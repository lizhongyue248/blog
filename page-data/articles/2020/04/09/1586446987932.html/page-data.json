{"componentChunkName":"component---src-templates-post-tsx","path":"/articles/2020/04/09/1586446987932.html","result":{"data":{"asciidoc":{"id":"b58f8759-46b8-5b56-bb3b-ce760765c28b","fields":{"slug":"/articles/2020/04/09/1586446987932.html","birthTime":"2020-04-09T15:43:08.036Z","modifiedTime":"2020-04-09T15:43:08.036Z"},"html":"<div id=\"toc\" class=\"toc\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div id=\"toctitle\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">Table of Contents</div>\n<ul class=\"sectlevel1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_一般情况\">一般情况</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_reactive_mongodb_auditing\">Reactive Mongodb Auditing</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_总结\">总结</a></li>\n</ul>\n</div>\n<div id=\"preamble\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>相信很多人都知道 Jpa 的一个非常强大的功能：审计。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>简单地说就是你提供一些审计的元数据，Jpa\n会给你自动根据这些元数据去填充你相应的信息。在它的实现中，其元数据就是我们的注解或者接口。通过注解或者接口，Jpa\n可以更好的自动填充你的实体类信息。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>举个栗子：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">class Customer {\n\n  /**\n   * 创建时间\n   */\n  @CreatedDate\n  private LocalDateTime createTime = LocalDateTime.now();\n\n  /**\n   * 创建用户\n   */\n  @CreatedBy\n  private String createUser;\n\n  /**\n   * 最后修改时间\n   */\n  @LastModifiedDate\n  private LocalDateTime modifyTime = LocalDateTime.now();\n\n  /**\n   * 最后修改用户\n   */\n  @LastModifiedBy\n  private String modifyUser;\n\n  // ...... 其他字段\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这四个字段如果在每个实体类创建、修改的时候手动设置无疑是非常麻烦的事情。但是我们通过上面的注解就可以实现\nJpa 的审计，让他帮我们去填充。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_一般情况\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">一般情况</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在传统模式中，配合 Spring Security\n去实现这一个过程是很简单的，只需要如下几步：</p>\n</div>\n<div class=\"olist arabic\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ol class=\"arabic\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>为实体类添加审计注解</p>\n<div class=\"olist arabic\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ol class=\"arabic\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><code>@CreatedDate</code> 创建时间</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><code>@CreatedBy</code> 创建用户</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><code>@LastModifiedDate</code> 最后修改时间</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><code>@LastModifiedBy</code> 最后修改用户</p>\n</li>\n</ol>\n</div>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>启动/配置类添加 <code>@EnableJpaAuditing</code> 开启审计</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>实体类添加 <code>@EntityListeners(AuditingEntityListener.class)</code>\n注解（在后面的版本中可以省略）</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这样就可以自动审计了，如果是自定义用户实体了的，需要自定义一下获取用户的方式，例如：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Configuration\npublic class UserAuditorHandle implements AuditorAware&lt;String&gt; {\n    @NotNull\n    @Override\n    public Optional&lt;String&gt; getCurrentAuditor() {\n        return Optional.ofNullable(SecurityContextHolder.getContext())\n                .map(SecurityContext::getAuthentication)\n                .map(Principal::getName);\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>但是这是在传统模式下，使用 servlet 的阻塞式情况下去完成的。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_reactive_mongodb_auditing\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">Reactive Mongodb Auditing</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>使用依赖：</p>\n</div>\n<div class=\"literalblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre>org.springframework.boot:spring-boot-starter-data-mongodb-reactive</pre>\n</div>\n</div>\n</blockquote>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>最近在实践响应式微服务的时候就发现代码审计是存在问题的，在 Reactive\n的环境下，需要下面几步：</p>\n</div>\n<div class=\"olist arabic\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ol class=\"arabic\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>同传统模式，为实体类添加审计注解</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>启动类添加 <code>@EnableMongoAuditing</code> 开启审计</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这样我们开启了部分的代码审计，这种模式下只会自动添加 <em>时间</em>\n类型的代码审计。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>但是我们如果需要用户的审计如何使用呢？<code>AuditorAware</code> 是不存在\n<code>Spring Security Reactive</code> 版本的。对于时间的审计，它存在一个\n<code>ReactiveAuditingEntityCallback</code> 进行审计。官方也在 jira 中提出提出了\n<a href=\"https://jira.spring.io/browse/DATACMNS-1231\">Auditing should support\nreactive security\ncontext</a>，但是至今为止快三年了，都没有去做。不过他倒是给出了一个解决方案，使用\n<code>EntityCallbacks</code> 来完成相应的 Reactive 审计。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>官网中给出了三个 <code>EntityCallbacks</code>：</p>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>注： Jpa 在执行任何操作之前所有的实体类都会转化为 <code>org.bson.Document</code></p>\n</div>\n</blockquote>\n</div>\n<table class=\"tableblock frame-all grid-all stretch\">\n<colgroup>\n<col style=\"width: 19%;\">\n<col style=\"width: 33%;\">\n<col style=\"width: 33%;\">\n<col style=\"width: 15%;\">\n</colgroup>\n<thead>\n<tr>\n<th class=\"tableblock halign-left valign-top\">Callback</th>\n<th class=\"tableblock halign-left valign-top\">Method</th>\n<th class=\"tableblock halign-left valign-top\">Description</th>\n<th class=\"tableblock halign-left valign-top\">Order</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">Reactive/BeforeConvertCallback</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\"><code>onBeforeConvert(T entity, String collection)</code></p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">在实体类转化为`org.bson.Document` 之前进行调用。</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\"><code>Ordered.LOWEST_PRECEDENCE</code></p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">Reactive/AuditingEntityCallback</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\"><code>onBeforeConvert(Object entity, String collection)</code></p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">标记审计的实体是\n<em>创建</em> 还是 <em>修改</em></p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">100</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">Reactive/BeforeSaveCallback</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\"><code>onBeforeSave(T entity, org.bson.Document target, String collection)</code></p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">在保存实体之前调用。可以修改要持久化的目标\n<code>Document</code>，其中包含所有映射的实体信息。</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\"><code>Ordered.LOWEST_PRECED</code></p></td>\n</tr>\n</tbody>\n</table>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>其中第一、三个为接口，第二个是一个类，就是它来完成时间的审计的。如何选择呢？总结了一下他们的适用场景</p>\n</div>\n<table class=\"tableblock frame-all grid-all stretch\">\n<colgroup>\n<col style=\"width: 35%;\">\n<col style=\"width: 65%;\">\n</colgroup>\n<thead>\n<tr>\n<th class=\"tableblock halign-left valign-top\">Callback</th>\n<th class=\"tableblock halign-left valign-top\">适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">Reactive/BeforeConvertCallback</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">所有的操作之前都会调用。可以对目标进行统一处理，只能获取到转化前的实体类。</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">Reactive/AuditingEntityCallback</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">他是第一种的接口的一个实现，在没有明确的字段能够识别当前实体是新建还是修改的情况下，可以参照这个实现类进行区分和修改。</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">Reactive/BeforeSaveCallback</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">只有使用 <code>save</code>\n方法之前会调用到这个方法，同时他可以对转化后的 <code>Document</code> 进行操作。</p></td>\n</tr>\n</tbody>\n</table>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>很明显，我们需要填充用户的审计信息但是不需要操作\n<code>Document</code>，那么就是需要统一处理，同时我可以根据 id\n去判断是否是新增的实体，所以就直接使用第一个了。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>Kotlin 版本</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">  @Bean\n  @Order(99)    // 可选\n  // 因为强转了会有警告，抑制一下，又因为实体类是 Java 的，他会要求我使用 = 访问属性\n  // 但是 Java 代码是不可以的，所以同样抑制下\n  @Suppress(\"UsePropertyAccessSyntax\", \"USELESS_CAST\")\n  fun userAuditingHandler() =\n    ReactiveBeforeConvertCallback { entity: Any, _: String -&gt;\n      ReactiveSecurityContextHolder.getContext()\n        .map { context -&gt; context.authentication.principal }\n        // 这里根据你的授权机制去修改，强转为对应的授权对象\n        .map { it as Jwt }\n        .map { it.claims[\"user_id\"].toString() }\n        .map {\n          val id = (entity as BaseEntity).getId()\n          if (id == null) entity.setCreateUser(it)\n          else entity.setModifyUser(it)\n          // 一定要强转回去，kotlin 里面 as 以后，下面代码的所有类型就全改变了\n          // 不然子类实体的字段会丢失\n          entity as Any\n        }.defaultIfEmpty(entity)\n      }</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>Java 版本</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Bean\npublic ReactiveBeforeConvertCallback&lt;Objects&gt; userAuditingHandler() {\n    return (entity, _) -&gt;\n        ReactiveSecurityContextHolder.getContext()\n            .map(securityContext -&gt; {\n                // 这里根据你的授权机制去修改，强转为对应的授权对象并获取用户信息\n                Jwt jwt = (Jwt) securityContext.getAuthentication().getPrincipal();\n                return jwt.getClaims().get(\"user_id\").toString();\n            })\n            .map(userId -&gt; {\n                String id = ((BaseEntity) entity).getId();\n                if (id == null) {\n                    ((BaseEntity) entity).setCreateUser(id);\n                } else {\n                    ((BaseEntity) entity).setModifyUser(id);\n                }\n                return entity;\n            }).defaultIfEmpty(entity);\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><strong>值得注意的是，对于 <code>ReactiveBeforeConvertCallback</code>，其 <code>entity</code>\n的类型是什么，他就会拦截什么类型的实体</strong>。这里是\n<code>Any/Object</code>，那么他就会拦截所有的实体。同理\n<code>Reactive/BeforeSaveCallback</code> 接口也是一样的。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_总结\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">总结</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>代码审计能够帮我节省不少麻烦事儿的。这次看了他审计的一些源码，其实一开始准备使用第二种他提供的实例方式来实现的，但是发现有几个难点。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><code>ReactiveAuditingEntityCallback</code> 中核心就是 <code>auditingHandlerFactory</code>\n里面的 <code>IsNewAwareAuditingHandler</code>，但是他需要一个 <code>PersistentEntities</code>\n传入，他需要一个 <code>MappingContext</code>\n上下文对象去创建。这就很麻烦了（我不会告诉你我找不到这个上下文怎么用。。。），所以在自己能够区分是新增还是编辑的情况下大可以自己实现一个简单版本的。</p>\n</div>\n</div>\n</div>","document":{"title":"Spring Reactive Mongodb Jpa Auditing 审计"},"pageAttributes":{"category":"spring","description":"相信很多人都知道 Jpa 的一个非常强大的功能：审计。我们就来聊聊他。","image":"https://img.hacpai.com/bing/20180313.jpg?imageView2/1/w/960/h/540/interlace/1/q/100","sort":null}}},"pageContext":{"slug":"/articles/2020/04/09/1586446987932.html","next":{"document":{"title":"Spring Reactive Mongodb Jpa Repository 总结"},"fields":{"slug":"/articles/2020/04/13/1586760856276.html"}},"previous":{"document":{"title":"kotlin 1.3.70 中 kotlinx.serialization 升级到 0.20.0"},"fields":{"slug":"/articles/2020/03/11/1583919686142.html"}}}},"staticQueryHashes":["3069561552","3673333084"]}