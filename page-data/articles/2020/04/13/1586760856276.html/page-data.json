{"componentChunkName":"component---src-templates-post-tsx","path":"/articles/2020/04/13/1586760856276.html","result":{"data":{"asciidoc":{"id":"d1b5812f-77f3-523f-a1f2-f44dde6df265","fields":{"slug":"/articles/2020/04/13/1586760856276.html","birthTime":"2020-04-13T06:54:16.338Z","modifiedTime":"2020-04-13T07:00:58.962Z"},"html":"<div id=\"toc\" class=\"toc\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div id=\"toctitle\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">Table of Contents</div>\n<ul class=\"sectlevel1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_从方法名派生查询\">从方法名派生查询</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_使用_query_自定义\">使用 <code>@Query</code> 自定义</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_使用_reactivequerybyexampleexecutor_接口\">使用 <code>ReactiveQueryByExampleExecutor</code> 接口</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_使用_reactivequerydslpredicateexecutor\">使用 ReactiveQuerydslPredicateExecutor</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_自定义某个_repository_的复杂操作\">自定义某个 Repository 的复杂操作</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_类似于_jparepository_的_baserepository\">类似于 JpaRepository 的 BaseRepository</a>\n<ul class=\"sectlevel2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_expandrepository\"><code>ExpandRepository</code></a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_baserepository\"><code>BaseRepository</code></a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_高级用法\">高级用法</a></li>\n</ul>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_总结\">总结</a></li>\n</ul>\n</div>\n<div id=\"preamble\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>上一篇中提到了 <code>Reactive data Jpa</code>\n的一个强大功能：审计。而这篇文章则是对于 Repository implement\n使用方式的总结。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在我们使用 <code>Jpa</code> 的时候，有如下几种个人觉得比较规范的方式来进行使用：</p>\n</div>\n<div class=\"olist arabic\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ol class=\"arabic\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><a href=\"https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods\">从方法名称派生查询</a></p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><a href=\"https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.at-query\">使用\n<code>@Query</code> 注解自定义</a></p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>对于复杂的数据查询，可以使用\n<a href=\"https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#query-by-example\">QueryByExampleExecutor</a>\n接口</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>对于复杂的数据操作，我们有\n<a href=\"https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#specifications\">JpaSpecificationExecutor</a>\n接口，也可以使用\n<a href=\"https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#core.extensions\"><code>Querydsl</code>\n扩展</a></p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>我们如果需要职责分离，希望将数据库的操作 <strong>完全</strong> 封装到 Repository\n里面，我们可以 <a href=\"https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.single-repository-behavior\">自定义某个\nRepository 的复杂操作</a></p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>当然，也可以自定义一个 <a href=\"https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.customize-base-repository\">类似于\nJpaRepository 的 BaseRepository</a></p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>直接使用 <code>EntityManager</code></p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>有了以上这些方式就完全够我们大部分需求了。但是为什么还会有这篇文章呢？原因和上篇文章一样，因为\n<code>Reactive</code>。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>对于 Reactove Mongo\n来说，传统的七点都是可以继续使用的，他们实现的方式和以前都是大同小异。我们可以直接使用\n<code>ReactiveMongoOperations</code> 来替代 <code>EntityManager</code> 进行数据库的。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_从方法名派生查询\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">从方法名派生查询</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这个是最为常用的一种，也是最为方便的使用方式。</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">  /**\n   * 通过 [ids] 查询\n   */\n  fun findAllByIdContaining(ids: List&lt;String&gt;): Flux&lt;E&gt;\n\n  /**\n   * 查询 isEnable 字段为 true 的数量\n   */\n  fun countAllByIsEnableTrue(): Mono&lt;Long&gt;</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>唯一不同的就是返回值了，同时需要注意的是，在 Reactive\n的环境中，他是没有办法获取到分页的对象的，文档中明确指出：</p>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>The <code>Page</code> return type (as in <code>Mono</code>) is not supported by reactive\nrepositories.</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在 Reactive 仓库中 Page 类型的返回值（作为 Mono）是不被支持的。</p>\n</div>\n</blockquote>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>所以我们写出来的分页方法如下：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">/**\n * 分页查询，名称不能直接写 findAll，否则会报错，必须至少一个条件\n */\nfun findAllByIsEnableIsTrue(pageable: Pageable): Flux&lt;E&gt;</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>那么分页怎么写呢？Kotlin 里面自然就可以用协程了</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">  override suspend fun page(pageable: Pageable): Page&lt;E&gt; {\n    val content = repository.findAllByIsEnableIsTrue(pageable).collectList().awaitSingle()\n    val count = repository.countAllByIsEnableTrue().awaitSingle()\n    return PageImpl(content, pageable, count)\n  }</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>当然你也可以用 <code>mono</code> 将它包裹起来，返回值就变成了 <code>Mono&lt;Page&lt;E&gt;&gt;</code>\n了。如果不使用协程，需要操作两个不同类型的 Mono，我们可以使用 <code>Mono.zip</code>\n方法来完成</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">  override suspend fun page(pageable: Pageable, entity: E): Mono&lt;Page&lt;E&gt;&gt; =\n    Mono.zip(repository.findAllByIsEnableIsTrue(pageable).collectList(), repository.countAllByIsEnableTrue()) { content, count -&gt;\n      PageImpl(content, pageable, count)\n    }</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>使用起来和以前方式还是有些许区别。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_使用_query_自定义\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">使用 <code>@Query</code> 自定义</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这种就没啥可以说的了</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">  /**\n   * Get menu by [roles].\n   * If one of the lines contains one of the [roles], will match.\n   */\n  @Query(\"{ 'roles': { '\\$in': ?0 }}\")\n  fun searchByRoles(roles: List&lt;Long&gt;): Flux&lt;Route&gt;</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>当然，在以前，我们可以在里面写更新、创建的操作，但是在 Mongo\n中是不可以的。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_使用_reactivequerybyexampleexecutor_接口\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">使用 <code>ReactiveQueryByExampleExecutor</code> 接口</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>我们只需要构建一个 <code>Example</code> 过去就可以查询了</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">val all: Flux&lt;User&gt; = repository.findAll(Example.of(entity));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>但是他却没有提供分页的接口，例如我想要的</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">fun findAll(example: Example&lt;E&gt;, pageable: Pageable): FLux&lt;E&gt;</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>他就没有，后面会说咋自定义。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>当然还有一种用法，对于动态条件匹配，我们可以预先准备一个自定义的匹配器\n<a href=\"https://docs.spring.io/spring-data/mongodb/docs/current/reference/html/#query-by-example.matchers\">ExampleMatcher</a>：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">  private fun getPageMatcher() = ExampleMatcher.matching()\n      // 以下字段模糊匹配\n      .withMatcher(\"name\", ExampleMatcher.GenericPropertyMatcher().contains())\n      .withMatcher(\"spell\", ExampleMatcher.GenericPropertyMatcher().contains())\n      .withMatcher(\"remark\", ExampleMatcher.GenericPropertyMatcher().contains())\n      // 忽略为 null 字段\n      .withIgnoreNullValues()</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>也是可以满足我们部分需求了的。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_使用_reactivequerydslpredicateexecutor\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">使用 ReactiveQuerydslPredicateExecutor</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>Reactive 是没有 <code>Specification</code> 的，所以只能是Spring 是整合的\n<a href=\"https://http://www.querydsl.com%22\">Querydsl</a> ，值得注意的是，这个是在\n<strong>2.2</strong> 版本以后才引入的支持，在之前的版本，是不支持 Reactive\n的。所以需要引入以下它的依赖：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-markdown\" data-lang=\"markdown\">groupId：com.querydsl\nartifactId：querydsl-apt</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>它的使用流程先生成 <code>@Entity</code> 注解下的实体类，编译以后会生成 <code>Q</code>\n开头的实体类，通过这个实体类进行 DSL 操作。不过他目前只支持 maven\n插件以及 gradle 5 以下的插件注解生成，见\n<a href=\"https://github.com/ewerk/gradle-plugins\">github</a> ：</p>\n</div>\n<table class=\"tableblock frame-all grid-all stretch\">\n<colgroup>\n<col style=\"width: 25%;\">\n<col style=\"width: 25%;\">\n<col style=\"width: 25%;\">\n<col style=\"width: 25%;\">\n</colgroup>\n<thead>\n<tr>\n<th class=\"tableblock halign-left valign-top\">Plugin</th>\n<th class=\"tableblock halign-left valign-top\">≥ 2.1</th>\n<th class=\"tableblock halign-left valign-top\">≥ 3.3</th>\n<th class=\"tableblock halign-left valign-top\">≥ 5.0</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">annotation-processor-plugin</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">≤1.0.3</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">≥1.0.4</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">ø</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">artifactory-deb-publish-plugin</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">≤1.0.1</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">≥1.0.2</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">ø</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">auto-value-plugin</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">≤1.0.7</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">≥1.0.8</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">ø</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">dagger-plugin</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">≤1.0.7</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">≥1.0.8</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">ø</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">integration-test-plugin</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">≤1.0.8</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">≥1.0.9</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">ø</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">jaxb2-plugin</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">≤1.0.2</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">≥1.0.3</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">ø</p></td>\n</tr>\n<tr>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">querydsl-plugin</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">≤1.0.7</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\">≥1.0.8</p></td>\n<td class=\"tableblock halign-left valign-top\"><p class=\"tableblock\"><code>INCUBATING</code></p></td>\n</tr>\n</tbody>\n</table>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>对于 Gradle 大于 5.0\n的是正在开发中的，所以目前是无法进行注解生成的，不过\n<a href=\"https://stackoverflow.com/questions/54134455/java-11-querydsl-4-gradle-5-springboot-2-1-not-generating-qclasses\">stackoverflow</a>\n上面有些许解决办法，但我尚未尝试。``曲线救国'' 的方式就是使用 IDEA\n的注解处理器，如果是 Kotlin 的就可以使用 Kapt\n注解处理器。当然这里就不做演示了，具体可以参见\n<a href=\"http://www.querydsl.com/static/querydsl/latest/reference/html/\">官方文档</a>。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_自定义某个_repository_的复杂操作\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">自定义某个 Repository 的复杂操作</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这种方式个人觉得是不太好用的一种方式，有以下原因</p>\n</div>\n<div class=\"olist arabic\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ol class=\"arabic\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>指定定义一个 Repository 的复杂操作</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>需要实现那个 Repository\n接口，那么就必须实现它的所有方法，就会失去根据名称派生查询优势</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这种比较鸡肋，比如有几个 Repository 具有同一个方法，但是其他的\nRepository\n又没有，同时这个方法又没法自动推断或者是更新、删除等操作，这个时候才会抽出一个部分共用的的\nRepository 来实现。但是有个问题就是几个 Repsitory\n对应的实体都是不一样的，那么抽出来的实体只能是 BaseEntity\n的子类，也就是公共实体，而 BaseEntity 又是所有 Entity\n的父类，那就是通用的了，那我为啥还要抽出来=-=</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>所以个人想到的只有一个场景，你有一个 Repsoitory，但是这个 Repsoitory\n的部分方法需要 Jpa\n通过方法名称派生查询，部分方法需要自己去实现，那么就可以单独写一个去用了。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这个实现起来很简单</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">interface CustomizedUserRepository {\n  fun someCustomMethod(User user);\n}</code></pre>\n</div>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">class CustomizedUserRepositoryImpl implements CustomizedUserRepository {\n\n  fun someCustomMethod(User user) {\n    // Your custom implementation\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><strong>注意：实现类必须以 <code>Impl</code>\n结尾</strong>，如果不是需要修改注解参数 <code>@EnableReactiveMongoRepositories(repositoryImplementationPostfix = \"Impl\")</code>\n，默认是 <code>Impl</code></p>\n</div>\n</blockquote>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_类似于_jparepository_的_baserepository\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">类似于 JpaRepository 的 BaseRepository</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这种方式个人觉得非常常用，在我的项目中我写了两个 <code>BaseRepository</code>。</p>\n</div>\n<div class=\"ulist\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ul data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><code>ExpandRepository</code>：用来自定义各种实现的方法，继承\n<code>ReactiveMongoRepository</code></p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><code>BaseRepository</code>： 用来通过方法名派生查询的方法，继承\n<code>ExpandRepository`和 `ReactiveQuerydslPredicateExecutor</code></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这样就能够很方便的定义许多操作。来说说他们的实现吧</p>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_expandrepository\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><code>ExpandRepository</code></h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>接口很简单，这里我们写一个他 <code>ReactiveQueryByExampleExecutor</code>\n没有提供的方法，也就是分页</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">@NoRepositoryBean\ninterface ExpandRepository&lt;E: BaseEntity&lt;E&gt;&gt;: ReactiveMongoRepository&lt;E, String&gt; {\n\n  /**\n   * Find all by [example] and [pageable].\n   */\n  fun findAll(example: Example&lt;E&gt;, pageable: Pageable): Flux&lt;E&gt;\n\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>然后定一个实现类</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">class ExpandRepositoryImpl&lt;E : BaseEntity&lt;E&gt;&gt;(\n    private val entityInformation: MongoEntityInformation&lt;E, String&gt;,\n    private val mongoOperations: ReactiveMongoOperations\n) : SimpleReactiveMongoRepository&lt;E, String&gt;(entityInformation, mongoOperations), ExpandRepository&lt;E&gt; {\n\n  override fun findAll(example: Example&lt;E&gt;, pageable: Pageable): Flux&lt;E&gt; =\n      mongoOperations.find(\n          Query(Criteria().alike(example))\n              .collation(entityInformation.collation)\n              .with(pageable),\n          example.probeType,\n          entityInformation.collectionName\n      )\n\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>最后修改注解就可以了</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">@EnableReactiveMongoRepositories(repositoryBaseClass = ExpandRepositoryImpl::class)</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_baserepository\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><code>BaseRepository</code></h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这就是一个通过方法名或者 <code>@Query</code> 派生的接口</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">@NoRepositoryBean\ninterface BaseRepository&lt;E : BaseEntity&lt;E&gt;&gt; : ExpandRepository&lt;E&gt;, ReactiveQuerydslPredicateExecutor&lt;E&gt; {\n\n  fun findAllByIdContaining(ids: List&lt;String&gt;): Flux&lt;E&gt;\n\n  fun countAllByIsEnableTrue(): Mono&lt;Long&gt;\n\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_高级用法\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">高级用法</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>当然，还有一个高级用法，就是我们可以自定义它的工厂以及工厂 Bean</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">/**\n * This bean will be injected in [cn.edu.gzmu.university.common.MongodbConfig].\n * It will give a [cn.edu.gzmu.university.common.base.ExpandRepository] implement and\n * a [ExpandMongoRepositoryFactory] to create repository.\n *\n * @author &lt;a href=\"https://echocow.cn\"&gt;EchoCow&lt;/a&gt;\n * @date 2020/4/12 下午7:14\n */\nclass ExpandRepositoryFactoryBean&lt;T : Repository&lt;E, String&gt;, E : BaseEntity&lt;E&gt;&gt;(\n    repositoryInterface: Class&lt;out T&gt;\n) : ReactiveMongoRepositoryFactoryBean&lt;T, E, String&gt;(repositoryInterface) {\n\n  /**\n   * Get customize factory instance.\n   */\n  override fun getFactoryInstance(operations: ReactiveMongoOperations): RepositoryFactorySupport =\n      ExpandMongoRepositoryFactory&lt;E&gt;(operations)\n\n  @Suppress(\"UNCHECKED_CAST\")\n  private class ExpandMongoRepositoryFactory&lt;E : BaseEntity&lt;E&gt;&gt;(\n      private val mongoOperations: ReactiveMongoOperations\n  ) : ReactiveMongoRepositoryFactory(mongoOperations) {\n\n    /**\n     * Get our customize repository base class.\n     */\n    override fun getRepositoryBaseClass(metadata: RepositoryMetadata): Class&lt;*&gt; = ExpandRepositoryImpl::class.java\n\n    /**\n     * Get target repository.\n     */\n    override fun getTargetRepository(information: RepositoryInformation): Any {\n      val entityInformation: MongoEntityInformation&lt;*, Serializable&gt; = getEntityInformation(information.domainType)\n      return ExpandRepositoryImpl(entityInformation as MongoEntityInformation&lt;E, String&gt;, mongoOperations)\n    }\n\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>当然，不要忘记添加如下注解：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-kotlin\" data-lang=\"kotlin\">@EnableReactiveMongoRepositories(repositoryFactoryBeanClass = ExpandRepositoryFactoryBean::class)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这个是最简单的一个实现。<code>ExpandRepositoryFactoryBean</code> 会注入一个\n<code>ExpandMongoRepositoryFactory</code> ，然后他就可以生产我们的 repository base\nclass 来完成自定义 repository\n实现。为什么需要这个高级用法呢？一个最明显的栗子就是在它的父类\n<code>ReactiveMongoRepositoryFactoryBean</code> 中，有一个创建工厂的方法：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Override\nprotected RepositoryFactorySupport createRepositoryFactory() {\n\n    RepositoryFactorySupport factory = getFactoryInstance(operations);\n\n    if (createIndexesForQueryMethods) {\n        factory.addQueryCreationListener(new IndexEnsuringQueryCreationListener(\n            collectionName -&gt; IndexOperationsAdapter.blocking(operations.indexOps(collectionName))));\n    }\n\n    return factory;\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><code>createRepositoryFactory</code> 是用来创建工厂的，他在这里加入了一个\n<code>IndexEnsuringQueryCreationListener</code>，他会去检查\n<code>RepositoryQuery</code>，并且为它的属性创建索引。那么我们自然可以模仿他去创建一些其他的监听器并作出一些实现。再比如我们可以通过\n<code>addRepositoryProxyPostProcessor</code> 添加\n<code>RepositoryProxyPostProcessor</code>，在进行代理之前操作工厂。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>同时我们也可以通过工厂的 <code>getQueryLookupStrategy</code>\n方法自定义工厂的查询查找策略，默认是 <code>MongoQueryLookupStrategy</code>。</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">    @Override\n    protected Optional&lt;QueryLookupStrategy&gt; getQueryLookupStrategy(@Nullable Key key,\n            QueryMethodEvaluationContextProvider evaluationContextProvider) {\n        return Optional.of(new MongoQueryLookupStrategy(operations, evaluationContextProvider, mappingContext));\n    }</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这些都是一些可以进行自定义的高级操作。在某些场合还是非常有用的。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_总结\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">总结</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>Jpa 实在是太过方便，除了上面几种我们还可以直接注入\n<code>ReactiveMongoOperations</code>、<code>ReactiveMongoTemplate</code>\n来直接操作数据库也是十分方便，事实上 Repository\n他们的底层其实也就是这两样。总的来说 Jpa\n给我们提供太多的方便，对于许多地方的自定义配置都留了很大很大的空间。个人喜欢\nJpa 比喜欢 Mybatis 好多了！</p>\n</div>\n</div>\n</div>","document":{"title":"Spring Reactive Mongodb Jpa Repository 总结"},"pageAttributes":{"category":"spring","description":"上一篇中提到了 Reactive data Jpa 的一个强大功能：审计。而这篇文章则是对于 Repository implement 使用方式的总结。","image":"https://img.hacpai.com/bing/20190430.jpg?imageView2/1/w/960/h/540/interlace/1/q/100","sort":null}}},"pageContext":{"slug":"/articles/2020/04/13/1586760856276.html","next":{"document":{"title":"Phpstorm + Docker / Docker Compose + xdebug 环境搭建"},"fields":{"slug":"/articles/2020/08/01/1596268325013.html"}},"previous":{"document":{"title":"Spring Reactive Mongodb Jpa Auditing 审计"},"fields":{"slug":"/articles/2020/04/09/1586446987932.html"}}}},"staticQueryHashes":["3069561552","3673333084"]}