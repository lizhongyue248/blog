{"componentChunkName":"component---src-templates-post-tsx","path":"/articles/2020/01/20/1579503807596.html","result":{"data":{"asciidoc":{"id":"ecc365be-34fe-57ab-b74f-05645165be88","fields":{"slug":"/articles/2020/01/20/1579503807596.html","birthTime":"2020-01-20T07:03:27.648Z","modifiedTime":"2020-04-25T06:25:03.960Z"},"html":"<div id=\"toc\" class=\"toc\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div id=\"toctitle\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">Table of Contents</div>\n<ul class=\"sectlevel1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_系列文章\">系列文章</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_refresh_token_第一次有效\">REFRESH_TOKEN 第一次有效</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_自定义客户端信息\">自定义客户端信息</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_多类型混合存储\">多类型混合存储</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_授权服务器资源服务器共存\">授权服务器、资源服务器共存</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_资源服务器安全配置顺序\">资源服务器安全配置顺序</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_安全退出\">安全退出</a>\n<ul class=\"sectlevel2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_自定义退出端点\">自定义退出端点</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_自定义退出页面\">自定义退出页面</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_自定义退出成功处理器\">自定义退出成功处理器</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_spring_security_配置\">spring security 配置</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_效果\">效果</a></li>\n</ul>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_jwk_端点\">JWK 端点</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_自定义端点路径\">自定义端点路径</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_rbac_动态权限控制\">RBAC 动态权限控制</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_传统项目的过渡\">传统项目的过渡</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_测试\">测试</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_总结\">总结</a></li>\n</ul>\n</div>\n<div id=\"preamble\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"admonitionblock important\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<table>\n<tbody><tr>\n<td class=\"icon\">\n<i class=\"fa icon-important\" title=\"Important\"></i>\n</td>\n<td class=\"content\">\n<strong>注意注意：本文章适用于5.3以前的spring security以及spring boot 2.3.x\n以前的 oauth，以下内容应该为过时！spring 提供新的 oauth2\n授权服务器。目前正在https://spring.io/blog/2019/11/14/spring-security-oauth-2-0-roadmap-update[实验性阶段]</strong>\n</td>\n</tr>\n</tbody></table>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>时隔半年，终于要来填坑了。不过经过这段时间的学习和实践，确实解决了不少问题。现在在这里一一记录一下。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>不过在这之前，还是需要说一下19年11月一件关于 spring security oauth\n的大事，参见官网文章\n<a href=\"https://spring.io/blog/2019/11/14/spring-security-oauth-2-0-roadmap-update\">Spring\nSecurity OAuth 2.0 Roadmap Update</a>。主要有以下两个点：</p>\n</div>\n<div class=\"olist arabic\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ol class=\"arabic\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><strong>不再支持 OAuth2 授权服务器</strong>。</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>spring security oauth 迁移至 spring security 中</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><strong>但是由于第一点收到了太多用户的反馈，建议继续支持授权服务器，所以现在进行重新决议，目前正在决议中。另外还有一个项目生命周期的维护：</strong></p>\n</div>\n<div class=\"admonitionblock note\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<table>\n<tbody><tr>\n<td class=\"icon\">\n<i class=\"fa icon-note\" title=\"Note\"></i>\n</td>\n<td class=\"content\">\nThe currently supported branches are 2.3.x and 2.4.x. The 2.3.x line\nwill reach EOL in March 2020. We will support the 2.4.x line at least\none year after reaching feature parity.\n</td>\n</tr>\n</tbody></table>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>目前官方支持的两个版本就是 spring security oauth 2.3.x 和\n2.4.x，其中，2.3.x 版本会在 2020 年 3 月的时候停止支持和维护，而 2.4.x\n会至少一年后停止支持和维护。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在 spring security oauth 的项目中的 master\n分支（即2.4.x版本），相关的注解如\n<code>EnableAuthorizationServer</code>，都被标记为了 <strong>过时</strong> 。并给出了迁移 spring\nsecurity 的 wiki\n链接：https://github.com/spring-projects/spring-security/wiki/OAuth-2.0-Migration-Guide[OAuth-2.0-Migration-Guide]。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>但是现在的主要依赖（如现在的spring boot 2.2.3）都还是 spring security\noauth 的 2.3.x 分支，也就是说目前还是可以使用的。预计在三月，会使用它的\n2.4.x\n分支了。但是个人觉得自定义授权服务器还是非常重要的，很多场景下都适用，并且可以自己规划非常方便。所以也是希望他继续支持授权服务器的，并且在近一年内，spring\nsecurity oauth 的授权服务器都会继续使用，我也在我们学校搭建了一个 oauth2\n的授权中心：https://github.com/gzmuSoft/authorization-server[authorization-server]。这段时间也踩了不少坑，记录一下。</p>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>注意：以下内容依旧使用 spring security oauth 项目。</p>\n</div>\n</blockquote>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_系列文章\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">系列文章</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"olist arabic\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ol class=\"arabic\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><a href=\"https://echocow.cn/articles/2019/07/14/1563082088646.html\">较为详细的学习\noauth2 的四种模式其中的两种授权模式</a></p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><a href=\"https://echocow.cn/articles/2019/07/14/1563082247386.html\">spring boot\noauth2 自动配置实现</a></p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><a href=\"https://echocow.cn/articles/2019/07/14/1563096109754.html\">spring\nsecurity oauth2 授权服务器配置</a></p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><a href=\"https://echocow.cn/articles/2019/07/20/1563611848587.html\">spring\nsecurity oauth2 资源服务器配置</a></p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><a href=\"https://echocow.cn/articles/2019/07/30/1564498598952.html\">spring\nsecurity oauth2 自定义授权模式（手机、邮箱等）</a></p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>spring security oauth2 踩坑记录</p>\n</li>\n</ol>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_refresh_token_第一次有效\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">REFRESH_TOKEN 第一次有效</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在刷新 token 的时候，携带 <code>refresh_token</code> 去请求 <code>/oauth/token</code>\n端点，会生成新的 <code>access_token</code> 和\n<code>refresh_token</code>，但是你会发现，<strong>只有第一次的 <code>refresh_token</code>\n可以使用，后面的都不能够使用</strong>。这个问题主要原因来自于授权服务器端点配置，<strong>默认情况下，授权服务器的端点配置会有这么一个属性：<code>reuseRefreshToken</code>\n表示重复使用刷新令牌</strong>。也就是说会一直重复使用第一次请求到的\n<code>refresh_token</code>，而后面的 <code>refresh_token</code> 就是无效的了。</p>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>参见\n<code>org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer</code></p>\n</div>\n</blockquote>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>所以我们需要修改一下这个设置</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">public class Oauth2AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter{\n    // ...\n    @Override\n    public void configure(AuthorizationServerEndpointsConfigurer endpoints) {\n        endpoints..reuseRefreshTokens(false);\n    }\n    // ...\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_自定义客户端信息\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">自定义客户端信息</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>很多时候我要从数据库中读取客户端信息，但是不希望使用它的表结构来创建表，这个时候需要我们去自定义客户端信息。就像自定义用户信息一样，需要实现\n<code>org.springframework.security.oauth2.provider.ClientDetailsService</code>\n接口。它的返回值是\n<code>org.springframework.security.oauth2.provider.ClientDetails</code>。所以这里有两种实现方式</p>\n</div>\n<div class=\"ulist\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ul data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>第一种实体类实现 <code>ClientDetails</code> 接口</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>第二种就是在写一个转换的方法，把你的 <code>ClientDetails</code> 转换为它的\n<code>ClientDetails</code></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>第一种可以参见： <a href=\"https://github.com/xkcoding/spring-boot-demo/blob/dev/spring-boot-demo-oauth/spring-boot-demo-oauth-authorization-server/src/main/java/com/xkcoding/oauth/entity/SysClientDetails.java\"><strong>SysClientDetails</strong></a></p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这里我使用的是第二种。</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">public org.springframework.security.oauth2.provider.ClientDetails buildSpringClientDetails() {\n    BaseClientDetails details = new BaseClientDetails(clientId, resourceIds, scope, grantTypes, authorities, redirectUrl);\n    details.setClientSecret(clientSecret);\n    details.setAutoApproveScopes(Collections.singletonList(autoApproveScopes));\n    details.setAccessTokenValiditySeconds(accessTokenValidity);\n    details.setRefreshTokenValiditySeconds(refreshTokenValidity);\n    details.setAdditionalInformation(JSON.parseObject(additionalInformation));\n    return details;\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>然后将我们写的实现 <code>ClientDetailsService</code> 接口的 service 配置进去即可：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">public class Oauth2AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {\n    // ......\n    @Override\n    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {\n        // 从数据库读取我们自定义的客户端信息\n        clients.withClientDetails(sysClientDetailsService);\n    }\n    // ......\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_多类型混合存储\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">多类型混合存储</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>我的一个需求就是，客户端信息我需要持久化存储，存在 <code>postgresql</code>\n里面，而我的 <code>token</code> 相关的需要频繁取出或者修改，所以我希望他存在\n<code>redis</code> 里面并且需要使用 jwt\n非对称密钥转换。那么我就要从两个不同的地方取出不同的东西。所以我们需要给他两个东西</p>\n</div>\n<div class=\"olist arabic\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ol class=\"arabic\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><code>RedisTokenStore</code>：从 Redis 中获取 token</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><code>ClientDetailsService</code> ：从 Postgresql 中获取客户端信息</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这个时候 <code>JwtTokenStore</code> 不是必须的，需要的是 <code>JwtAccessTokenConverter</code>\n来进行令牌的转换。</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Bean\n@Primary\npublic TokenStore tokenStore() {\n    return new RedisTokenStore(redisConnectionFactory);\n}\n\n@Bean\npublic JwtAccessTokenConverter jwtAccessTokenConverter() {\n    final JwtAccessTokenConverter accessTokenConverter = new JwtAccessTokenConverter();\n    accessTokenConverter.setKeyPair(keyPair());\n    return accessTokenConverter;\n}\n\n@Bean\npublic KeyPair keyPair() {\n    KeyStoreKeyFactory keyStoreKeyFactory = new KeyStoreKeyFactory(new ClassPathResource(\"oauth.jks\"), \"123456\".toCharArray());\n    return keyStoreKeyFactory.getKeyPair(\"oauth\");\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>同样，在有其他的组合需求的时候也只需要提供相应的实现就可以了。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_授权服务器资源服务器共存\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">授权服务器、资源服务器共存</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这个是比较头疼的地方了。头疼在哪里呢？就是头疼在 <code>CSRF</code> 这么个东西。</p>\n</div>\n<div class=\"admonitionblock tip\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<table>\n<tbody><tr>\n<td class=\"icon\">\n<i class=\"fa icon-tip\" title=\"Tip\"></i>\n</td>\n<td class=\"content\">\n参见：\n <a href=\"https://zh.wikipedia.org/zh/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%5D(https://zh.wikipedia.org/zh/跨站请求伪造)\">CSRF\n跨站请求伪造</a>\n</td>\n</tr>\n</tbody></table>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>我希望我的项目即是资源服务器，又是授权服务器。说白了他能够提供令牌发放的功能，但是也通过简单的一些查询的功能。<strong>但是当他作为授权服务器的时候，使用授权码模式的时候，他是一个使用模板引擎的前后端未分离的项目，而当他作为资源服务器的时候，他是一个前后端分离的提供\nAPI 服务的项目。那么这个时候 CSRF 就比较棘手了</strong>。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在前后端未分离的情况下，需要提交 post 请求的时候都要经过 <code>CSRF</code>\n认证才可以进行提交，所以你不能够简单粗暴的直接关闭\n<code>CSRF</code>，因为他可能带来安全问题。而在前后端分离的情况下我们使用了 JWT\n非对称加密，所以是不存在 <code>CSRF</code> 安全的问题的，</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>就目前而言，我并没有找到一个好的方式来处理 POST 请求下的 CSRF\n问题，一个方法就是，不使用 <code>@EnableResourceServer</code>\n自己编写一个资源服务器的相关配置。但是太过于复杂了。当然还有其他曲线救国的方法，比如自己定义一些过滤规则，或者自己手动加上\n<code>csrf_token</code> 等，不过都是有一定的代码量的。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>个人认为最佳的实践就是，授权服务器提供部分资源服务器的功能，比如查询一些相关的数据，也就是只提供\nGET\n方法，而修改数据则是单独用一个资源服务器来完成。授权服务器只提供发放、校验令牌和一些信息的查询功能，<strong>不提供增删改等复杂的功能</strong>，这样也能够减少授权服务器的压力。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_资源服务器安全配置顺序\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">资源服务器安全配置顺序</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>当我配置资源服务器的时候，会涉及到 spring security 相关的配置和 spring\nsecurity oauth resource server\n相关的配置。这里需要非常注意他们的顺序问题：</p>\n</div>\n<div class=\"ulist\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ul data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>spring secruity 需要继承 <code>WebSecurityConfigurerAdapter</code> ，order 为 100</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>spring security oauth resource server 需要继承\n<code>ResourceServerConfigurerAdapter</code>， order 为 3</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>他们两个都会对安全进行控制，所以要很好的调配。个人建议完全只交给一个去完成安全的控制，order\n越小，优先级越高。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_安全退出\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">安全退出</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>什么是安全退出呢？我个人的理解就是点击退出以后，它的 <code>token</code>\n完全失效了。举个栗子：</p>\n</div>\n<div class=\"olist arabic\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ol class=\"arabic\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>小明在家登录了，获取了一个令牌 <code>access_token1</code>。</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>小明在家没有退出，去公司又登录了，获取到了同一个令牌 <code>access_token1</code></p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>晚上小明回家了，突然想起公司的电脑还保留自己的登录状态，但是又不能够叫别人帮忙退出登录或者删除登录状态。</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>他只需要在家安全退出，那么 <code>access_token1</code>\n将会被完全销毁，在家、在公司，都不再保持登录状态。</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>他在家安全退出后再次登录，获取了一个新的令牌 <code>access_token2</code>。</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>总结就是 ``<strong>一处退出，处处退出</strong>''。当然，这种模式只有在 <strong>授权码模式</strong>\n有效，非授权码模式客户端只要删除本地存储的令牌即可，但是没有办法做到安全退出的。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在授权码模式下，我们登录是要在授权服务器这边进行登录的，所以在授权服务器这边存在用户相关的\n<code>session</code>，因此退出的时候我们也要来授权服务器这边进行一次退出，再去客户端那边进行一次退出。因此我们需要客户端那边传递一个退出完成的回调地址给我们进行跳转，我们主要有如下步骤：</p>\n</div>\n<div class=\"olist arabic\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ol class=\"arabic\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>自定义退出端点</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>自定义退出页面</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>自定义退出成功处理器</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>spring security 配置</p>\n</li>\n</ol>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_自定义退出端点\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">自定义退出端点</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>就是写一个控制器</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Controller\n@RequestMapping(\"/oauth\")\n@RequiredArgsConstructor\npublic class OauthController {\n    @GetMapping(\"/logout\")\n    public ModelAndView logoutView(\n            @RequestParam(\"redirect_url\") String redirectUrl,\n            // 如果存在客户端 id，就是安全退出，否则只是普通退出\n            @RequestParam(name = \"client_id\", required = false) String clientId,\n            // 登录用户的信息\n            Principal principal) {\n        if (Objects.isNull(principal)) {\n            // 如果用户的 session 已经失效，那么授权服务器这边是已经没有用户信息了的\n            // 直接重定向到回调地址\n            return new ModelAndView(new RedirectView(redirectUrl));\n        }\n        ModelAndView view = new ModelAndView();\n        // 视图名称\n        view.setViewName(\"logout\");\n        /// 用户名称\n        view.addObject(\"user\", principal.getName());\n        view.addObject(\"redirectUrl\", redirectUrl);\n        view.addObject(\"clientId\", clientId);\n        return view;\n    }\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_自定义退出页面\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">自定义退出页面</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>页面各有不同，可以参考我写的\n<a href=\"https://github.com/gzmuSoft/authorization-server/blob/master/src/main/resources/templates/logout.html\">logout.html</a>。注意\nPOST 提交需要携带 <code>csrf_token</code>。</p>\n</div>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_自定义退出成功处理器\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">自定义退出成功处理器</h3>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Slf4j\n@Component\n@AllArgsConstructor\npublic class AuthLogoutSuccessHandler implements LogoutSuccessHandler {\n    private final @NonNull Oauth2Helper oauth2Helper;\n\n    @Override\n    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException {\n        String redirectUrl = request.getParameter(\"redirectUrl\");\n        // 一般来说回调地址是必填的，不会有为空的情况\n        // 但是如果用户直接浏览器输入授权服务器的退出地址，就可能不存在\n        // 所以需要判断一下，如果没有就让他重定向到登录页面\n        if (StringUtils.isBlank(redirectUrl)) {\n            redirectUrl = \"/oauth/login\";\n        }\n        String clientId = request.getParameter(\"clientId\");\n        // 如果客户端 id 不为空，就是安全退出，需要清除内存或者redis中的当前用户的令牌信息\n        if (StringUtils.isNoneBlank(clientId)) {\n            oauth2Helper.safeLogout(clientId, authentication);\n        }\n        // 设置状态码和重定向地址\n        response.setStatus(HttpStatus.FOUND.value());\n        response.sendRedirect(redirectUrl);\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>安全推出的逻辑</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Component\n@RequiredArgsConstructor\npublic class Oauth2Helper {\n    private final TokenStore tokenStore;\n    /**\n     * 如果携带了 clientId，清除 令牌 信息\n     * 实现 一处退出，处处退出\n     *\n     * @param clientId       clientId\n     * @param authentication authentication\n     */\n    public void safeLogout(String clientId, Authentication authentication) {\n        tokenStore\n                .findTokensByClientIdAndUserName(clientId, authentication.getName())\n                .forEach(oAuth2AccessToken -&gt; {\n                    tokenStore.removeAccessToken(oAuth2AccessToken);\n                    tokenStore.removeRefreshToken(oAuth2AccessToken.getRefreshToken());\n                });\n    }\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_spring_security_配置\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">spring security 配置</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>前面说道资源服务器安全配置的顺序，这里我是完全交给了 spring security\n来管理，配置一下相关信息：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                // ......\n                .formLogin()\n                .loginPage(\"/oauth/login\")\n                .loginProcessingUrl(\"/authorization/form\")\n                .failureHandler(authFailureHandler)\n                .successHandler(authSuccessHandler)\n                .and()\n                // 退出登录相关\n                .logout()\n                // 退出登录的 url，post 方法\n                .logoutUrl(\"/oauth/logout\")\n                // 推出登录成功处理器\n                .logoutSuccessHandler(authLogoutSuccessHandler);\n    }</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_效果\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">效果</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>自己写了一个简单的 demo，前后端分离，前端使用vue，后端就是spring\nboot，授权服务器就是我们学校的授权服务器。<strong>注意看 URL 的变化</strong>。</p>\n</div>\n<div class=\"imageblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<img src=\"https://resources.echocow.cn/file/2020/01/20logout.gif\" alt=\"logout\">\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_jwk_端点\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">JWK 端点</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在 spring secruity oauth 迁移 spring security\n的过程中，我发现资源服务器和客户端都支持 jwk 端点了。所以引入一下 jwk\n端点：</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>你可能需要引入如下依赖：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-bash\" data-lang=\"bash\">group id: org.wso2.orbit.com.nimbusds\nartifactId: nimbus-jose-jwt</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>添加如下端点：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">import com.nimbusds.jose.jwk.JWKSet;\nimport com.nimbusds.jose.jwk.RSAKey;\nimport lombok.AllArgsConstructor;\nimport lombok.NonNull;\nimport net.minidev.json.JSONObject;\nimport org.springframework.security.oauth2.provider.endpoint.FrameworkEndpoint;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport java.security.KeyPair;\nimport java.security.interfaces.RSAPublicKey;\n\n@FrameworkEndpoint\n@AllArgsConstructor\npublic class JwkEndpoint {\n    // 这是前面 @Bean 添加的非对称加密的密钥对\n    private final @NonNull KeyPair keyPair;\n\n    @GetMapping(\"/.well-known/jwks.json\")\n    @ResponseBody\n    public JSONObject getKey() {\n        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();\n        // 注意 包 别引错\n        RSAKey key = new RSAKey.Builder(publicKey).build();\n        return new JWKSet(key).toJSONObject();\n    }\n\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>当然，目前 JWK 是完全暴露出来的，个人认为还是需要进行 BASIC\n认证的，但是目前还没找到在哪儿加的好。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_自定义端点路径\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">自定义端点路径</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>目前 spring security oauth 提供的端点都是\n<code>/oauth/token</code>，<code>/oauth/token_key</code>\n之类的，如果我们需要自定义呢？配置如下：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">public class Oauth2AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {\n    @Override\n    public void configure(AuthorizationServerEndpointsConfigurer endpoints) {\n        // ......\n        endpoints.pathMapping(\"/oauth/token\", \"/auth/token\");\n        // ......\n    }\n\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_rbac_动态权限控制\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">RBAC 动态权限控制</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>目前找到两种比较好的权限控制：</p>\n</div>\n<div class=\"olist arabic\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ol class=\"arabic\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>自定义 <code>FilterInvocationSecurityMetadataSource</code> 和\n<code>AccessDecisionManager</code></p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>自定义权限表达式</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>我使用的是第一种，安全配置如下：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">private final FilterInvocationSecurityMetadataSource securityMetadataSource;\nprivate final AuthAccessDecisionManager authAccessDecisionManager;\n// ......\nhttp\n    .authorizeRequests()\n    .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() {\n        @Override\n        public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(O o) {\n            o.setSecurityMetadataSource(securityMetadataSource);\n            o.setAccessDecisionManager(authAccessDecisionManager);\n            return o;\n        }\n    }).anyRequest().permitAll()</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>具体实现可以参见\n<a href=\"https://github.com/gzmuSoft/lesson-cloud/tree/master/lesson-cloud-auth/src/main/java/cn/edu/gzmu/auth/res\">res</a>。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>当然，在第二个项目中我使用了第二种方式，不过是基于 webflux 的，参见\n<a href=\"https://github.com/gzmuSoft/authorization-center-web/blob/master/src/main/kotlin/cn/edu/gzmu/center/config/ResourceConfig.kt\">ResourceConfig</a>。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_传统项目的过渡\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">传统项目的过渡</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>如何对传统项目进行添加 token\n解析呢？直接将他们作为一个资源服务器肯定是不行的，光是 CSRF\n问题就是比较难处理的了。我们完全可以手动解析\nTOKEN，比较好的一种方式就是自定义一个过滤器，放在\n<code>org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter</code>\n之前进行用户的验证，如果请求头中有 <code>AUTHORIZATION</code> 并且是以 <code>Bearer</code>\n开头的，那么就进行手动解析一下然后存在安全上下文之中就可以了。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>可以参考我写的\n<a href=\"https://github.com/gzmuSoft/authorization-server/blob/master/src/main/java/cn/edu/gzmu/authserver/auth/res/SecurityMetadataSource.java#L141\">AuthToken</a>\n。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_测试\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">测试</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>它的测试比较复杂，我只会写它的集成测试，对于单元测试涉及到的东西太多了，所以不会。。。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>集成测试中，就是向授权服务器获取\ntoken，通过密码模式获取最为简单，授权码模式涉及到 <code>csrf_token</code>\n的问题比较复杂，并且不止一个请求。自己也写了一些以供参考</p>\n</div>\n<div class=\"ulist\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ul data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>密码模式获取令牌： <a href=\"https://github.com/gzmuSoft/lesson-cloud/blob/master/lesson-cloud-core/src/test/java/cn/edu/gzmu/integration/Oauth2RestTemplate.java\">Oauth2RestTemplate</a></p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>授权码模式获取授权码： <a href=\"https://github.com/xkcoding/spring-boot-demo/blob/master/spring-boot-demo-oauth/spring-boot-demo-oauth-authorization-server/src/test/java/com/xkcoding/oauth/oauth/AuthorizationCodeGrantTests.java#L66\">testCodeAcquisitionWithCorrectContext</a></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>个人觉得开发的时候用密码模式就好，目前我们的测试是继承\nOauth2RestTemplate 就可以获取到已经拥有 access_token 的restTemplate\n直接请求数据即可。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_总结\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">总结</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这是目前能够想到的，其实在实践的过程中还有很多的坑，自己也被很多问题卡了很久。庆幸的是后面都过来了。其实预计这个是这个系列的最后一篇文章，但是计划赶不上变化，spring\nsecurity oauth 客户端和资源服务器已经开始迁移到了 spring security 5.2\n里面去了。所以可能后面还要写一篇博客来学习吧，在实践的过程中确实发现其实迁移过后的资源服务器更加简单，并且定制起来非常容易。相比起原来其实好了很多。不管是\nservlet 的也好，还是 webflux\n的也好，都比以前高度可定制了很多。后面会继续更新的～</p>\n</div>\n</div>\n</div>","document":{"title":"Spring Security Oauth2 从零到一完整实践（六）踩坑记录"},"pageAttributes":{"category":"spring","description":"时隔半年，终于要来填坑了。不过经过这段时间的学习和实践，确实解决了不少问题。现在在这里一一记录一下。","image":"https://img.hacpai.com/bing/20181116.jpg?imageView2/1/w/960/h/540/interlace/1/q/100","sort":null}}},"pageContext":{"slug":"/articles/2020/01/20/1579503807596.html","next":{"document":{"title":"vert.x 4 日志配置"},"fields":{"slug":"/articles/2020/01/31/1580462516035.html"}},"previous":{"document":{"title":"2019，最后的轻狂"},"fields":{"slug":"/articles/2019/12/31/1577769144050.html"}}}},"staticQueryHashes":["3069561552","3673333084"]}