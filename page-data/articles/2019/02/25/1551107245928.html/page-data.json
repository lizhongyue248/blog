{"componentChunkName":"component---src-templates-post-tsx","path":"/articles/2019/02/25/1551107245928.html","result":{"data":{"asciidoc":{"id":"e0d5e1e9-713d-547b-a758-69bcd8713545","fields":{"slug":"/articles/2019/02/25/1551107245928.html","birthTime":"2019-02-25T15:19:59.337Z","modifiedTime":"2019-02-25T15:22:13.615Z"},"html":"<div id=\"toc\" class=\"toc\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div id=\"toctitle\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">Table of Contents</div>\n<ul class=\"sectlevel1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_定义路由\">定义路由</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_导航的生命周期\">导航的生命周期</a>\n<ul class=\"sectlevel2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_beforeleaveevent\">BeforeLeaveEvent</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_beforeenterevent\">BeforeEnterEvent</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_reroute\">Reroute</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_afternavigationevent\">AfterNavigationEvent</a></li>\n</ul>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_路由器布局和嵌套路由器目标\">路由器布局和嵌套路由器目标</a>\n<ul class=\"sectlevel2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_routerlayout\">RouterLayout</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_具有parentlayout的多个父布局\">具有@parentlayout的多个父布局</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_使用_routeprefix_的_parentlayout_路由控制\">使用 <code>@routeprefix</code> 的 parentlayout 路由控制</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_绝对路由\">绝对路由</a></li>\n</ul>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_路由和_url_参数\">路由和 URL 参数</a>\n<ul class=\"sectlevel2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_导航目标的_url_参数\">导航目标的 URL 参数</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_导航目标的可选_url_参数\">导航目标的可选 URL 参数</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_导航目标的通配符_url_参数\">导航目标的通配符 URL 参数</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_查询参数\">查询参数</a></li>\n</ul>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_url_生成\">URL 生成</a>\n<ul class=\"sectlevel2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_带参数导航目标的_url_生成\">带参数导航目标的 URL 生成</a></li>\n</ul>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_在路线之间导航\">在路线之间导航</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_路由器异常处理\">路由器异常处理</a>\n<ul class=\"sectlevel2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_重新路由到错误视图\">重新路由到错误视图</a></li>\n</ul>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_获取已注册的路由\">获取已注册的路由</a>\n<ul class=\"sectlevel2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_按父布局获取已注册路由\">按父布局获取已注册路由</a></li>\n</ul>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_更新导航页面标题\">更新导航页面标题</a>\n<ul class=\"sectlevel2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_使用_pagetitle_注解\">使用 <code>@PageTitle</code> 注解</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_动态设置页面标题\">动态设置页面标题</a></li>\n</ul>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_结束语\">结束语</a></li>\n</ul>\n</div>\n<div id=\"preamble\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>前段时间无聊逛 maven 仓库的时候，无意中看到一个名为 spring boot\n的框架，但是却发布到了 12 的版本，我很奇怪，spring boot\n最近在用，没那么高啊，然后点进去才发现是 Vaadin 12 集成 spring boot\n的库。于是一时好奇去查看了一下 Vaadin，感觉还不错，Vaadin早期叫IT Mill\nToolkit，前端用一种专有的Javascript实现的，开发非常复杂。2007年底，这种专有的Javascript实现就被放弃了，转而拥抱GWT。2009年改名字叫Vaadin\nFramework。然而现在的 Vaadin 其实在也是有一席之地的，</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>相比来说不用写 js 还是不错的，不过 css 还是要写的，可以理解是 GWT\n的一个超集吧。虽然说google工程已经使用 dart 和 angular dart 来取代GWT\n写的应用了，但我还是比较想试试使用 Vaadin\n如何，不过可惜的是文章实在少，只有从官网上看了，英语听力差的一批，不得已只能看文章慢慢学习啦。不过先体验一番，可以的话在考虑深入学习。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_定义路由\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">定义路由</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>@route 注释允许您将任意组件定义为给定 URL 片段的路由目标。例如：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Route(\"\")\npublic class HelloWorld extends Div {\n  public HelloWorld() {\n    setText(\"Hello world\");\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这里，我们将 Helloworld\n组件定义为应用程序的默认路由目标（空路由）。您可以为不同的路由定义单独的组件，如下所示：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Route(\"some/path\")\npublic class SomePathComponent extends Div {\n  public SomePathComponent() {\n    setText(\"Hello @Route!\");\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>每当用户访问 <a href=\"http://yourdomain.com/some/path\" class=\"bare\">http://yourdomain.com/some/path</a>\n时（假设应用程序是从根上下文运行的）通过单击应用程序内的链接或直接在地址栏上键入地址，SomePathComponent\n组件将显示在页面上。</p>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>如果省略了 @Route 的值，则路由的路径默认将从类名派生。例如，MyEditor\n将变为 <code>myeditor''，personView 将变为 </code>person''，mainView 将变为“”。</p>\n</div>\n</blockquote>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>PS: 很简单的一个路由注解就完成路由设置，类似于 spring boot 的\n@RequestMapping</p>\n</div>\n</blockquote>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_导航的生命周期\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">导航的生命周期</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在将导航从一种状态应用到另一种状态时，将触发许多生命周期事件。事件触发将会调用到\n<code>UI</code> 实例的侦听器和实现特殊观察者接口的附加组件</p>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_beforeleaveevent\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">BeforeLeaveEvent</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在导航期间激发的第一个事件是BeforeLeaveEvent。该事件允许延迟或取消导航，或者将导航更改为转到其他目的地。此事件将传递到实现\nBeforeLeaveObserver 并在导航开始前附加到 <code>UI</code>\n的任何组件实例。也可以使用UI中的\naddBeforeLeaveListener（beforeLeaveListener）方法为此事件注册独立的侦听器。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>此事件的一个典型用例是，在导航到应用程序的其他部分之前，询问用户是否要保存任何未保存的更改。</p>\n</div>\n<div class=\"sect3\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h4 id=\"_postpone_推迟导航\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">Postpone 推迟导航</h4>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>BeforeLeaveEvent有一个 Postpone\n方法，可用于推迟当前导航转换，直到满足特定条件。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>E.g. 在离开页面前请求用户确认：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">public class SignupForm extends Div implements BeforeLeaveObserver {\n    @Override\n    public void beforeLeave(BeforeLeaveEvent event) {\n        if (this.hasChanges()) {\n            ContinueNavigationAction action = event.postpone();\n            ConfirmDialog.build(\"Are you sure you want to leave this page?\")\n                    .ifAccept(action::proceed).show();\n        }\n    }\n\n    private boolean hasChanges() {\n        // no-op implementation\n        return true;\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>使用 <code>postpone</code>\n方法将会暂时中断观察者和监听者，当他恢复以后，将会启用推迟的观察者之后的观察者。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>例如，我们假设当前页面有 <code>A</code> <code>B</code> <code>C</code> 三个观察者（即实现了 Observer\n结尾接口），按照这些顺序通知这些观察者，如果 <code>B</code> 调用推迟，对 <code>C</code>\n的调用以及转换过程的其余部分将被推迟。如果 <code>B</code> 推迟的转换没有恢复，<code>C</code>\n将不会收到有关此事件的通知，并且转换永远不会结束。但是，如果 <code>B</code> 执行其\n<code>ContinueNavigationAction</code> 以恢复转换，则从中断的位置继续。因此，<code>A</code> 和\n<code>B</code> 不再被调用，但 <code>C</code> 被通知。</p>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>任何时候最多可以推迟一个导航事件；当前一个导航事件处于推迟状态时启动新的导航转换将取消推迟状态。之后，执行之前保存的\n<code>ContinueNavigationAction</code> 将没有任何效果</p>\n</div>\n</blockquote>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>PS: 其实类似于 axios 的 路由前置守卫</p>\n</div>\n</blockquote>\n</div>\n</div>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_beforeenterevent\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">BeforeEnterEvent</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在导航期间触发的第二个事件是\n<code>BeforeEnterEvent</code>。它允许将导航更改为转到其他目的地。此事件通常用于响应特殊情况，例如，如果没有要显示的数据或用户没有适当的权限。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>只有在通过 <code>BeforeLeaveEvent</code> 的任何 <code>postpone</code>\n都已继续之后，才会激发该事件。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>此事件将传递到任何实现 <code>BeforeEnterObserver</code>\n的组件实例，该实例将在导航完成后附加到\n<code>UI</code>。请注意，在分离并到达组件或使`UI`\n导航到的位置匹配之前，将激发该事件。也可以使用 <code>UI</code> 中的\n<code>addBeforeEnterListener（beforeEnterListener）</code>\n方法为此事件注册独立的侦听器。</p>\n</div>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_reroute\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">Reroute</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>如果需要在某些状态下显示完全不同的信息，可以使用 BeforeEnterEvent 或\nBeforeLeaveEvent\n动态重新路由。重新路由后，不会再激发任何其他侦听器或观察器。相反，将根据新的导航目标触发新的导航阶段，而事件将根据该导航触发。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>E.g. 下面的例子发生在进入 <code>BlogList</code> 没有任何结果的时候</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Route(\"no-items\")\npublic class NoItemsView extends Div {\n    public NoItemsView() {\n        setText(\"No items found.\");\n    }\n}\n\n@Route(\"blog\")\npublic class BlogList extends Div implements BeforeEnterObserver {\n    @Override\n    public void beforeEnter(BeforeEnterEvent event) {\n        // implementation omitted\n        Object record = getItem();\n\n        if (record == null) {\n            event.rerouteTo(NoItemsView.class);\n        }\n    }\n\n    private Object getItem() {\n        // no-op implementation\n        return null;\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><code>rerouteto</code> 有几个重载来服务不同的用例。</p>\n</div>\n</blockquote>\n</div>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_afternavigationevent\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">AfterNavigationEvent</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>导航过程中的第三个也是最后一个触发事件是\n<code>AfterNavigationEvent</code>。此事件通常用于在实际导航完成后更新 <code>UI</code>\n的各个部分。例如，调整 <code>breadcrumb</code>\n组件的内容，并在菜单中直观地将活动条目标记为 active。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>事件在 <code>beforeenterEvent</code> 和更新附加的 <code>UI</code>\n组件后激发。此时，可以预期当前的导航状态将实际显示给用户，也就是说，不会有任何进一步的重新路由或类似的情况。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>此事件将传递到完成导航后附加的实现 <code>AfterNavigationOnBServer</code>\n的任何组件实例。也可以使用 <code>UI</code> 中的\n<code>AddAfterNavigationListener（AfterNavigationListener）</code>\n方法为此事件注册独立的侦听器。</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">public class SideMenu extends Div implements AfterNavigationObserver {\n    Anchor blog = new Anchor(\"blog\", \"Blog\");\n\n    @Override\n    public void afterNavigation(AfterNavigationEvent event) {\n        boolean active = event.getLocation().getFirstSegment()\n                .equals(blog.getHref());\n        blog.getElement().getClassList().set(\"active\", active);\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>PS:其实就是路由后置守卫</p>\n</div>\n</blockquote>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_路由器布局和嵌套路由器目标\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">路由器布局和嵌套路由器目标</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_routerlayout\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">RouterLayout</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>使用 <code>@route（“path”）</code> 定义路由时，默认情况下，组件将呈现在页面上的\n<code>&lt;body&gt;</code> 标记内（<code>hasElement.getElement()</code> 返回的元素附加到 <code>&lt;body&gt;</code>）。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>可以使用 <code>route.layout()</code> 方法定义父布局。例如，在名为 <code>Mainlayout</code>\n的布局中呈现 <code>CompanyComponent</code>，代码如下：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Tag(\"div\")\n@Route(value=\"company\", layout=MainLayout.class)\npublic class CompanyComponent extends Component {\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><strong>所有用作父布局的布局都必须实现 <code>RouterLayout</code> 接口。</strong></p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>如果有多个路由器目标组件使用相同的父布局，那么当用户在子组件之间导航时，父布局实例将保持不变。</p>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>PS:类似于 HTML 的元素嵌套</p>\n</div>\n</blockquote>\n</div>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_具有parentlayout的多个父布局\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">具有@parentlayout的多个父布局</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在某些情况下，可能需要在应用程序中为父布局提供父布局。一个例子是，我们有一个用于所有内容的主布局和一个可重用为视图的菜单栏。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>为此，我们可以进行以下设置：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">public class MainLayout extends Div implements RouterLayout {\n}\n\n@ParentLayout(MainLayout.class)\npublic class MenuBar extends Div implements RouterLayout {\n    public MenuBar() {\n        addMenuElement(TutorialView.class, \"Tutorial\");\n        addMenuElement(IconsView.class, \"Icons\");\n    }\n    private void addMenuElement(Class&lt;? extends Component&gt; navigationTarget,\n            String name) {\n        // implementation omitted\n    }\n}\n\n@Route(value = \"tutorial\", layout = MenuBar.class)\npublic class TutorialView extends Div {\n}\n\n@Route(value=\"icons\", layout = MenuBar.class)\npublic class IconsView extends Div {\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在这种情况下，我们将拥有一个始终封装 <code>MenuBar</code> 的 <code>MainLayout</code>，而\n<code>MenuBar</code> 又封装 <code>TutorialView</code> 或\n<code>IconsView</code>，具体取决于我们导航到的位置。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在这个示例中，我们有两个父层，但是嵌套布局的数量没有限制。</p>\n</div>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_使用_routeprefix_的_parentlayout_路由控制\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">使用 <code>@routeprefix</code> 的 parentlayout 路由控制</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在某些情况下，父布局应该通过添加到路由位置来补充导航路由。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这可以通过用 <code>@RoutePrefix(\"prefix_to_add\")</code> 注解父布局来完成。</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Route(value = \"path\", layout = SomeParent.class)\npublic class PathComponent extends Div {\n    // Implementation omitted\n}\n\n@RoutePrefix(\"some\")\npublic class SomeParent extends Div implements RouterLayout {\n    // Implementation omitted\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在本例中，<code>PathComponent</code> 将接收的路由是 <code>some/path</code>，就像前面提到的\n<code>somePathComponent</code> 一样。</p>\n</div>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_绝对路由\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">绝对路由</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>有时，我们可能有一个设置，我们希望在许多部分中使用相同的父组件，但在某些情况下，不使用父链中的任何\n<code>@RoutePrefix</code>，或仅将它们用于定义的部分。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在这些情况下，我们可以将 <code>absolute=true</code> 添加到 <code>@Route</code> 或\n<code>@RoutePrefix</code> 注释中。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>因此，如果我们想在 <code>SomeParent</code>\n布局的许多地方使用某些内容，但不想将路由前缀添加到导航路径中，我们可以用以下方式构建一个类\n<code>MyContent</code>：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Route(value = \"content\", layout = SomeParent.class, absolute = true)\npublic class MyContent extends Div {\n    // Implementation omitted\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在这种情况下，即使完整的链路径应该是\n<code>some/content</code>，我们实际上得到路径是 <code>content</code>\n正如我们所定义的，这应该是绝对的。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>当在链的中间有绝对定义时，也可以这样做，例如：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@RoutePrefix(value = \"framework\", absolute = true)\n@ParentLayout(SomeParent.class)\npublic class FrameworkSite extends Div implements RouterLayout {\n    // Implementation omitted\n}\n\n@Route(value = \"tutorial\", layout = FrameworkSite.class)\npublic class Tutorials extends Div {\n    // Implementation omitted\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在这种情况下，绑定的路由将是 <code>framework/tutorial</code> 即使整个链接是\n<code>some/framework/tutorial</code></p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_路由和_url_参数\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">路由和 URL 参数</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_导航目标的_url_参数\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">导航目标的 URL 参数</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>支持通过URL传递参数的导航目标应实现 <code>HasUrlParameter</code>\n接口，并使用泛型定义参数类型。通过这种方式，路由器 API\n可以提供一种类型安全的方式来构造指向特定目标的 URL。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><code>HasUrlParameter</code> 定义路由器根据从 URL 提取的值调用的 <code>setParameter</code>\n方法。该方法将始终在激活导航目标之前被调用。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在下面的代码段中，我们定义了一个导航目标，它接受一个字符串参数并从中生成一个\nhello 字符串，然后目标将其设置为自己的导航文本内容。</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Route(value = \"greet\")\npublic class GreetingComponent extends Div\n        implements HasUrlParameter&lt;String&gt; {\n\n    @Override\n    public void setParameter(BeforeEvent event, String parameter) {\n        setText(String.format(\"Hello, %s!\", parameter));\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>启动时，此导航目标将自动配置为格式 <code>greet/&lt;anything&gt;</code>\n的每个路径，除非已将具有精确 <code>@Route</code> 的单独导航目标配置为匹配\n<code>greet/&lt;some specific path&gt;</code> ,因为在解析URL时，精确导航目标优先。</p>\n</div>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_导航目标的可选_url_参数\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">导航目标的可选 URL 参数</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>可以使用 <code>@OptionalParameter</code> 对 URL 参数进行注释，使路由同时匹配\n<code>greet</code> 和 <code>greet/&lt;anything&gt;</code>。</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Route(\"greet\")\npublic class OptionalGreeting extends Div\n        implements HasUrlParameter&lt;String&gt; {\n\n    @Override\n    public void setParameter(BeforeEvent event,\n            @OptionalParameter String parameter) {\n        if (parameter == null) {\n            setText(\"Welcome anonymous.\");\n        } else {\n            setText(String.format(\"Welcome %s.\", parameter));\n        }\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>另外，对于可选参数，特定路由将优先于参数化路由。</p>\n</div>\n</blockquote>\n</div>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_导航目标的通配符_url_参数\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">导航目标的通配符 URL 参数</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在需要更多参数的情况下，还可以使用 <code>@WildcardParameter</code> 对 URL\n参数进行注释，以使路由匹配问候语以及之后的任何内容，例如问候语\n<code>/one/five/three</code>。</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Route(\"greet\")\npublic class WildcardGreeting extends Div\n        implements HasUrlParameter&lt;String&gt; {\n\n    @Override\n    public void setParameter(BeforeEvent event,\n            @WildcardParameter String parameter) {\n        if (parameter.isEmpty()) {\n            setText(\"Welcome anonymous.\");\n        } else {\n            setText(String.format(\"Handling parameter %s.\", parameter));\n        }\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>通配符参数的参数永远不会为空。</p>\n</div>\n</blockquote>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>更具体的路径将优先于通配符目标。</p>\n</div>\n</blockquote>\n</div>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_查询参数\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">查询参数</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>也可以获取包含在 URL 中的查询参数。e.g.&nbsp;<code>?name1=value1&amp;name2=value2</code>.</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>可以通过 <code>Location</code> 类的 <code>getQueryParameters()</code>\n方法访问这些查询参数。位置类可以通过 <code>setParameter</code> 方法的 <code>BeforeEvent</code>\n参数获得。</p>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><code>Location</code> 对象表示由路径段和查询参数组成的相对\nURL，但不用主机名，e.g.&nbsp;<code>new Location(\"foo/bar/baz?name1=value1\")</code>.</p>\n</div>\n</blockquote>\n</div>\n<div class=\"literalblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre>@Override\npublic void setParameter(BeforeEvent event,\n        @OptionalParameter String parameter) {\n\n    Location location = event.getLocation();\n    QueryParameters queryParameters = location.getQueryParameters();\n\n    Map&lt;String, List&lt;String&gt;&gt; parametersMap = queryParameters.getParameters();\n}</pre>\n</div>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><code>getQueryParameters()</code> 支持与同一个键关联的多个值。 Example:\n<code><a href=\"https://example.com/?one=1&amp;two=2&amp;one=3\" class=\"bare\">https://example.com/?one=1&amp;two=2&amp;one=3</a></code> 3将生成对应的映射\n<code>{\"one\" : [1, 3], \"two\": [2]}}</code>.</p>\n</div>\n</blockquote>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_url_生成\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">URL 生成</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>路由器公开了获取已注册导航目标的导航 URL 的方法。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>对于一个普通的导航目标，请求是一个简单的调用\n<code>Router.getUrl(Class target)</code>。</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Route(\"path\")\npublic class PathComponent extends Div {\n  public PathComponent() {\n    setText(\"Hello @Route!\");\n  }\n}\n\npublic class Menu extends Div {\n    public Menu() {\n        String route = UI.getCurrent().getRouter()\n                .getUrl(PathComponent.class);\n        Anchor link = new Anchor(route, \"Path\");\n        add(link);\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在这种情况下，返回的 URL 将简单地解析为\n<strong>路径</strong>，但在我们在父布局有添加部分路径情况下，手工生成路径可能不那么简单。</p>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_带参数导航目标的_url_生成\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">带参数导航目标的 URL 生成</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>对于具有所需参数的导航目标，参数被赋予解析器，返回的字符串将包含参数，e.g.&nbsp;<code>Router.getUrl(Class target, T parameter)</code></p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Route(value = \"greet\")\npublic class GreetingComponent extends Div\n        implements HasUrlParameter&lt;String&gt; {\n\n    @Override\n    public void setParameter(BeforeEvent event,\n            String parameter) {\n        setText(String.format(\"Hello, %s!\", parameter));\n    }\n}\n\npublic class ParameterMenu extends Div {\n    public ParameterMenu() {\n        String route = UI.getCurrent().getRouter()\n                .getUrl(GreetingComponent.class, \"anonymous\");\n        Anchor link = new Anchor(route, \"Greeting\");\n        add(link);\n    }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_在路线之间导航\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">在路线之间导航</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>您可以使用 <code>RouterLink</code> 组件创建链接，以引导到应用程序中的路由目标。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>带或不带 url 参数的导航目标的 <code>RouterLink</code> 示例</p>\n</div>\n<div class=\"literalblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre>void routerLink() {\n    Div menu = new Div();\n    menu.add(new RouterLink(\"Home\", HomeView.class));\n    menu.add(new RouterLink(\"Greeting\", GreetingComponent.class, \"default\"));\n}</pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>带URL参数的 <code>GreetingComponent</code> 组件</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Route(value = \"greet\")\npublic class GreetingComponent extends Div\n        implements HasUrlParameter&lt;String&gt; {\n\n    @Override\n    public void setParameter(BeforeEvent event,\n            String parameter) {\n        setText(String.format(\"Hello, %s!\", parameter));\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>也可以使用普通的类型链接进行导航，但这些链接会导致页面重新加载。相反，使用\n<code>RouterLink</code>\n导航会获取新组件的内容，该组件在不重新加载页面的情况下就地更新。</p>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>通过向常规链接添加 <code>router-link</code>\n属性，您可以告诉框架它应在不重新加载的情况下处理导航，e.g.&nbsp;<code>&lt;a router-link href=\"company\"&gt;Go to the company page&lt;/a&gt;</code>。</p>\n</div>\n</blockquote>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>要从服务器端触发导航，请使用 <code>UI.navigate(String)</code>，其中 String\n参数是要导航到的位置。还有，<code>UI.navigate(Class&lt;? extends Component&gt; navigationTarget)</code>\n或\n<code>navigate(Class&lt;? extends C&gt; navigationTarget, T parameter)</code>，这样就不必手动生成路由字符串。这将触发浏览器位置的更新并添加新的历史记录状态条目。单击按钮时指向\n<code>company</code> 路线目标的示例导航：</p>\n</div>\n<div class=\"literalblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre>NativeButton button = new NativeButton(\"Navigate to company\");\nbutton.addClickListener( e-&gt; {\n     button.getUI().ifPresent(ui -&gt; ui.navigate(\"company\"));\n});</pre>\n</div>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>即使会话 session\n已过期，路由器链接也可以工作，因此您应该更喜欢使用这些链接，而不是处理导航服务器端。</p>\n</div>\n</blockquote>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_路由器异常处理\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">路由器异常处理</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>vaadin\n对于导航目标有特殊的支持，因为在<strong>导航过程</strong>中引发了未处理的异常而激活这些目标，以便向用户显示``错误视图''。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这些目标通常与常规导航目标的工作方式相同，尽管它们通常没有任何特定的\n<code>@Route</code>，因为它们是为任意 URL 显示的。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>错误导航根据导航期间引发的异常类型解析为 target。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在启动时，将收集实现接口 <code>HasErrorParameter&lt;T extends Exception&gt;</code>\n的所有类，以便在导航期间用作异常 targets。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>例如，这里是 <code>NotFoundException</code> 的默认目标，当给定的 URL\n没有目标时，将显示该目标。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>RouteNotFoundError for NotFoundException during routing</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Tag(Tag.DIV)\npublic class RouteNotFoundError extends Component\n        implements HasErrorParameter&lt;NotFoundException&gt; {\n\n    @Override\n    public int setErrorParameter(BeforeEnterEvent event,\n            ErrorParameter&lt;NotFoundException&gt; parameter) {\n        getElement().setText(\"Could not navigate to '\"\n                    + event.getLocation().getPath() + \"'\");\n        return HttpServletResponse.SC_NOT_FOUND;\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这将返回 404 的 HTTP 响应并向用户显示设置的文本。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>异常匹配将首先按异常原因运行，然后按异常超类型运行。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>实现的默认异常为 <code>NotFoundException（404）</code> 的 <code>RouteNotFoundError</code>\n，<code>Java.lang.Exception（500）</code> 的 <code>InternalServerError</code> 。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>默认的异常处理程序可以通过如下方式进行扩展来重写：</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>Custom route not found that is using our application layout</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@ParentLayout(MainLayout.class)\npublic class CustomNotFoundTarget extends RouteNotFoundError {\n\n    @Override\n    public int setErrorParameter(BeforeEnterEvent event,\n            ErrorParameter&lt;NotFoundException&gt; parameter) {\n        getElement().setText(\"My custom not found class!\");\n        return HttpServletResponse.SC_NOT_FOUND;\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>作为一个更复杂的示例，我们可以有一个仪表板，它可以收集和向用户显示小部件，并且可以有不应为未经身份验证的用户显示的小部件。出于某种原因，为未经身份验证的用户加载\n<code>ProtectedWidget</code>。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>集合本应捕获受保护的小部件，但出于某种原因实例化了它，但幸运的是，该小部件检查创建时的身份验证，并抛出\n<code>AccessDeniedException</code></p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>此未处理的异常在导航过程中传播，并由 <code>AccessDeniedExceptionHandler</code>\n处理，该处理程序仍保留主布局的菜单栏，但显示发生异常的信息。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>错误加载受保护的小部件时访问被拒绝的异常示例</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Route(value = \"dashboard\", layout = MainLayout.class)\n@Tag(Tag.DIV)\npublic class Dashboard extends Component {\n    public Dashboard() {\n        init();\n    }\n\n    private void init() {\n        getWidgets().forEach(this::addWidget);\n    }\n\n    public void addWidget(Widget widget) {\n        // Implementation omitted\n    }\n\n    private Stream&lt;Widget&gt; getWidgets() {\n        // Implementation omitted, gets faulty state widget\n        return Stream.of(new ProtectedWidget());\n    }\n}\n\npublic class ProtectedWidget extends Widget {\n    public ProtectedWidget() {\n        if (!AccessHandler.getInstance().isAuthenticated()) {\n            throw new AccessDeniedException(\"Unauthorized widget access\");\n        }\n        // Implementation omitted\n    }\n}\n\n@Tag(Tag.DIV)\npublic abstract class Widget extends Component {\n    public boolean isProtected() {\n        // Implementation omitted\n        return true;\n    }\n}\n\n@Tag(Tag.DIV)\n@ParentLayout(MainLayout.class)\npublic class AccessDeniedExceptionHandler extends Component\n        implements HasErrorParameter&lt;AccessDeniedException&gt; {\n\n    @Override\n    public int setErrorParameter(BeforeEnterEvent event,\n            ErrorParameter&lt;AccessDeniedException&gt; parameter) {\n        getElement().setText(\n            \"Tried to navigate to a view without correct access rights\");\n        return HttpServletResponse.SC_FORBIDDEN;\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>异常目标可以定义 <code>ParentLayouts</code>，并且在进行导航之前和之后发送的\n<code>NavigationEvent</code> 将与正常导航相同。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>一个异常只能有一个异常处理程序（只允许扩展实例）。</p>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_重新路由到错误视图\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">重新路由到错误视图</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>可以从 <code>BeforeEnterEvent</code> 和 <code>BeforeLeaveEvent</code>\n重新路由到为异常注册的错误视图。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>重新路由是通过使用其中一个重载来完成的，该重载用于只将异常类重新路由到目标或添加自定义错误消息。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>重新路由到错误视图</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">public class AuthenticationHandler implements BeforeEnterObserver {\n    @Override\n    public void beforeEnter(BeforeEnterEvent event) {\n        Class&lt;?&gt; target = event.getNavigationTarget();\n        if (!currentUserMayEnter(target)) {\n            event.rerouteToError(AccessDeniedException.class);\n        }\n    }\n\n    private boolean currentUserMayEnter(Class&lt;?&gt; target) {\n        // implementation omitted\n        return false;\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>如果重新路由方法捕获到异常，并且需要添加自定义消息，则可以使用\n<code>rerouteToError(Exception, String)</code> 方法设置自定义消息。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>包含自定义消息的日志示例错误视图</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Tag(Tag.DIV)\npublic class BlogPost extends Component implements HasUrlParameter&lt;Long&gt; {\n\n    @Override\n    public void setParameter(BeforeEvent event, Long parameter) {\n        removeAll();\n\n        Optional&lt;BlogRecord&gt; record = getRecord(parameter);\n\n        if (!record.isPresent()) {\n            event.rerouteToError(IllegalArgumentException.class,\n                    getTranslation(\"blog.post.not.found\",\n                            event.getLocation().getPath()));\n        } else {\n            displayRecord(record.get());\n        }\n    }\n\n    private void removeAll() {\n        // NO-OP\n    }\n\n    private void displayRecord(BlogRecord record) {\n        // NO-OP\n    }\n\n    public Optional&lt;BlogRecord&gt; getRecord(Long id) {\n        // Implementation omitted\n        return Optional.empty();\n    }\n}\n\n@Tag(Tag.DIV)\npublic class FaultyBlogPostHandler extends Component\n        implements HasErrorParameter&lt;IllegalArgumentException&gt; {\n\n    @Override\n    public int setErrorParameter(BeforeEnterEvent event,\n            ErrorParameter&lt;IllegalArgumentException&gt; parameter) {\n        Label message = new Label(parameter.getCustomMessage());\n        getElement().appendChild(message.getElement());\n\n        return HttpServletResponse.SC_NOT_FOUND;\n    }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_获取已注册的路由\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">获取已注册的路由</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>要检索应用程序中所有已注册的路由，可以使用：</p>\n</div>\n<div class=\"literalblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre>Router router = UI.getCurrent().getRouter();\nList&lt;RouteData&gt; routes = router.getRoutes();</pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><code>RouteData</code> 对象包含有关已定义路由的所有相关信息，如 URL、参数和父布局。</p>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_按父布局获取已注册路由\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">按父布局获取已注册路由</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>要获取由父布局定义的所有路由，可以使用：</p>\n</div>\n<div class=\"literalblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre>Router router = UI.getCurrent().getRouter();\nMap&lt;Class&lt;? extends RouterLayout&gt;, List&lt;RouteData&gt;&gt; routesByParent = router.getRoutesByParent();\nList&lt;RouteData&gt; myRoutes = routesByParent.get(MyParentLayout.class);</pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_更新导航页面标题\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">更新导航页面标题</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>导航期间有两种更新页面标题的方法：</p>\n</div>\n<div class=\"ulist\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ul data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>使用 <code>@PageTitle</code> 注解</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>实现 <code>HasDynamicTitle</code></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这两种方法是互斥的：在同一个类上同时使用这两种方法将在启动时导致运行时异常。</p>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_使用_pagetitle_注解\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">使用 <code>@PageTitle</code> 注解</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>更新页面标题的最简单方法是在组件类上使用 <code>@PageTitle</code> 注释。</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@PageTitle(\"home\")\nclass HomeView extends Div {\n\n  HomeView(){\n    setText(\"This is the home view\");\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><code>@PageTitle</code> 注释仅从实际导航目标读取；不考虑其超类或其父视图。</p>\n</div>\n</blockquote>\n</div>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_动态设置页面标题\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">动态设置页面标题</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>实现 <code>HasDynamicTitle</code> 接口使我们可以在运行时从 Java 更改标题：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Route(value = \"blog\")\nclass BlogPost extends Component\n        implements HasDynamicTitle, HasUrlParameter&lt;Long&gt; {\n  private String title = \"\";\n\n  @Override\n  public String getPageTitle() {\n    return title;\n  }\n\n  @Override\n  public void setParameter(BeforeEvent event,\n        @OptionalParameter Long parameter) {\n    if (parameter != null) {\n      title = \"Blog Post #\" + parameter;\n    } else {\n      title = \"Blog Home\";\n    }\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_结束语\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">结束语</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>路由这一块还不错，相比于 vertx\n至少他的注解是很友好的（其实两者不是一性质哈哈），不过 html\n组件构建方面有点麻烦，慢慢学习适应下咯只有，不过重点是\n资料少！资料少！资料少！ 啊！不过我喜欢（逃。。。</p>\n</div>\n</div>\n</div>","document":{"title":"Vaadin —— Java 从后端到前端 （路由与导航）"},"pageAttributes":{"category":"归档","description":"Vaadin —— Java 从后端到前端 （路由与导航）","image":"https://img.hacpai.com/bing/20171124.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100","sort":null}}},"pageContext":{"slug":"/articles/2019/02/25/1551107245928.html","next":{"document":{"title":"我校资源仓库 使用详解"},"fields":{"slug":"/articles/2019/03/01/1551410272344.html"}},"previous":{"document":{"title":"submail 短信接口以及 spring boot 集成"},"fields":{"slug":"/articles/2019/02/22/1550766482735.html"}}}},"staticQueryHashes":["3069561552","3673333084"]}