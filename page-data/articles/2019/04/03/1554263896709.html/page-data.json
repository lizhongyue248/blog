{"componentChunkName":"component---src-templates-post-tsx","path":"/articles/2019/04/03/1554263896709.html","result":{"data":{"asciidoc":{"id":"d3d30da1-9142-59f3-aa51-f1a583d1824d","fields":{"slug":"/articles/2019/04/03/1554263896709.html","birthTime":"2019-04-03T03:58:16.824Z","modifiedTime":"2019-04-03T03:58:32.341Z"},"html":"<div id=\"toc\" class=\"toc\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div id=\"toctitle\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">Table of Contents</div>\n<ul class=\"sectlevel1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_command_模式和_active_object_模式\">COMMAND 模式和 ACTIVE OBJECT 模式</a>\n<ul class=\"sectlevel2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_command_模式\">COMMAND 模式</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_active_object_模式\">ACTIVE OBJECT 模式</a></li>\n</ul>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_template_method_模式和_strategy_模式继承与委托\">TEMPLATE METHOD 模式和 STRATEGY 模式：继承与委托</a>\n<ul class=\"sectlevel2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_template_method_模式\">TEMPLATE METHOD 模式</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_strategy_模式\">STRATEGY 模式</a></li>\n</ul>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_facade_模式和_mediator_模式\">FACADE 模式和 MEDIATOR 模式</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_singleton_模式和_monostate_模式\">SINGLETON 模式和 MONOSTATE 模式</a>\n<ul class=\"sectlevel2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_singleton_模式\">SINGLETON 模式</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_monostate_模式\">MONOSTATE 模式</a></li>\n</ul>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_null_object_模式\">NULL OBJECT 模式</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_总结\">总结</a></li>\n</ul>\n</div>\n<div id=\"preamble\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这一部分与前面的两部分不太一样，他通过实际操作来完成一个完整的案例。并且引入一些常见的设计模式，开篇介绍了薪水支付系统的初步规格说明，相当于需求分析。</p>\n</div>\n<div class=\"ulist\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ul data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>对于钟点工，按照他们雇员记录中<strong>每小时报酬字段</strong>的值对他们进行支付。每天提交工作时间卡，其中记录了<strong>日期以及工作小时数</strong>。如果一天超过八小时，超过的部分会按照<strong>正常报酬的\n1.5 倍</strong>进行支付，<strong>每周五</strong>对他们进交付。</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>有些雇员完全以<strong>月薪</strong>进行交付。<strong>每个月的最后一个工作日</strong>对他们进行交付，在他们的雇员记录中有一个*月薪字段*。</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>带薪雇员，根据销售情况，支付<strong>一定量的酬金</strong>。他们会提交销售凭条，其中记录了<strong>销售的日期</strong>和<strong>数量</strong>，在他们的雇员记录中有一个<strong>酬金字段</strong>。<strong>每隔一周的周五</strong>对他们进行交付。</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>加入协会的雇员，有一个<strong>每周应付款项字段</strong>。将会从他们<strong>薪水中扣除</strong>。协会有时也会<strong>针对单个协会成员征收服务费用</strong>。协会每周会提交这些<strong>服务费用</strong>，服务费用必须要从<strong>相应雇员的下个月的薪水总额中扣除</strong>。</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>应用程序<strong>每个工作日运行一次</strong>，并在<strong>当天</strong>为相应的雇员进行交付，系统会被告知雇员的<strong>支付日期</strong>，这样他会计算从雇员<strong>上次支付日期到规定的本次支付日期间应支付的数额</strong>。</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_command_模式和_active_object_模式\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">COMMAND 模式和 ACTIVE OBJECT 模式</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>没有人天生就具有命令他人的权利。</p>\n</div>\n</blockquote>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>先从简单的入手，COMMAND\n模式是最简单、最优雅但同时也是适用性最广的设计模式。</p>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_command_模式\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">COMMAND 模式</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>他非常简单，看一下下面的接口</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">public interface Command {\n    //　书中为　do()，但是　do　是　java　的关键字，无法作为函数名\n    public void execute();\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>正如看到的一样，他只是封装了一个没有任何变量的函数。从严格的面向对象的意义上来说，这种做法是被强烈反对的————因为他具有功能分解的味道，他把函数层面的任务提升到了类的层面。然而这正是他有趣的地方。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>作者举了一个<em>复印机软件的例子</em>，其中通过对依稀的一些的简单的\ncommand　的封装。解除了系统的逻辑互联关系和实际链接的设备之间的耦合。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>另外一个例子是<strong>创建和执行事务操作</strong>，例如在对数据库进行操作之前，对数据进行\nvalidate\n操作。他很好的解除了从用户获取数据代码、验证并操作数据的代码以及业务对象本身之间的耦合关系。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>第三个例子是<em>回退</em>，可以对某个命令进行撤销操作。</p>\n</div>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_active_object_模式\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">ACTIVE OBJECT 模式</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>他是实现多线程的一项古老的技术，他可以自动完成动作或改变状态，隔离了方法执行和方法调用的过程，提高了并行性，对内部拥有控制线程的主动对象，降低了异步访问的复杂性。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>我们需要一个例子，看看以下的代码：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">public interface Command {\n    /**\n     * 执行\n     */\n    public void execute();\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>建立一个`ActiveObjectEngine`</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * 维护一个 Command 对象的链表\n *\n * @author echo\n */\npublic class ActiveObjectEngine {\n    private LinkedList&lt;Command&gt; itsCommands = new LinkedList&lt;&gt;();\n\n    /**\n     * 添加命令\n     *\n     * @param command 命令\n     */\n    public void addCommand(Command command) {\n        itsCommands.add(command);\n    }\n\n    /**\n     * 遍历链表，执行并去除每个命令\n     */\n    public void run() {\n        while (!itsCommands.isEmpty()){\n            Command command = itsCommands.getFirst();\n            itsCommands.removeFirst();\n            command.execute();\n        }\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>以及一个实现</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * sleep 命令\n * 等待指定数目的毫秒，然后执行 wakeup 命令\n *\n * @author echo\n */\npublic class SleepCommand implements Command {\n    private Command wakeupCommand;\n    private ActiveObjectEngine engine;\n    private long sleepTime;\n    private long startTime = 0;\n    private boolean started = false;\n\n    public SleepCommand(int milliseconds, ActiveObjectEngine engine, Command wakeupCommand) {\n        this.sleepTime = milliseconds;\n        this.engine = engine;\n        this.wakeupCommand = wakeupCommand;\n    }\n\n    /**\n     * 执行时，检查自己是以前是已经执行过\n     * 如果没有，记录下开始时间\n     * 如果没有过延迟时间，就把自己再加到 ActiveObjectEngine 中\n     * 如果过了延迟时间，就把 wakeup 命令对象加到 ActiveObjectEngine 中\n     */\n    @Override\n    public void execute() {\n        long currentTime = System.currentTimeMillis();\n        if (!started) {\n            // 未开始时\n            started = true;\n            startTime = currentTime;\n            engine.addCommand(this);\n        } else if ((currentTime - startTime) &lt; sleepTime) {\n            // 没有过延迟时间\n            engine.addCommand(this);\n        } else {\n            // 过了延迟时间,添加 -&gt; 执行\n            engine.addCommand(wakeupCommand);\n        }\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>然后一个测试</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">class TestSleepCommand {\n    private boolean commandExecuted = false;\n\n    @Test\n    void testSleep() {\n        Command wakeup = () -&gt; commandExecuted = true;\n        ActiveObjectEngine activeObjectEngine = new ActiveObjectEngine();\n        SleepCommand sleepCommand = new SleepCommand(1000, activeObjectEngine, wakeup);\n        activeObjectEngine.addCommand(sleepCommand);\n        long start = System.currentTimeMillis();\n        activeObjectEngine.run();\n        long stop = System.currentTimeMillis();\n        long sleepTime = stop - start;\n        assertTrue(commandExecuted, \"Command executed!\");\n        System.out.println(\"SleepTime \" + sleepTime);\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>具体的已经添加注释，在处理事件的时候，他不进行阻塞，常常在不符合执行条件的时候，他就把自己再次放回到\n<code>ActiveObjectEngine</code> 之中。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>采用该技术的变体去构建多线程系统已经是很常见的实践，这种类型的线程被称为\nrun-to-completion （RTC），意味着 command 不会阻塞。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>我们来模拟一个例子</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">public class DelayedTyper implements Command {\n    private int itsDelay;\n    private char itsChar;\n    private static ActiveObjectEngine engine = new ActiveObjectEngine();\n    private static boolean stop = false;\n\n    public DelayedTyper(int delay, char c) {\n        itsDelay = delay;\n        itsChar = c;\n    }\n\n    public static void main(String[] args) {\n        // 进行循环\n        engine.addCommand(new DelayedTyper(100, '1'));\n        engine.addCommand(new DelayedTyper(300, '3'));\n        engine.addCommand(new DelayedTyper(500, '5'));\n        engine.addCommand(new DelayedTyper(700, '7'));\n        // 设置 stop，停止循环\n        Command startCommand = () -&gt; stop = true;\n        // 最后一个命令\n        engine.addCommand(new SleepCommand(20000, engine, startCommand));\n        engine.run();\n    }\n\n    /**\n     * 打印在构造时传入的字符\n     */\n    @Override\n    public void execute() {\n        System.out.print(itsChar);\n        if (!stop) {\n            delayAndRepeat();\n        }\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>COMMAND\n模式的简单性掩盖了他的多功能性，但是它可能是不符合面向对象的思维范式的，因为他对函数的关注查过了类，但是在实际开发中，他确实是非常有用的。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_template_method_模式和_strategy_模式继承与委托\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">TEMPLATE METHOD 模式和 STRATEGY 模式：继承与委托</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>业精于勤</p>\n</div>\n</blockquote>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>``业精于勤，荒于嬉；行成于思，毁于随。''一本外国的书引入了我们中国的《进学解》，让人意外。这句话很好理解，学业由于勤奋而专精，由于玩乐而荒废；德行由于独立思考而有所成就，由于因循随俗而败坏。在软件开发中，使用继承我们可以基于差异编程，通过集成可以建立完整的软件结构分类。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>但是继承的过度使用是非常糟糕的，代价十分昂贵</p>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>优先使用对象组合而不是类继承</p>\n</div>\n</blockquote>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_template_method_模式\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">TEMPLATE METHOD 模式</h3>\n<div class=\"sect3\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h4 id=\"_华氏度转摄氏度\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">华氏度转摄氏度</h4>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>他是通过继承来解决问题。现在我们有一个程序如下：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * 输入华氏度转化为摄氏度\n *\n * @author echo\n * @version 1.0\n * @date 19-4-3 09:01\n */\npublic class Ftocraw {\n    public static void main(String[] args) throws Exception {\n        // 初始化流\n        InputStreamReader isr = new InputStreamReader(System.in);\n        BufferedReader br = new BufferedReader(isr);\n        boolean done = false;\n        // 主循环中完成工作\n        while (!done) {\n            String fabrString = br.readLine();\n            if (fabrString == null || fabrString.length() == 0) {\n                done = true;\n            } else {\n                double fahr = Double.parseDouble(fabrString);\n                double celcius = 5.0 / 9.0 * (fahr - 32);\n                System.out.println(\"F=\" + fahr + \", C=\" + celcius);\n            }\n        }\n        System.out.println(\"ftoc exit!\");\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>他是一个简单且正常运行的主循环结构。我们可以应用 TEMPLATE METHOD\n模式把这个基本结构从 <code>floc</code> 程序中分离出来。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><strong>我们把所有的通用代码放入一个抽象基类的实现方法中，这个实现方法完成这个通用算法，但是将所有的实现细节都交付给该积累的抽象方法，修改后的如下：</strong></p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * 描绘了一个通用的主循环应用程序\n *\n * @author echo\n * @version 1.0\n * @date 19-4-3 09:10\n */\npublic abstract class Application {\n    private boolean isDone = false;\n    protected abstract void init();\n    protected abstract void idle();\n    protected abstract void cleanup();\n\n    public void run() {\n        // 初始化\n        init();\n        // 执行\n        while (!done()) {\n            idle();\n        }\n        // 清除\n        cleanup();\n    }\n\n    protected boolean done() {\n        return isDone;\n    }\n\n    protected void setDone(boolean done) {\n        isDone = done;\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>现在，我们可以通过继承 <code>Application</code> 来重写 <code>floc</code>\n类，只需要实现抽象方法即可，修改后的如下：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 09:15\n */\npublic class FtocTemplateMethod extends Application {\n    private InputStreamReader inputStreamReader;\n    private BufferedReader bufferedReader;\n\n    public static void main(String[] args) {\n        new FtocTemplateMethod().run();\n    }\n\n    @Override\n    protected void init() {\n        inputStreamReader = new InputStreamReader(System.in);\n        bufferedReader = new BufferedReader(inputStreamReader);\n    }\n\n    @Override\n    protected void idle() {\n        String fahrString = readLineAndReturnNullIfError();\n        if (fahrString == null || fahrString.length() == 0) {\n            setDone();\n        } else {\n            double fahr = Double.parseDouble(fahrString);\n            double celcius = 5.0 / 9.0 * (fahr - 32);\n            System.out.println(\"F=\" + fahr + \", C=\" + celcius);\n        }\n    }\n\n    /**\n     * 异常处理\n     *\n     * @return 读取结果\n     */\n    private String readLineAndReturnNullIfError() {\n        String s;\n        try {\n            s = bufferedReader.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n            s = null;\n        }\n        return s;\n    }\n\n    @Override\n    protected void cleanup() {\n        System.out.println(\"ftoc exit!\");\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这就是 TEMPLATE METHOD\n模式的一个简单应用。在这个特定的简单的程序中，我们很容易理解。但是我们真的需要这样吗？<strong>其实，上面的这个是一个滥用模式的好礼自，在这个特定程序中，使用\nTEMPLATE METHOD\n模式是荒谬的，他使得程序变得复杂庞大，他的意义不大，因为俄他的代价高于他所带来的好处。</strong></p>\n</div>\n</div>\n<div class=\"sect3\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h4 id=\"_冒泡排序\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">冒泡排序</h4>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>设计模式是很好的东西，但是并不意味着必须要经常使用它们，下面我们看一个设计模式稍微有用些的例子。</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * 冒泡排序\n *\n * @author echo\n * @version 1.0\n * @date 19-4-3 09:29\n */\npublic class BubbleSorter {\n    static int operations = 0;\n\n    public static int sort(int[] array) {\n        operations = 0;\n        if (array.length &lt;= 1) {\n            return operations;\n        }\n        for (int nextToLast = array.length - 2; nextToLast &gt;= 0; nextToLast--) {\n            for (int index = 0; index &lt;= nextToLast; index++) {\n                compareAndSwap(array, index);\n            }\n        }\n        return operations;\n    }\n\n    private static void compareAndSwap(int[] array, int index) {\n        if (array[index] &gt; array[index + 1]) {\n            swap(array, index);\n        }\n        operations++;\n    }\n\n    private static void swap(int[] array, int index) {\n        int tmp = array[index];\n        array[index] = array[index + 1];\n        array[index + 1] = tmp;\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这是一个非常普通的冒泡排序算法，现在我们使用 TEMPLATE METHOD\n模式，把冒泡排序算法分离出来，放到一个抽象类中，如下：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * 抽象\n *\n * @author echo\n * @version 1.0\n * @date 19-4-3 09:35\n */\npublic abstract class BubbleSorterAbstract {\n    private int operations = 0;\n    protected int length = 0;\n\n    protected int doSort() {\n        operations = 0;\n        if (length &lt;= 1) {\n            return operations;\n        }\n        for (int nextToLast = length - 2; nextToLast &gt;= 0; nextToLast--) {\n            for (int index = 0; index &lt;= nextToLast; index++) {\n                if (outOfOrder(index)) {\n                    swap(index);\n                }\n                operations++;\n            }\n        }\n        return operations;\n    }\n\n    protected abstract void swap(int index);\n    protected abstract boolean outOfOrder(int index);\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>通过继承这个类，就可以完成一些变化的排序如下：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * int 类型冒泡排序\n *\n * @author echo\n * @version 1.0\n * @date 19-4-3 09:39\n */\npublic class IntBubbleSorter extends BubbleSorterAbstract {\n    private int[] array = null;\n\n    public int sort(int[] theArray) {\n        array = theArray;\n        length = array.length;\n        return doSort();\n    }\n\n    @Override\n    protected void swap(int index) {\n        int tmp = array[index];\n        array[index] = array[index + 1];\n        array[index + 1] = tmp;\n    }\n\n    @Override\n    protected boolean outOfOrder(int index) {\n        return array[index] &gt; array[index+1];\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * double 类型冒泡排序\n *\n * @author echo\n * @version 1.0\n * @date 19-4-3 09:41\n */\npublic class DoubleBubbleSorter extends BubbleSorterAbstract {\n    private double[] array = null;\n    public int sort(double[] theArray) {\n        array = theArray;\n        length = array.length;\n        return doSort();\n    }\n\n    @Override\n    protected void swap(int index) {\n        double tmp = array[index];\n        array[index] = array[index + 1];\n        array[index + 1] = tmp;\n    }\n\n    @Override\n    protected boolean outOfOrder(int index) {\n        return array[index] &gt; array[index+1];\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>通过 TEMPLATE METHOD\n模式的继承，把通用方法放在基类中，并且通过继承在不同的上下文中实现该通用算法。但是继承是一种非常强的关系，派生类不得不和基类绑定在一起。例如，其他类型的排序算法也要重新实现\n<code>outOfOrder</code> 和 <code>swap</code>。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><em>java 中有范型能够很好的解决上面的例子的问题。</em></p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>不过，STRATEGY 提供了一种可选的方案。</p>\n</div>\n</div>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_strategy_模式\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">STRATEGY 模式</h3>\n<div class=\"sect3\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h4 id=\"_华氏度转摄氏度_2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">华氏度转摄氏度</h4>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>我们考虑刚才 华氏度转摄氏度\n的例子，我们不再将通用的应用算法放进一个抽象基类中，而是放到一个\n<code>ApplicationRunner</code>\n具体类中。我们把通用算法必须要调用的抽象方法定义在一个 <code>Application</code>\n接口中，再从这个接口中派生出 <code>FlocStrategy</code>，再传给具\n<code>ApplicationRunner</code>，之后，就可以把具体工作委托给接口去完成。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>先来写 <code>Application</code> 接口</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 10:00\n */\npublic interface Application {\n    public void init();\n    public void idle();\n    public void cleanup();\n    public boolean done();\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>看看 <code>ApplicationRunner</code></p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 09:59\n */\npublic class ApplicationRunner {\n    public Application itsAppliction = null;\n\n    public ApplicationRunner(Application itsAppliction) {\n        this.itsAppliction = itsAppliction;\n    }\n\n    public void run() {\n        itsAppliction.init();\n        while (!itsAppliction.done()) {\n            itsAppliction.idle();\n        }\n        itsAppliction.cleanup();\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>然后使用 STRATEGY 模式来进行改造 华氏度转摄氏度 的例子</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 10:02\n */\npublic class FtocStrategy implements Application {\n    private InputStreamReader inputStreamReader;\n    private BufferedReader bufferedReader;\n    private boolean isDone = false;\n\n    public static void main(String[] args) {\n        new ApplicationRunner(new FtocStrategy()).run();\n    }\n\n    @Override\n    public void init() {\n        inputStreamReader = new InputStreamReader(System.in);\n        bufferedReader = new BufferedReader(inputStreamReader);\n    }\n\n    @Override\n    public void idle() {\n        String fahrString = readLineAndReturnNullIfError();\n        if (fahrString == null || fahrString.length() == 0) {\n            isDone = true;\n        } else {\n            double fahr = Double.parseDouble(fahrString);\n            double celcius = 5.0 / 9.0 * (fahr - 32);\n            System.out.println(\"F=\" + fahr + \", C=\" + celcius);\n        }\n    }\n\n    @Override\n    public void cleanup() {\n        System.out.println(\"ftoc exit!\");\n    }\n\n    @Override\n    public boolean done() {\n        return isDone;\n    }\n\n    /**\n     * 异常处理\n     *\n     * @return 读取结果\n     */\n    private String readLineAndReturnNullIfError() {\n        String s;\n        try {\n            s = bufferedReader.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n            s = null;\n        }\n        return s;\n    }\n\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>他和 TEMPLATE METHOD 实现的相比怎么样呢？很明显，STRATEGY\n模式代价更高一点，涉及到更多数量的类和间接层次，<code>ApplicationRunner</code>\n委托指针的使用会造成比继承稍微多一点的运行时间和数据空间开销。<strong>但是另一方面，如果有许多不同的程序妖运行，就可以重用\n<code>ApplicationRunner</code> 实例，并把许多不同的 <code>Application</code>\n实现传给他，从而减小了通用算法和该算法所控制的及具体细节之间的耦合。</strong></p>\n</div>\n</div>\n<div class=\"sect3\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h4 id=\"_冒泡排序_2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">冒泡排序</h4>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>不过最烦人的问题是 STRATEGY 模式需要很多额外的类，我们来考虑一下使用\nSTRATEGY 模式实现 冒泡排序 看看。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>排序接口</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 10:13\n */\npublic interface SortHandle {\n    public void swap(int index);\n    public boolean outOfOrder(int index);\n    public int length();\n    public void setArray(Object array);\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>他的一个实现</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 10:13\n */\npublic class IntSortHandle implements SortHandle {\n    private int[] array = null;\n\n    @Override\n    public void swap(int index) {\n        int tmp = array[index];\n        array[index] = array[index + 1];\n        array[index + 1] = tmp;\n    }\n\n    @Override\n    public boolean outOfOrder(int index) {\n        return (array[index] &gt; array[index + 1]);\n    }\n\n    @Override\n    public int length() {\n        return array.length;\n    }\n\n    @Override\n    public void setArray(Object array) {\n        this.array = (int[]) array;\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>排序算法</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 10:12\n */\npublic class BubbleSorter {\n    private int operations = 0;\n    private int length = 0;\n    private SortHandle itsSortHandle = null;\n\n    public BubbleSorter(SortHandle itsSortHandle) {\n        this.itsSortHandle = itsSortHandle;\n    }\n\n    public int sort(Object array) {\n        itsSortHandle.setArray(array);\n        length = itsSortHandle.length();\n        operations = 0;\n        if (length &lt;= 1) {\n            return operations;\n        }\n        for (int nextToLast = length - 2; nextToLast &gt;= 0; nextToLast--) {\n            for (int index = 0; index &lt;= nextToLast; index++) {\n                if (itsSortHandle.outOfOrder(index)) {\n                    itsSortHandle.swap(index);\n                }\n                operations++;\n            }\n        }\n        return operations;\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>和 TEMPLATE METHOD 不同的是，接口实现 <code>IntSortHandle</code> 对 <code>BubbleSorter</code>\n一无所知，布依赖于任何实现方式。在 TEMPLATE METHOD 中，<code>swap</code> 和\n<code>outOfOrder</code> 的实现依赖于冒泡排序算法，所以他部分违反了 <code>DIP</code>，而\nSTRATEGY 总不包含这样的依赖。所以可以在 <code>BubbleSorter</code> 之外的其他任何从\n<code>SortHandle</code> 派生出来的类。</p>\n</div>\n</div>\n<div class=\"sect3\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h4 id=\"_冒泡排序的变体\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">冒泡排序的变体</h4>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>现在，我们创建冒泡排序的一个变体，如果他在一次对于数组的遍历中发现数组的元素已经是按序排列的话，就提前结束。创建一个\n<code>QuickBubbleSorter</code></p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 10:27\n */\npublic class QuickBubbleSorter {\n    private int operations = 0;\n    private int length = 0;\n    private SortHandle itsSortHandle = null;\n\n    public QuickBubbleSorter(SortHandle itsSortHandle) {\n        this.itsSortHandle = itsSortHandle;\n    }\n\n    public int sort(Object array) {\n        itsSortHandle.setArray(array);\n        length = itsSortHandle.length();\n        operations = 0;\n        if (length &lt;= 1) {\n            return operations;\n        }\n        boolean thisPassInOrder = false;\n        for (int nextToLast = length - 2; nextToLast &gt;= 0 &amp;&amp; !thisPassInOrder; nextToLast--) {\n            thisPassInOrder = true;\n            for (int index = 0; index &lt;= nextToLast; index++) {\n                if (itsSortHandle.outOfOrder(index)) {\n                    itsSortHandle.swap(index);\n                    thisPassInOrder = false;\n                }\n                operations++;\n            }\n        }\n        return operations;\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><code>QuickBubbleSorter</code> 同样可以使用 <code>IntSortHandle</code>，或者任何其他从\n<code>SortHandle</code> 派生出来的类。它完全遵循 DIP\n原则，从而允许每个具体实现都可以被多个不同的通用算法操纵。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>相比起来，两个模式都可以\n<strong>用来分离高层的算法和底层的具体实现细节，都允许高层的算法独立于他的具体实现细节重用。</strong>\n此外 STRATEGY\n模式也允许具体实现细节独立于高层的算法重用，不过要以一些额外的复杂性、内存以及运行时间开销作为代价。</p>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_facade_模式和_mediator_模式\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">FACADE 模式和 MEDIATOR 模式</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>尊贵的符号外表下，隐藏着卑劣的梦想。</p>\n</div>\n</blockquote>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>FACADE 模式和 MEDIATOR\n模式有着共同的目的，他们都把某种策略施加到另外一组对象上。 - FACADE\n模式从上面施加策略，使用是明显且受限的。 -\n可以为一组具有复杂且全面的接口的对象提供一个简单且特定的接口，简单的说，就是应藏了具体的内部细节，提供一个非常简单且特定的接口来完成。FACADE\n对其就施加了策略。 - MEDIATOR\n模式从下面施加策略，使用是不明显且不受限的。 -\n无需被施加者允许或者知晓。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_singleton_模式和_monostate_模式\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">SINGLETON 模式和 MONOSTATE 模式</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这是对万物的祝福！除此之外再无其他</p>\n</div>\n</blockquote>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这章的两个模式，是强制对象单一性的模式。</p>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_singleton_模式\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">SINGLETON 模式</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>SINGLETON 模式 是一个很简单的模式，通过一个一些测试用例来看看。</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * 单例模式\n *\n * @author echo\n * @version 1.0\n * @date 19-4-3 11:08\n */\npublic class Singleton {\n    private static Singleton theInstance = null;\n    private Singleton(){}\n    public static Singleton instance() {\n        if (theInstance == null) {\n            theInstance = new Singleton();\n        }\n        return theInstance;\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>测试</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 11:07\n */\nclass TestSimpleSingleton {\n    @Test\n    void testCreateSingleton() {\n        Singleton s1 = Singleton.instance();\n        Singleton s2 = Singleton.instance();\n        assert s1 == s2;\n    }\n\n    @Test\n    void testNoPublicConstructors() throws ClassNotFoundException {\n        Class&lt;?&gt; singleton = Class.forName(\"four.singleton.Singleton\");\n        Constructor[] constructors = singleton.getConstructors();\n        assert constructors.length == 0;\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>可以看出，通过私有化构造函数，实现了 SINGLETON 模式</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><strong>好处：</strong> 1. 跨平台：使用合适的中间件，可以把 SINGLETON 模式扩展为跨多个\nJVM 和多个计算机工作。 2.\n适用于任何类：只要把一个类的构造函数私有化，并且增加相应的静态函数和变量，就可以把这个类变成\nSINGLETON。 3. 可以通过派生创建：给定一个类，可以创建他的一个 SINGLETON\n子类。 4. 延迟求值：如果 SINGLETON 从未使用过，那么就不会创建他。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><strong>代价：</strong> 1. 摧毁方法未定义：没有好的摧毁方法去摧毁一个\nSINGLETON，或者解除其职责，可能会同时存在两个实例。 2. 不能继承：从\nSINGLETON 类派生出来的类不是 SINGLETON 的。 3. 效率问题：每次调用\ninstance 都会执行 if 语句 4. 不透明性：SINGLETON\n使用者指定他们在使用一个 SINGLETON，因为他们必须调用 instance 方法。</p>\n</div>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_monostate_模式\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">MONOSTATE 模式</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>MONOSTATE\n模式是获取单一对象的另外一种方法。它使用了一种完全不同的工作机制，看看下面的一个例子：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 11:20\n */\npublic class Monostate {\n    private static int itsX = 0;\n    public Monostate(){}\n    public void setX(int x) {\n        itsX = x;\n    }\n    public int getX() {\n        return itsX;\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>测试用例</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 11:21\n */\nclass TestMonostate {\n    @Test\n    void testInstance() {\n        Monostate monostate = new Monostate();\n        for (int x = 0; x &lt; 10; x++) {\n            monostate.setX(x);\n            assert x == monostate.getX();\n        }\n    }\n\n    @Test\n    void testInstanceBehaveAsOne() {\n        Monostate m1 = new Monostate();\n        Monostate m2 = new Monostate();\n        for (int x = 0; x &lt; 10; x++) {\n            m1.setX(x);\n            assert x == m2.getX();\n        }\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>两个对象共享相同的变量，<code>itsX</code>\n是静态的，但是方法不是静态的，这一点很重要。无论创建多少个 <code>Monostate</code>\n对象的实例，他们都表现得<strong>像一个对象一样，甚至把当前的所有实例都销毁或者解除职责，也不会丢失数据。</strong></p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><strong>好处：</strong> 1. 透明性：使用 MONOSTATE\n对象和使用常规对象没有什么区别，使用者不知道对象是 MONOSTATE。 2.\n可派生性：MONOSTATE 的派生类都是 MONOSTATE，事实上，MONOSTATE\n的所有派生类都是同一个 MONOSTATE 的一部分，他们共享相同的静态变量。 3.\n多态性：由于 MONOSTATE 的方法不是静态的，所以可以在派生类中总重写。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><strong>代价</strong> 1. 不可转换性：不能通过派生类把常规类转换成 MONOSTATE 类。 2.\n效率问题：因为 MONOSTATE 是真正的对象，所以会导致许多的创建和销毁开销。\n3. 内存占用：即使从未使用过 MONOSTATE，他的变量也要占据内存空间。 4.\n平台局限性：MONOSTATE 不能跨多个 JVM 或者多个平台工作。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>两个模式，一个关注行为，一个。 - SINGLETON\n模式关注结构，强制结构上的单一性。防止创建出多个对象实例。如果希望通过派生去约束一个现存类，并且不介意他的所有调用这都必须要调用\n<code>instance()</code> 方法来获取访问权，那么他是最合适的。 - MONOSTATE\n模式关注行为，强制行为上的单一性，而没有强加结构方面的限制。如果希望类的单一性本质对使用者透明，或者希望使用单一对象的多态派生对象，那么他是最合适的。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>MONOSTATE 的测试用例对 SINGLETON 类是有效的，但是 SINGLETON\n的测试用例却不远不适用于 MONOSTATE 类。</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_null_object_模式\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">NULL OBJECT 模式</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>残缺即是完美，冷淡即是虚无，死亡即是圆满，没有即是更多。</p>\n</div>\n</blockquote>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>java 中可能最常见的一个异常就是空指针异常了，使用 <code>if</code> 和 <code>try/catch</code>\n都不是很优雅，现在我们俩看个 NULL OBJECT 模式的例子。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>先编写测试用例</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 11:42\n */\nclass TestEmployee {\n\n    @Test\n    void testNull() {\n        // 不存在的数据\n        Employee employee = DB.getEmployee(\"Bob\");\n        assert employee.isTimeToPay(new Date()) || Employee.NULL == employee;\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>书写接口</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">public interface Employee {\n    public boolean isTimeToPay(Date payDate);\n    public void pay();\n    public static final Employee NULL = new Employee() {\n        @Override\n        public boolean isTimeToPay(Date payDate) {\n            return false;\n        }\n\n        @Override\n        public void pay() {\n\n        }\n    };\n}</code></pre>\n</div>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 11:43\n */\npublic class DB {\n    public static Employee getEmployee(String name) {\n        return Employee.NULL;\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>我们通过使无效的数据成为一个匿名内部类是一个确保只有单一实例的方法，实际上并不存在。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>我突然想到了 jdk 8 的 optional～</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_总结\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">总结</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>相比来说，前半部分较难，后面比较简单。周六看完的，但是周三才实现部分代码，理解提高了一点，作业实在太多=-=脑壳疼，加油吧！</p>\n</div>\n</div>\n</div>","document":{"title":"[阅读] 敏捷软件开发 —— 薪水支付案例研究（一）"},"pageAttributes":{"category":"阅读","description":"[阅读] 敏捷软件开发 —— 薪水支付案例研究（一）","image":"https://img.hacpai.com/bing/20180314.jpg?imageView2/1/w/960/h/540/interlace/1/q/100","sort":null}}},"pageContext":{"slug":"/articles/2019/04/03/1554263896709.html","next":{"document":{"title":"[阅读] 敏捷软件开发 —— 薪水支付案例研究（二）"},"fields":{"slug":"/articles/2019/04/06/1554562203987.html"}},"previous":{"document":{"title":"[阅读] 敏捷软件开发 —— 敏捷设计（二）"},"fields":{"slug":"/articles/2019/03/23/1553311043768.html"}}}},"staticQueryHashes":["3069561552","3673333084"]}