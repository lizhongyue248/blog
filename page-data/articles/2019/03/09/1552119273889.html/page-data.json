{"componentChunkName":"component---src-templates-post-tsx","path":"/articles/2019/03/09/1552119273889.html","result":{"data":{"asciidoc":{"id":"ced49425-7ed1-5e12-929a-c21cb11081d7","fields":{"slug":"/articles/2019/03/09/1552119273889.html","birthTime":"2019-03-09T08:14:34.161Z","modifiedTime":"2019-03-09T16:36:58.718Z"},"html":"<div id=\"toc\" class=\"toc\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div id=\"toctitle\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">Table of Contents</div>\n<ul class=\"sectlevel1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_回顾\">回顾</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_一次编程实战\">一次编程实战</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_保龄球规则\">保龄球规则</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_测试驱动开发\">测试驱动开发</a>\n<ul class=\"sectlevel2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_普通情况\">普通情况</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_简单重构\">简单重构</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_补中情况\">补中情况</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_全中情况\">全中情况</a></li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_重构\">重构</a></li>\n</ul>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\"><a href=\"#_总结\">总结</a></li>\n</ul>\n</div>\n<div id=\"preamble\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>快一周过去了，再次拿起这本书。周六是美好的日子，没有学校的课程，不用担心作业，没有人约，也不用去考虑太多其他琐事，只需要静下来看会儿书，多么惬意美好。</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_回顾\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">回顾</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>总得回顾一下上周看了些什么的，然而写读后感的好处莫过于不用再去翻书啦。看看自己上周写的文章，文字不多不少，但是也是体会颇深，也会有一些不同的体会。</p>\n</div>\n<div class=\"ulist\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ul data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>敏捷是有组织的，是团队性的。</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>敏捷开发方法：极限编程。</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>用户素材 与 任务计划。</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>测试驱动开发，从无到有的构建。</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>重构是必要的。</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>今天开始学习第六章，一次编程实战，<strong>长文预警！</strong></p>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_一次编程实战\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">一次编程实战</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>设计和编程都是人的活动，忘记了这一点，将会失去一切。</p>\n</div>\n</blockquote>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这一章节，是一次 XP\n的编程的实践，章节中采用的是以对话的形式展现，相比于无聊的阐述，以故事的方式却好了很多。汲取朋友的经验，在这之前先去最后一页翻看了\n保龄球比赛\n规则，了解了规则后再看看确实棒很多！但是发现光看的话不能全身心的投入进去，所以准备实践一番。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在这里，我将我所学习到的分为连个部分来总结，不过在那之前，还是需要了解的应该是保龄球规则<sub>~</sub></p>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_保龄球规则\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">保龄球规则</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>保龄球是一种比赛，比赛者把一个哈密瓜大小的球顺着一条窄窄的球道投向10个木瓶。目的是在每次投球中击倒尽可能多的木瓶。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>一局比赛由10轮组成。每轮开始，10个木瓶都是竖立摆放的。比赛者可以投球两次，尝试击倒所有木瓶。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>如果比赛者在第一次投球中就击倒了所有木瓶，称之为``全中''，并且本轮结束。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>如果比赛者在第一次投球中没有击倒所有木瓶，但在第二次投球中成功击倒了所有剩余的木瓶，称之为``补中''。一轮中第二次投球后，即使还有未被击倒的木瓶，本轮也宣告结束。</p>\n</div>\n<div class=\"olist arabic\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ol class=\"arabic\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>全中轮的记分规则为：10，加上接下来的两次投球击倒的木瓶数，再加上前一轮的得分。</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>补中轮的记分规则为：10，加上接下来的一次投球击倒的木瓶数，再加上前一轮的得分。</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>其他轮的记分规则为：本轮中两次投球所击倒的木瓶数，加上前一轮的得分。</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>如果在第10轮全中，那么比赛者可以再多投球两次，以完成对全中的记分。同样，如果第10轮为补中，那么比赛者可以再多投球一次，以完成对补中的记分。因此，第10轮可以包含3次投球而不是2次。</p>\n</div>\n<div class=\"ulist\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ul data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>保龄球：bowling</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>木瓶：ball</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>局：game</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>轮：frame</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>全中：strike</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>补中：spare</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_测试驱动开发\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">测试驱动开发</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>两个人的 XP\n编程，一起商讨需求，在确定好了以后，每次首先进行的就是编写测试用例。<strong>主人公分别是\nRSK 和 RCM，以下简称 S 和 C。</strong></p>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_普通情况\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">普通情况</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>对于这个实战，我们需要明白 <code>输入</code> 和 <code>输出</code> 是什么。</p>\n</div>\n<div class=\"ulist\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ul data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><strong>输入： 一个投掷（throw）的序列</strong></p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><strong>输出：每一轮（Frame）的得分</strong></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>然而，S 提出对于 <code>Throw</code> 类并不需要测试：</p>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>关注有实际行为的对象，而不是仅仅存储数据的对象。</p>\n</div>\n</blockquote>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>很明显，throw 不过是一个存储数据的对象。所以，将目光移至依赖链上的\n<code>Frame</code> 类，所以，为他编写测试用例。</p>\n</div>\n<div class=\"ulist\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ul data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>测试用例\n<code>java      @Test      void testScoreNoThrows(){          Frame frame = new Frame();          frame.add(5);          assertEquals(5, frame.getScore());      }</code></p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>编译通过 ```java public class Frame \\{ private int itsScore = 0;\npublic void add(int pins) \\{</p>\n<div class=\"literalblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre> }\n\n public int getScore() {\n     return 0;\n }</pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>} <code>`</code></p>\n</div>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>测试通过</p>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">public class Frame {\n    private int itsScore = 0;\n    public void add(int pins) {\n        itsScore += pins;\n    }\n\n    public int getScore() {\n        return itsScore;\n    }\n}</code></pre>\n</div>\n</div>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这个时候，最最最基本的要求就达到了。但是对于 <code>add</code>\n方法，是十分脆弱的，当参数为 <code>11</code>\n的时候，就会出现预料之外的情况。但是现在其实并不需要太过多的考虑，我们首先做的不过是基础的进球能够实现。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这时 C 提出，现在的代码却有一个问题，我们以 <em>一轮</em>\n为单位，但是保龄球比赛是有十轮的，当进行到后面几轮的时候，调用\n<code>getScore</code> 是没有意义的，因为一个 <code>Frame</code>\n只代表了一轮。而且，当计算总分的时候还需要将所有的 <code>Frame</code>\n给一起计算起来，是十分繁琐的，那么我们希望的是什么呢？ —— <code>Frame</code>\n之间互相知晓，而谁会持有这些不同的 <code>Frame</code>\n对象呢？那应该上升依赖链，多个`Frame`\n是属于一场游戏（Game）的，这个时候，输出应该由 <code>Frame</code> 变成\n<code>Game</code>。<code>Game</code> 对象构建了 <code>Frame</code>\n并把他们串连起来，所以，我们注意力开始再次变化：</p>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>Throws 分数 ——&gt; Frame 轮数 ——&gt; Game 一场游戏</p>\n</div>\n</blockquote>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>现在我们将注意力放到 <code>Game</code> 上面，写一个同样的测试用例。</p>\n</div>\n<div class=\"ulist\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ul data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>测试用例</p>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">    @Test\n    void testOneThrows() {\n        Game game = new Game();\n        game.add(5);\n        assertEquals(5, game.score());\n    }</code></pre>\n</div>\n</div>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>编译通过 ```java public class Game \\{ private int itsScore = 0; public\nint score()\\{ return 0; }</p>\n<div class=\"literalblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre> public void add(int pins) {\n\n }</pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>} <code>`</code></p>\n</div>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>测试通过</p>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">public class Game {\n    private int itsScore = 0;\n    public int score(){\n        return itsScore;\n    }\n\n    public void add(int pins) {\n        itsScore += pins;\n    }\n}</code></pre>\n</div>\n</div>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>它具有和 <code>Frame</code> 具有同样的功能。但我们任然需要解决以及寻找需要多个\n<code>Frame</code> 的证据，因为他是我们使用 <code>Game</code> 的最初理由。我们逐步完成\n<code>Game</code>，S 提出编写一个有两次投掷但是没有补中的测试。</p>\n</div>\n<div class=\"ulist\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ul data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>测试用例</p>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">    @Test\n    void testTwoThrowsNoMark(){\n        Game game = new Game();\n        game.add(5);\n        game.add(4);\n        assertEquals(9, game.score());\n    }</code></pre>\n</div>\n</div>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>无需修改其他，编译通过</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>无需修改其他，测试通过</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>一轮两次的投掷，是没有问题，那么如果两轮四次呢？并且我们需要知道每一轮之后的分数是多少，接下来我们继续测试用例的书写。</p>\n</div>\n<div class=\"ulist\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ul data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>测试用例</p>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">    @Test\n    void testFourThrowsNoMark(){\n        Game game = new Game();\n        game.add(5);\n        game.add(4);\n        game.add(7);\n        game.add(2);\n        assertEquals(18, game.score());\n        assertEquals(9, game.scoreForFrame(1));\n        assertEquals(18, game.scoreForFrame(2));\n    }</code></pre>\n</div>\n</div>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>编译通过</p>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">    public int scoreForFrame(int frame) {\n        return 0;\n    }</code></pre>\n</div>\n</div>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>测试通过</p>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">public class Game {\n    /**\n     * 投掷序列，最大可能的投掷次数是 21 次 —— C 的回答\n     */\n    private int[] itsThrows = new int[21];\n    /**\n     * 当前第几轮投掷\n     */\n    private int itsCurrentThrow = 0;\n\n    private int itsScore = 0;\n    public int score(){\n        return itsScore;\n    }\n\n    public void add(int pins) {\n        // 存放到 投掷序列 中\n        itsThrows[itsCurrentThrow++] = pins;\n        itsScore += pins;\n    }\n\n    public int scoreForFrame(int frame) {\n        // 到指定轮数的总分\n        int score = 0;\n        for (int ball = 0;\n             frame &gt; 0 &amp;&amp; (ball &lt; theFrame);\n             ball += 2, frame --) {\n            score += itsThrows[ball] + itsThrows[ball + 1];\n        }\n        return score;\n    }\n}</code></pre>\n</div>\n</div>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>现在测试用例已经通过了，但是 S 提出他似乎不是那么美观，因为他违反了\n单一职责原则（SRP），所以需要重构，不过我们暂且把重构这件事情放放，C\n来简化这个循环。</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">    public int scoreForFrame(int theFrame) {\n        // 到指定轮数的总分\n        int score = 0;\n        int ball = 0;\n        for (int currentFrame = 0;\n             currentFrame &lt; theFrame;\n             currentFrame ++) {\n            score += itsThrows[ball++] + itsThrows[ball++];\n        }\n        return score;\n    }</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这样看上去比上面的好了很多，但是 C\n觉得会不会有其他问题呢？是的，他可能存在的的问题就是运算符的优先级问题，对于\n<code>score</code> 的值似乎和我们预想的不一样。我们稍微修改一下。</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">    public int scoreForFrame(int theFrame) {\n        // 到指定轮数的总分\n        int score = 0;\n        int ball = 0;\n        for (int currentFrame = 0; currentFrame &lt; theFrame; currentFrame ++) {\n            int firstThrow = itsThrows[ball++];\n            int secondThrow = itsThrows[ball++];\n            score += firstThrow + secondThrow;\n        }\n        return score;\n    }</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这样可能就明白了很多，对于密友补中和全中的情况，我们似乎已经完成了，来进行一次完整的测试——运行整个\n<code>TestGame</code> 类，他的三个已有的测试方法都会是绿色通过。</p>\n</div>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_简单重构\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">简单重构</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>C 提出我们现在的测试似乎有点问题</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">class TestGame {\n    @Test\n    void testOneGame(){\n        Game game = new Game();\n        //... other code\n    }\n\n    @Test\n    void testTwoThrowsNoMark(){\n        Game game = new Game();\n        //... other code\n    }\n\n    @Test\n    void testFourThrowsNoMark(){\n        Game game = new Game();\n        //... other code\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>是的，似乎都是重复性的 <code>new</code>\n，十分不友好，也<em>不敏捷</em>，那我们简单的重构下测试吧。</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">class TestGame {\n    private Game game;\n    // 对于 junit 4 ，你应该使用 @Before 注解\n    @BeforeEach\n    void setUp() {\n        game = new Game();\n    }\n\n    @Test\n    void testOneGame() {\n        game.add(5);\n        assertEquals(5, game.score());\n    }\n\n    @Test\n    void testTwoThrowsNoMark(){\n        game.add(5);\n        game.add(4);\n        assertEquals(9, game.score());\n    }\n\n    @Test\n    void testFourThrowsNoMark(){\n        game.add(5);\n        game.add(4);\n        game.add(7);\n        game.add(2);\n        assertEquals(18, game.score());\n        assertEquals(9, game.scoreForFrame(1));\n        assertEquals(18, game.scoreForFrame(2));\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>修改完后，应该运行整个类，以保证所有的测试方法都是可以通过的。</p>\n</div>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_补中情况\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">补中情况</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>简单重构测试完成，那么我们继续来写关于补中的情况，同样，测试驱动：</p>\n</div>\n<div class=\"ulist\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ul data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>测试用例</p>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">    @Test\n    void testSimpleSpare(){\n        game.add(3);\n        game.add(7);\n        game.add(3);\n        assertEquals(13, game.scoreForFrame(1));\n    }</code></pre>\n</div>\n</div>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>无需修改，编译通过</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>测试通过</p>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">    public int scoreForFrame(int theFrame) {\n        // 到指定轮数的总分\n        int score = 0;\n        int ball = 0;\n        for (int currentFrame = 0;\n             currentFrame &lt; theFrame;\n             currentFrame ++) {\n            int firstThrow = itsThrows[ball++];\n            int secondThrow = itsThrows[ball++];\n            // 这一轮的分数\n            int frameScore = firstThrow + secondThrow;\n            // 是否补选\n            if (frameScore == 10){\n                // 补选的情况需要加上下一轮的第一次分数\n                score += frameScore + itsThrows[ball++];\n            } else {\n                score += frameScore;\n            }\n        }\n        return score;\n    }</code></pre>\n</div>\n</div>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>C\n觉得看起来似乎不错，因为测试用例通过了，但是是否就完成了呢？来进行一个测试</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">    @Test\n    void testSimpleFrameAfterSpare() {\n        game.add(3);\n        game.add(7);\n        game.add(3);\n        game.add(2);\n        assertEquals(13, game.scoreForFrame(1));\n        assertEquals(18, game.score());\n    }</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>结果是红灯，为什么呢？（C\n似乎很高兴发现这个错误）看看期望值的得到的值的区别</p>\n</div>\n<div class=\"literalblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre>Expected :18\nActual   :15</pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>结果相差三分，就是第三次 投掷 的分数，因为我们在 <code>scoreForFrame</code>\n方法最后，使得 <code>ball</code> 加一了，所以跳过了第三次 投掷 的分数，那我们去掉\n<code>++</code> 看看</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">    if (frameScore == 10){\n        // 补选的情况需要加上下一轮的第一次分数\n        score += frameScore + itsThrows[ball++];\n    }</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>测试结果</p>\n</div>\n<div class=\"literalblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre>Expected :18\nActual   :15</pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>依旧不对且不变，那么我们试着把 <code>game.score()</code> 换成\n<code>game.scoreForFrame(2)</code> 试试？</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">    @Test\n    void testSimpleFrameAfterSpare() {\n        game.add(3);\n        game.add(7);\n        game.add(3);\n        game.add(2);\n        assertEquals(13, game.scoreForFrame(1));\n        assertEquals(18, game.scoreForFrame(2));\n    }</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>嘿，他通过了，那么问题应该是出在 <code>score()</code> 方法上了，我们来看看 <code>score</code>\n方法：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">    public int score(){\n        return itsScore;\n    }\n\n    public void add(int pins) {\n        // 存放到 投掷序列 中\n        itsThrows[itsCurrentThrow++] = pins;\n        itsScore += pins;\n    }</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>C 发现了错误：是的，似乎问题，确实出在这里，因为返回的是 <code>itsScore</code>\n，而这个变量标识的仅仅是木瓶数目的综合，但他却不是得分，我们应该让\n<code>score</code> 做的是用当前轮作为参数去调用 <code>scoreForFrame()</code>\n方法。我们不知道当前哪轮，所以我们需要先写一个能够让我们知道当前第几轮的方法，完善下前面已经通过的所有测试用例：</p>\n</div>\n<div class=\"ulist\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ul data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>完善测试用例</p>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Test\nvoid testOneGame() {\n    game.add(5);\n    assertEquals(5, game.score());\n    // 当前第一轮\n    assertEquals(1, game.getCurrentFrame());\n}\n\n@Test\nvoid testTwoThrowsNoMark(){\n    game.add(5);\n    game.add(4);\n    assertEquals(9, game.score());\n    // 当前第一轮\n    assertEquals(1, game.getCurrentFrame());\n}\n\n@Test\nvoid testFourThrowsNoMark(){\n    game.add(5);\n    game.add(4);\n    game.add(7);\n    game.add(2);\n    assertEquals(18, game.score());\n    assertEquals(9, game.scoreForFrame(1));\n    assertEquals(18, game.scoreForFrame(2));\n    // 当前第二轮\n    assertEquals(2, game.getCurrentFrame());\n}</code></pre>\n</div>\n</div>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>编译通过</p>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-hava\" data-lang=\"hava\">public int getCurrentFrame() {\n    return 0;\n}</code></pre>\n</div>\n</div>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>测试通过</p>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">    /**\n     * 当前第几轮\n     */\n    private int itsCurrentFrame = 0;\n    /**\n     * 是否是第一次投掷\n     */\n    private boolean firstThrow = true;\n\n    public int getCurrentFrame() {\n        return itsCurrentFrame;\n    }\n\n    public void add(int pins) {\n        // 存放到 投掷序列 中\n        itsThrows[itsCurrentThrow++] = pins;\n        itsScore += pins;\n        // 计算当前轮\n        if (firstThrow){\n            firstThrow = false;\n            itsCurrentFrame++;\n        } else {\n            firstThrow = true;\n        }\n    }</code></pre>\n</div>\n</div>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>我们为他添加了两个成员变量用来让我们更好的查找当前轮，然后在 <code>add</code>\n里面设置值，这时运行修改的测试用例都是通过了的。不过 <code>add</code>\n函数的功能似乎有点多了，我们来把他修改得更易读一些。</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">    public void add(int pins) {\n        // 存放到 投掷序列 中\n        itsThrows[itsCurrentThrow++] = pins;\n        itsScore += pins;\n        adjustCurrentFrame();\n    }\n\n    /**\n     *  计算当前轮\n     */\n    private void adjustCurrentFrame() {\n        if (firstThrow){\n            firstThrow = false;\n            itsCurrentFrame++;\n        } else {\n            firstThrow = true;\n        }\n    }</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>S 觉得似乎好多了，但是 当前轮 <code>itsCurrentFrame</code> 初始化为 0\n，是不是不太好？因为他不应该初始化为 0 ，应该为\n1，游戏是从第一轮开始而不是第 0\n轮。并且当前轮应该是正在进行的投掷的所在轮，应该在最后一次投掷完毕，才对他进行递增，而不是第一次投掷就递增，所以修改一下。</p>\n</div>\n<div class=\"ulist\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ul data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>修改测试用例</p>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Test\nvoid testTwoThrowsNoMark(){\n    game.add(5);\n    game.add(4);\n    assertEquals(9, game.score());\n    // 第一轮已经结束，到了第二轮了\n    assertEquals(2, game.getCurrentFrame());\n}\n\n@Test\nvoid testFourThrowsNoMark(){\n    game.add(5);\n    game.add(4);\n    game.add(7);\n    game.add(2);\n    assertEquals(18, game.score());\n    assertEquals(9, game.scoreForFrame(1));\n    assertEquals(18, game.scoreForFrame(2));\n    // 第二轮已经结束，到了第三轮了\n    assertEquals(3, game.getCurrentFrame());\n}</code></pre>\n</div>\n</div>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>无需修改，编译通过</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>测试通过</p>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">private int itsCurrentFrame = 1;\n\n/**\n *  计算当前轮\n */\nprivate void adjustCurrentFrame() {\n    if (firstThrow){\n        firstThrow = false;\n    } else {\n        firstThrow = true;\n        itsCurrentFrame++;\n    }\n}</code></pre>\n</div>\n</div>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>C 觉得不错，修改了后，更容易让人理解了。现在我们来为 <code>getCurrentFrame</code>\n方法编写两个具有补中情况的测试用例。</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">    @Test\n    void testSimpleSpare(){\n        game.add(3);\n        game.add(7);\n        game.add(3);\n        assertEquals(13, game.scoreForFrame(1));\n        assertEquals(2, game.getCurrentFrame());\n    }\n\n    @Test\n    void testSimpleFrameAfterSpare() {\n        game.add(3);\n        game.add(7);\n        game.add(3);\n        game.add(2);\n        assertEquals(13, game.scoreForFrame(1));\n        assertEquals(18, game.scoreForFrame(2));\n        assertEquals(3, game.getCurrentFrame());\n//        assertEquals(18, game.score());\n    }</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>通过了，现在我们回到原来的 <code>score</code> 的问题上来，现在已经有了\n当前轮，那么我们可以大胆的调用 <code>scoreForFrame</code> 方法了：</p>\n</div>\n<div class=\"ulist\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ul data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>测试用例</p>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Test\nvoid testSimpleFrameAfterSpare() {\n    game.add(3);\n    game.add(7);\n    game.add(3);\n    game.add(2);\n    assertEquals(13, game.scoreForFrame(1));\n    assertEquals(18, game.scoreForFrame(2));\n    assertEquals(3, game.getCurrentFrame());\n    assertEquals(18, game.score());\n}</code></pre>\n</div>\n</div>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>无需修改，编译通过</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>测试通过</p>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">public int score(){\n    return scoreForFrame(getCurrentFrame() - 1);\n}</code></pre>\n</div>\n</div>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>是的，这个方法测试通过了，但是其他的方法呢？在运行整个\n测试类，<code>testOneGame</code> 似乎有点问题：</p>\n</div>\n<div class=\"literalblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre>Expected :5\nActual   :0</pre>\n</div>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Test\nvoid testOneGame() {\n    game.add(5);\n    assertEquals(5, game.score());\n    // 当前第一轮\n    assertEquals(1, game.getCurrentFrame());\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>是代码的问题吗？不，你会发现这个测试用例根本不符合保龄球的规则，所以这个测试用例是不合法的。所以大可以将他直接去掉。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>补中的情况就完成了。</p>\n</div>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_全中情况\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">全中情况</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>我们依旧来编写一个全中的测试用例</p>\n</div>\n<div class=\"ulist\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ul data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>测试用例</p>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Test\nvoid test(){\n    game.add(10);\n    game.add(3);\n    game.add(6);\n    assertEquals(19, game.scoreForFrame(1));\n    assertEquals(28, game.score());\n    assertEquals(3, game.getCurrentFrame());\n}</code></pre>\n</div>\n</div>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>无需修改，编译通过</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>测试通过</p>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * 投掷\n *\n * @param pins 得分\n */\npublic void add(int pins) {\n    // 存放到 投掷序列 中\n    itsThrows[itsCurrentThrow++] = pins;\n    adjustCurrentFrame(pins);\n}\n\n/**\n *  计算当前轮\n */\nprivate void adjustCurrentFrame(int pins) {\n    if (firstThrow){\n        if (pins == 10){\n            // 全中\n            itsCurrentFrame++;\n        } else {\n            firstThrow = false;\n        }\n    } else {\n        firstThrow = true;\n        itsCurrentFrame++;\n    }\n}\n\n/**\n * 指定轮的总分\n *\n * @param theFrame 轮\n * @return 总分\n */\npublic int scoreForFrame(int theFrame) {\n    // 到指定轮数的总分\n    int score = 0;\n    int ball = 0;\n    for (int currentFrame = 0; currentFrame &lt; theFrame; currentFrame ++) {\n        int firstThrow = itsThrows[ball++];\n        if (firstThrow == 10){\n            // 全中\n            score += 10 + itsThrows[ball] + itsThrows[ball + 1];\n        } else {\n            int secondThrow = itsThrows[ball++];\n            // 这一轮的分数\n            int frameScore = firstThrow + secondThrow;\n            // 是否补选\n            if (frameScore == 10){\n                // 补选的情况需要加上下一轮的第一次分数\n                score += frameScore + itsThrows[ball];\n            } else {\n                score += frameScore;\n            }\n        }\n    }\n    return score;\n}</code></pre>\n</div>\n</div>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>通过啦！全中的情况似乎完成了？C 提出我们来一次完美的比赛评分看看</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">    @Test\n    void testPerfectGame() {\n        for (int i = 0; i &lt; 12; i++) {\n            game.add(10);\n        }\n        assertEquals(300, game.score());\n        assertEquals(10, game.getCurrentFrame());\n    }</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>但是似乎结果与我们相信的不同</p>\n</div>\n<div class=\"literalblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre>Expected :300\nActual   :330</pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>S 一眼就看出来了，是的，当前轮一直被累加到了 12，所以我们应该将他限定在\n10，修改一下方法</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">    private void adjustCurrentFrame(int pins) {\n        if (firstThrow){\n            if (pins == 10){\n                // 全中\n                itsCurrentFrame++;\n            } else {\n                firstThrow = false;\n            }\n        } else {\n            firstThrow = true;\n            itsCurrentFrame++;\n        }\n        itsCurrentFrame = Math.min(10, itsCurrentFrame);\n    }</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>但是。。。C 很暴躁的发现结果似乎不对，因为代码似乎是没有问题的</p>\n</div>\n<div class=\"literalblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre>Expected :300\nActual   :270</pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>S 细心的发现， <code>score</code>\n需要减一，所以他只给出了第九轮的得分，而不是第十轮，所以因该是十一</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">private void adjustCurrentFrame(int pins) {\n    if (firstThrow){\n        if (pins == 10){\n            // 全中\n            itsCurrentFrame++;\n        } else {\n            firstThrow = false;\n        }\n    } else {\n        firstThrow = true;\n        itsCurrentFrame++;\n    }\n    itsCurrentFrame = Math.min(11, itsCurrentFrame);\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>但是运行后，发现当前轮似乎不对。。。</p>\n</div>\n<div class=\"literalblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre>Expected :10\nActual   :11</pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>C 和 S\n讨论了一下，似乎觉得这也应该是正确的结果及时有点不舒服（What？）所以应该修改的是测试用例：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">    @Test\n    void testPerfectGame() {\n        for (int i = 0; i &lt; 12; i++) {\n            game.add(10);\n        }\n        assertEquals(300, game.score());\n        assertEquals(11, game.getCurrentFrame());\n    }</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>S 又想到了一种情况，如果最后数组全满了呢？</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Test\nvoid testEndOfArray() {\n    for (int i = 0; i &lt; 9; i++) {\n        game.add(0);\n        game.add(0);\n    }\n    game.add(2);\n    game.add(8);\n    game.add(10);\n    assertEquals(20, game.score());\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>很好，S 很开心因为他也通过了。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>再来测试下如果记分板的所有数据输入到程序中呢？</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Test\nvoid testSampleGame() {\n    game.add(1);\n    game.add(4);\n    game.add(4);\n    game.add(5);\n    game.add(6);\n    game.add(4);\n    game.add(5);\n    game.add(5);\n    game.add(10);\n    game.add(0);\n    game.add(1);\n    game.add(7);\n    game.add(3);\n    game.add(6);\n    game.add(4);\n    game.add(10);\n    game.add(2);\n    game.add(8);\n    game.add(6);\n    assertEquals(133, game.score());\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>通过啦，C 提议再来测试一下边界情况</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Test\nvoid testHeartBreak(){\n    for (int i = 0; i &lt; 11; i++) {\n        game.add(10);\n    }\n    game.add(9);\n    assertEquals(299, game.score());\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>通过啦，C 再次提议第十轮补中的情况如何：</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Test\nvoid testTenthFrameSpare() {\n    for (int i = 0; i &lt; 9; i++) {\n        game.add(10);\n    }\n    game.add(9);\n    game.add(1);\n    game.add(1);\n    assertEquals(270, game.score());\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h3 id=\"_重构\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">重构</h3>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>C 和 S\n都想不出其他的测试用例了，他们觉得应该重构这个这个程序。在这之前，应该测试一下整个\n<code>TestGame</code> 测试类的所有方法，保证他们都能够通过。</p>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>请注意，重构过程中一定保证所有测试用例都是通过的。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><span class=\"image\"><img src=\"https://resources.echocow.cn/file/2019/3/9/QQ%E6%88%AA%E5%9B%BE20190309224101.png\" alt=\"image\"></span></p>\n</div>\n</blockquote>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>下面来看看第一个需要重构的 <code>scoreForFrame</code> 方法</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">public int scoreForFrame(int theFrame) {\n    // 到指定轮数的总分\n    int score = 0;\n    int ball = 0;\n    for (int currentFrame = 0; currentFrame &lt; theFrame; currentFrame ++) {\n        int firstThrow = itsThrows[ball++];\n        if (firstThrow == 10){\n            // 全中\n            score += 10 + itsThrows[ball] + itsThrows[ball + 1];\n        } else {\n            int secondThrow = itsThrows[ball++];\n            // 这一轮的分数\n            int frameScore = firstThrow + secondThrow;\n            // 是否补选\n            if (frameScore == 10){\n                // 补选的情况需要加上下一轮的第一次分数\n                score += frameScore + itsThrows[ball];\n            } else {\n                score += frameScore;\n            }\n        }\n    }\n    return score;\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>emmmmm，，，的确很乱。C 提议可以把 <code>else</code> 下的一堆都给抽离为一个方法，S\n提议把局部变量变成成员变量，S 抢过键盘，进行重构。</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">    /**\n     * 是否是第一次投掷\n     */\n    private boolean firstThrowInFrame = true;\n    /**\n     * 当前序列\n     */\n    private int ball;\n    /**\n     * 第一次投掷\n     */\n    private int firstThrow;\n    /**\n     * 第二次投掷\n     */\n    private int secondThrow;\n    /**\n     *  计算当前轮\n     */\n    private void adjustCurrentFrame(int pins) {\n        if (firstThrowInFrame){\n            if (pins == 10){\n                // 全中\n                itsCurrentFrame++;\n            } else {\n                firstThrowInFrame = false;\n            }\n        } else {\n            firstThrowInFrame = true;\n            itsCurrentFrame++;\n        }\n        itsCurrentFrame = Math.min(11, itsCurrentFrame);\n    }\n\n    /**\n     * 指定轮的总分\n     *\n     * @param theFrame 轮\n     * @return 总分\n     */\n    public int scoreForFrame(int theFrame) {\n        // 到指定轮数的总分\n        int score = 0;\n        ball = 0;\n        for (int currentFrame = 0; currentFrame &lt; theFrame; currentFrame ++) {\n            firstThrow = itsThrows[ball++];\n            if (firstThrow == 10){\n                // 全中\n                score += 10 + itsThrows[ball] + itsThrows[ball + 1];\n            } else {\n                score += handleSecondThrow();\n            }\n        }\n        return score;\n    }\n\n    /**\n     * 第二次投掷的结果\n     *\n     * @return 分数\n     */\n    private int handleSecondThrow(){\n        int score = 0;\n        secondThrow = itsThrows[ball++];\n        // 这一轮的分数\n        int frameScore = firstThrow + secondThrow;\n        // 是否补选\n        if (frameScore == 10){\n            // 补选的情况需要加上下一轮的第一次分数\n            score += frameScore + itsThrows[ball];\n        } else {\n            score += frameScore;\n        }\n        return score;\n    }</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这似乎好多了，<strong>修改完成后，一定要记得运行所有的测试用例保证通过。</strong>但是对于\n<code>scoreForFrame</code> 似乎不是那么易理解，C 提出的伪代码</p>\n</div>\n<div class=\"literalblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre>if strike\n    score += 10 + nextTwoBalls();\nelse if spare\n    score += 10 + nextBall();\nelse\n    score += twoBallInFrame();</pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>S 看到很高兴，因为这不就是保龄球的积分规则吗？我们改改看，并且去掉\n<code>firstThrow</code> 和 <code>secondThrow</code> 两个成员变量，并用恰当的函数来替代他。</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * 指定轮的总分\n *\n * @param theFrame 轮\n * @return 总分\n */\npublic int scoreForFrame(int theFrame) {\n    // 到指定轮数的总分\n    int score = 0;\n    ball = 0;\n    for (int currentFrame = 0; currentFrame &lt; theFrame; currentFrame ++) {\n        if (strike()){\n            ball ++;\n            // 全中\n            score += 10 + nextTwoBalls();\n        } else {\n            score += handleSecondThrow();\n        }\n    }\n    return score;\n}\n\n/**\n * 第二次投掷的结果\n *\n * @return 分数\n */\nprivate int handleSecondThrow(){\n    int score = 0;\n    // 是否补中\n    if (spare()){\n        // 补中的情况需要加上下一轮的第一次分数\n        ball += 2;\n        score += 10 + nextBall();\n    } else {\n        score += twoBallsInFrame();\n        ball += 2;\n    }\n    return score;\n}\n\n/**\n * 2. 添加方法：是否全中\n *\n * @return 结果\n */\nprivate boolean strike() {\n    return itsThrows[ball] == 10;\n}\n\n/**\n * 3. 添加方法：下面两次投掷的结果之和\n *\n * @return 和\n */\nprivate int nextTwoBalls(){\n    return itsThrows[ball] + itsThrows[ball + 1];\n}\n\n/**\n * 4. 添加方法，是否补中\n *\n * @return 补中\n */\nprivate boolean spare() {\n    return (itsThrows[ball] + itsThrows[ball + 1]) == 10;\n}\n\n/**\n * 5. 添加方法：下一次投掷分数\n *\n * @return 分数\n */\nprivate int nextBall() {\n    return itsThrows[ball];\n}\n\n/**\n * 6. 一轮中的两个投掷结果之和\n *\n * @return 和\n */\nprivate int twoBallsInFrame() {\n    return itsThrows[ball] + itsThrows[ball + 1];\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>运行测试用例全部通过，并且不会再有 <code>firstThrow</code> 和 <code>secondThrow</code> 和\n<code>frameScore</code> 三个成员变量了。接下来我们看看，C 提出唯一耦合的就是 <code>ball</code>\n这个变量了，现在都是独立处理三种情况的，那我们合并处理看看</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * 指定轮的总分\n *\n * @param theFrame 轮\n * @return 总分\n */\npublic int scoreForFrame(int theFrame) {\n    // 到指定轮数的总分\n    int score = 0;\n    ball = 0;\n    for (int currentFrame = 0; currentFrame &lt; theFrame; currentFrame ++) {\n        if (strike()){\n            // 全中\n            score += 10 + nextTwoBalls();\n            ball ++;\n        } else if (spare()){\n            // 补中\n            score += 10 + nextBallForSpare();\n            ball += 2;\n        } else {\n            score += handleSecondThrow();\n        }\n    }\n    return score;\n}\n/**\n * 一轮中的两个投掷结果之和\n *\n * @return 和\n */\nprivate int twoBallsInFrame() {\n    return itsThrows[ball] + itsThrows[ball + 1];\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>这样就很帮棒了，一眼就看出来规则。不过 C 和 S\n又吵起来了。有一句话非常好：</p>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>自上而下，测试优先设计，坦白地说，我不知道这是不是一个好的规则，只是这次，他帮了我们。所以下次，我会再次尝试看看他会发生什么。</p>\n</div>\n</blockquote>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>他们最后商定将他们分成几个对象，一些小规模的更改。</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">public class Game {\n    /**\n     * 当前第几轮\n     */\n    private int itsCurrentFrame = 1;\n    /**\n     * 分数\n     */\n    private int itsScore = 0;\n    /**\n     * 得分运动员\n     */\n    private Scorer itsScorer = new Scorer();\n    /**\n     * 是否是第一次投掷\n     */\n    private boolean firstThrowInFrame = true;\n    /**\n     * 计算总分\n     *\n     * @return 总分\n     */\n    public int score(){\n        return itsScorer.scoreForFrame(getCurrentFrame() - 1);\n    }\n\n    /**\n     * 投掷\n     *\n     * @param pins 得分\n     */\n    public void add(int pins) {\n        // 存放到 投掷序列 中\n        itsScorer.addThrow(pins);\n        itsScore += pins;\n        adjustCurrentFrame(pins);\n    }\n\n    /**\n     *  计算当前轮\n     */\n    private void adjustCurrentFrame(int pins) {\n        if (firstThrowInFrame){\n            if (pins == 10){\n                // 全中\n                itsCurrentFrame++;\n            } else {\n                firstThrowInFrame = false;\n            }\n        } else {\n            firstThrowInFrame = true;\n            itsCurrentFrame++;\n        }\n        itsCurrentFrame = Math.min(11, itsCurrentFrame);\n    }\n\n\n\n    /**\n     * 当前第几轮\n     *\n     * @return 当前轮\n     */\n    public int getCurrentFrame() {\n        return itsCurrentFrame;\n    }\n\n    public int scoreForFrame(int theFrame) {\n        return itsScorer.scoreForFrame(theFrame);\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">public class Scorer {\n    /**\n     * 当前序列\n     */\n    private int ball;\n    /**\n     * 投掷序列，最大可能的投掷次数是 21 次\n     */\n    private int[] itsThrows = new int[21];\n    /**\n     * 当前第几轮投掷\n     */\n    private int itsCurrentThrow = 0;\n\n    public void addThrow(int pins) {\n        itsThrows[itsCurrentThrow++] = pins;\n    }\n    /**\n     * 指定轮的总分\n     *\n     * @param theFrame 轮\n     * @return 总分\n     */\n    public int scoreForFrame(int theFrame) {\n        // 到指定轮数的总分\n        int score = 0;\n        ball = 0;\n        for (int currentFrame = 0; currentFrame &lt; theFrame; currentFrame ++) {\n            if (strike()){\n                // 全中\n                score += 10 + nextTwoBalls();\n                ball ++;\n            } else if (spare()){\n                // 补中\n                score += 10 + nextBallForSpare();\n                ball += 2;\n            } else {\n                score += handleSecondThrow();\n            }\n        }\n        return score;\n    }\n\n    /**\n     * 第二次投掷的结果\n     *\n     * @return 分数\n     */\n    private int handleSecondThrow(){\n        int score = 0;\n        // 是否补中\n        if (spare()){\n            // 补中的情况需要加上下一轮的第一次分数\n            ball += 2;\n            score += 10 + nextBallForSpare();\n        } else {\n            score += twoBallsInFrame();\n            ball += 2;\n        }\n        return score;\n    }\n\n    /**\n     * 2. 添加方法：是否全中\n     *\n     * @return 结果\n     */\n    private boolean strike() {\n        return itsThrows[ball] == 10;\n    }\n\n    /**\n     * 3. 添加方法：下面两次投掷的结果之和\n     *\n     * @return 和\n     */\n    private int nextTwoBalls(){\n        return itsThrows[ball + 1] + itsThrows[ball + 2];\n    }\n\n    /**\n     * 4. 添加方法，是否补中\n     *\n     * @return 补中\n     */\n    private boolean spare() {\n        return (itsThrows[ball] + itsThrows[ball + 1]) == 10;\n    }\n\n    /**\n     * 5. 添加方法：下一次投掷分数\n     *\n     * @return 分数\n     */\n    private int nextBallForSpare() {\n        return itsThrows[ball + 2];\n    }\n\n    /**\n     * 6. 一轮中的两个投掷结果之和\n     *\n     * @return 和\n     */\n    private int twoBallsInFrame() {\n        return itsThrows[ball] + itsThrows[ball + 1];\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>S 很高兴，因为现在 <code>Game</code> 只知晓 <code>Frame</code>，<code>Scorer</code>\n只计算得分，完全符合单一职责原则。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>C 发现多余的变量 <code>itsScore</code></p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">public void add(int pins) {\n    itsScorer.addThrow(pins);\n    adjustCurrentFrame(pins);\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>现在应该来看看 <code>adjustCurrentFrame</code> 啦</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n *  计算当前轮\n */\nprivate void adjustCurrentFrame(int pins) {\n    if (firstThrowInFrame){\n        if (pins == 10){\n            // 全中\n            itsCurrentFrame++;\n        } else {\n            firstThrowInFrame = false;\n        }\n    } else {\n        firstThrowInFrame = true;\n        itsCurrentFrame++;\n    }\n    itsCurrentFrame = Math.min(11, itsCurrentFrame);\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>C 非常不喜欢那个 十一 ，但是却没有办法。。。</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">private void adjustCurrentFrame(int pins) {\n    if (firstThrowInFrame){\n        if (pins == 10){\n            advanceFrame();\n        } else {\n            firstThrowInFrame = false;\n        }\n    } else {\n        firstThrowInFrame = true;\n        advanceFrame();\n    }\n}\n\nprivate void advanceFrame() {\n    itsCurrentFrame = Math.min(11, itsCurrentFrame + 1);\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>接下来我们把关于全中的情况判断取出来作为一个独立的方法。</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">private void adjustCurrentFrame(int pins) {\n    if (firstThrowInFrame){\n        if(!adjustFrameForStrike(pins)){\n            firstThrowInFrame = false;\n        }\n    } else {\n        firstThrowInFrame = true;\n        advanceFrame();\n    }\n}\n\nprivate boolean adjustFrameForStrike(int pins) {\n    if (pins == 10){\n        advanceFrame();\n        return true;\n    }\n    return false;\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>接下来，去掉 <code>getCurrentFrame</code> 方法，也去掉调用的地方，就可以把 11 改成\n10 啦。</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">/**\n * 计算总分\n *\n * @return 总分\n */\npublic int score(){\nreturn itsScorer.scoreForFrame(itsCurrentFrame);\n}\n\nprivate void advanceFrame() {\n    itsCurrentFrame = Math.min(10, itsCurrentFrame + 1);\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p><code>adjustCurrentFrame</code> 似乎有点表意不明</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">private void adjustCurrentFrame(int pins) {\n    if (!firstThrowInFrame || pins == 10){\n        advanceFrame();\n    } else {\n        firstThrowInFrame = false;\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>让他表意更加明确</p>\n</div>\n<div class=\"listingblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"content\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">private void adjustCurrentFrame(int pins) {\n    if (lastBallInFrame(pins)){\n        advanceFrame();\n    } else {\n        firstThrowInFrame = false;\n    }\n}\n\nprivate boolean lastBallInFrame(int pins) {\n    return strike(pins) || !firstThrowInFrame;\n}\n\nprivate boolean strike(int pins) {\n    return firstThrowInFrame &amp;&amp; pins == 10;\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>C 和 S 很高兴，因为终于完成了。我也很高兴，因为终于看懂了 T\nT，所以实践真的很重要。完整的测试（添加显示的名称）\n<span class=\"image\"><img src=\"https://resources.echocow.cn/file/2019/3/9/QQ%E6%88%AA%E5%9B%BE20190309224835.png\" alt=\"image\"></span></p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<h2 id=\"_总结\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">总结</h2>\n<div class=\"sectionbody\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>理论结合实践，是学习的不变真理。上周学习的时候不过是一些理论的东西，这周参与实践了一番，不得不说的是，敏捷开发真的挺累，但是效率与结果都让人满意，不过这不就是他诱人的地方吗？其中比较出名的\nXP\n编程，对于结对的思想也有了概念，但是有时候在想，倘若两个人的思想、基础都存在太大差异，对于弱势方自然收益匪浅，但是对于强势方就是有点累了。不过相比起一个团队的和谐程度，以及进步水平都是具有十分快速的提高的。就像敏捷开发里面的思想：<strong>你大可以选择你完全没有接触过和你不懂的专业领域，因为你相信在那里会有人和你一起结对，你可以在这个团队中快速的进步，这就是敏捷开发，一个自组织团队应该有的。</strong></p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>在这次实践中，从一开始两个人的互相思考，再到各自的思想结合，C\n总能发现一些小细节，S\n总能提出一些很好的解决问题的办法，他们两个能够想到覆盖后面可能出现的情况，从开始设计，到编程，两个人都进行了互补。而我也从这个过程彻底明白了<strong>测试驱动开发</strong>，在我总结下来三个非常重要的步骤</p>\n</div>\n<div class=\"olist arabic\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ol class=\"arabic\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>编写测试用例</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>编译通过</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>测试通过</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>并且，他们对用户素材非常清楚，在最后的重构中，一直不断往用户素材靠拢，例如，他们一直记得保龄球的三种情况，随后重构出来的几个方法的语句是完全和保龄球的规则是对应的。并且每一个语句都能够见名知意，即使有些变量封装成了方法，但是也是一眼就知道什么意思了。他们两总能在彼此看不到的地方提出新的建议，结对莫过于此，忽然感觉，自己一个人学了那么久，变得了自私了很多，这是可悲的，有时候一个人久了，就不太想和别人一起了，以前学习的时候找过别人，但都没有人陪我走下去，最后剩下的也只有自己。这可能是我非常喜欢\nXP\n思想结对编程的原因之一吧，因为自己十分羡慕这么一份团队。所以也慢慢反省这两年来的大学生活，在余下的大学生活里面也会慢慢改变自己。</p>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>后面的章节，学习到了很多重构的细节，但是重构真的是一门学问，始终不太清楚重构到一种什么程度才算完美，可能就是不断地不断地让代码更加易读更加友好，这或许就是重构的意义。重构最后思考来或许可以从以下几点入手：</p>\n</div>\n<div class=\"olist arabic\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ol class=\"arabic\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>代码易读性，能够见名知意。</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>尽量消除成员变量，因为永远不知道多少个地方进行修改了，能够选择函数最好。</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>一个函数最好负责已经事情，不要让他负责过多的事情。</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>多对条件语句的条件进行封装，能够增加代码的易读性。</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>尽量遵循一些必要的原则，例如 开放封闭原则、单一职责原则等。</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>对于耦合的变量，尽量消除。</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>每一次重构，务必要保证所有已有的测试用例通过，才算成功一半。</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>有意义的重构，才算成功的另一半。</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>而作者在结论最后一章提到了几个很重要的点。</p>\n</div>\n<div class=\"quoteblock\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<blockquote>\n<div class=\"olist arabic\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<ol class=\"arabic\">\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>面向对象不是必须的，某些时候，敏捷开发也提倡简单。</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>图示有时是不需要的，在创建了他们而没有验证他们的代码就打算遵循他们时，图示就是无意的。</p>\n</li>\n<li data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>有时，最好的设计是在你首先编写测试，一小步一小步前进时逐渐形成的。</p>\n</li>\n</ol>\n</div>\n</blockquote>\n</div>\n<div class=\"paragraph\" data-sal=\"fade\" data-sal-duration=\"500\" data-sal-repeat=\"true\">\n<p>下一章开始敏捷设计，期待到来。晚安各位～</p>\n</div>\n</div>\n</div>","document":{"title":"[阅读] 敏捷软件开发 —— 敏捷开发（二）"},"pageAttributes":{"category":"阅读","description":"[阅读] 敏捷软件开发 —— 敏捷开发（二）","image":"https://img.hacpai.com/bing/20180816.jpg?imageView2/1/w/960/h/540/interlace/1/q/100","sort":null}}},"pageContext":{"slug":"/articles/2019/03/09/1552119273889.html","next":{"document":{"title":"solo 独立部署和 Tomcat 模式自动更新"},"fields":{"slug":"/articles/2019/03/12/1552380944073.html"}},"previous":{"document":{"title":"[阅读] 敏捷软件开发 —— 敏捷开发（一）"},"fields":{"slug":"/articles/2019/03/01/1551401439594.html"}}}},"staticQueryHashes":["3069561552","3673333084"]}