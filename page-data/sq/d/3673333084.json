{"data":{"allAsciidoc":{"nodes":[{"content":"= Asciidoctor Demo\nDan Middlename Allen <thedoc@asciidoctor.org>\nv2.0, 2020-01-15: Rewritten for version 2\n:page-description: A demo of Asciidoctor. This document exercises numerous features of AsciiDoc to test Asciidoctor compliance.\n:page-category: test\n:page-sort: 1\n:page-image: https://rmt.dogedoge.com/fetch/fluid/storage/hexo-static/cover.jpg?w=480&fmt=webp\n:toc:\n:source-highlighter: pygments\n:source-linenums-option:\n:page-exclude: true\n\nDocGist is a URL proxy tool that converts http://asciidoctor.org/docs/asciidoc-syntax-quick-reference/[AsciiDoc] documents fetched from Gists (http://gist.github.com), GitHub repositories, Dropbox folders and other sources to HTML.\nThe conversion to HTML is performed in the browser (client-side) using the https://github.com/asciidoctor/asciidoctor.js[Asciidoctor.js] JavaScript library.\nDocGist can render documents located anywhere, as long as the host permits cross-domain access.\n\n\n[source,css]\n----\nspan.foo {\n\tbackground-color: navy;\n\tcolor: #BFD;\n}\n\nspan.bar {\n\tbackground: rgba(105, 0, 12, .38);\n\tcolor: hsl(30, 100%, 50%);\n\tborder-color: transparent;\n}\n----\n\n[%hardbreaks]\n`#fcf`\n`#00BCD4`\n`rgb(232, 74, 87)`\n`rgba(103,58,183,50%)`\n`hsl(88, 50%, 53%)`\n`hsla(36, 100%, 50%, 75%)`\n\nWe should use the color color:blueviolet[] in our logo.\n\nLet's take an example with a _GraphViz_ \"Hello World\":\n\n[graphviz]\n....\ndigraph foo {\n  node [style=rounded]\n  node1 [shape=box]\n  node2 [fillcolor=yellow, style=\"rounded,filled\", shape=diamond]\n  node3 [shape=record, label=\"{ a | b | c }\"]\n\n  node1 -> node2 -> node3\n}\n....\nemoji:wink[]\n\n:stem:\n\nA matrix can be written as\n\n[stem]\n++++\n[[a,b],[c,d]]((n),(k))\nsqrt(4) = 2\nsqrt(9) = 3\n++++\n\n[stem]\n++++\n令 g(x) = [f(b)-f(a)]·F(\\xi) - [F(b)-F(a)]·f(\\xi) \\\\\n而 g(a) = g(b) \\\\\n由罗尔定理，g(\\xi) = 0 \\\\\n即 [f(b)-f(a)]·F'(\\xi) - [F(b)-F(a)]·f'(\\xi) = 0\n++++\n\n\n\nThe DocGist project is found at https://github.com/asciidoctor/docgist where you can get the code, file issues and contribute.\n\n[NOTE]\nDocGist uses the https://github.com/asciidoctor/asciidoctor/releases/tag/v1.5.3[latest release (1.5.3)] of Asciidoctor.\nIf you want to use the syntax of older versions, add `:compat-mode:` to the document header or by setting it in the btn:[Attributes] menu.\nThere's more information on this in the link:./?github-asciidoctor%2Fasciidoctor.org%2F%2Fdocs%2Fmigration.adoc[migration guide].\n\n[[basic]]\n== icon:play[] The basics\n\n[[how-to-use]]\n=== icon:map-o[] How to use\n\n* Create/locate a gist on GitHub (or use a file in Dropbox).\n** Write text using AsciiDoc syntax in it.\n** Save it.\n* Enter the URL (or id) of the gist in the form on top of this page and hit Enter on your keyboard.\n* The page is rendered.\n* Share the URL to the page with others so they can read it.\n\nFor other possible hosts that can store documents, see <<source-documents>>.\n\n[[images]]\n=== icon:photo[] Images\n\nRelative image URLs are resolved to the same location as the document.\nIf the images are located elsewhere, use the `imagesdir` attribute to point out the location.\nSee the http://asciidoctor.org/docs/user-manual/#set-the-images-directory[Asciidoctor user manual] for the details.\nThere's also an <<images#images,image example>> here on DocGist.\n\n[source,asciidoc]\n----\nimage::sunset.jpg[]\n----\n\nIs rendered as:\n\nimage::sunset.jpg[]\n\n[[toc-how-to]]\n=== icon:list[] Table of contents\n\nThe table of content appears below the header by default.\nYou can alter this by setting a different value for the `toc` attribute.\nThe available options are found in the btn:[Attributes] menu.\n\nTo add a table of contents at any location you want, put this in the place you want it to appear:\n\n[source,asciidoc]\n....\ntoc::[]\n....\n\nand set the `toc` attribute to `macro` (in the document or via the btn:[Attributes] menu).\n\nThere's such a `toc` macro embedded in this document.\nIf you set the `toc` attribute to `macro` on this page, the table of contents will appear below this line!\n\ntoc::[]\n\n[[source-highlight]]\n=== icon:code[] Source code highlighting\n\nBy default, source code is highlighted using https://codemirror.net/[CodeMirror].\nSee the <<codemirror#codemirror,CodeMirror example>> for more information.\n\nSimply include the source code like this:\n\n[source,asciidoc,linenums,highlight='1-3']\n....\n[source,ruby]\n.app.rb\n----\nrequire 'sinatra'\nget '/hi' do\n \"Hello World!\"\nend\n----\n....\n\n[TIP]\nIt's possible to use Unicode glyphs as admonition icons.\n\n----\nline of code  // <1>\nline of code  # <2>\nline of code  ;; <3>\n----\n<1> A callout behind a line comment for C-style languages.\n<2> A callout behind a line comment for Ruby, Python, Perl, etc.\n<3> A callout behind a line comment for Clojure.\n\nThis is how it gets rendered:\n\n[source,ruby]\n.app.rb\n----\nrequire 'sinatra'\nget '/hi' do\n  \"Hello World!\"\nend\n----\n\nhttps://code.google.com/p/google-code-prettify/[Prettify] is supported as well.\nSee the <<prettify#prettify,Prettify example>> for how to activate it.\n\nhttps://highlightjs.org/[highlight.js] is supported too.\nSee the <<highlightjs#highlightjs,highlight.js example>> for how to activate it.\n\nIf you want to set a default language for `source` blocks, set the `source-language` attribute in the document header.\nSee <<source-language#source-language,Source language>> for how to use it.\n\n[NOTE]\n====\n* Only one source highlighter can be defined per document when using DocGist.\n* The source highlighter must be set in the document header.\n====\n\n[CAUTION]\n.Experimental Features in DocGist\n====\n* Highlighting can be used inline as well, for example `[src-ruby]`do`` renders like: [src-ruby]`do`.\n* Multiple code snippets in different languages can be combined into a tabbed view.\nSee the <<tabbed-source#tabbed-source,Tabbed source>> example for more information.\n====\n\n[[advanced]]\n== icon:forward[] Advanced features\n\n[[math]]\n=== icon:calculator[] Math\n\n:url-mathjax: https://www.mathjax.org/\n:url-asciimath: http://docs.mathjax.org/en/latest/asciimath.html\n:url-latex: http://docs.mathjax.org/en/latest/tex.html\n\nThanks to {url-mathjax}[MathJax] mathematical expressions can be typeset in DocGist documents.\nThe content can be written as {url-asciimath}[AsciiMath] or use {url-latex}[TeX/LaTeX] notation.\n\nFor block content, do like this:\n\n[source,asciidoc]\n....\n[stem]\n++++\nsqrt(4) = 2\n++++\n....\n\nIt will render like below:\n\n[stem]\n++++\nsqrt(4) = 2\n++++\n\nYou can use it inline as well, for example:\n\n[source,asciidoc]\n....\nWater (stem:[H_2O]) is a critical component.\n....\n\nWhich renders like this: Water (stem:[H_2O]) is a critical component.\n\n[TIP]\nThere's no need for special delimiters around the expression as the MathJax documentation suggests.\nThis is handled automatically by Asciidoctor!\n\nThe default notation is AsciiMath, but LaTeX can be used like this:\n\n[source,asciidoc]\n....\nlatexmath:[C = \\alpha + \\beta Y^{\\gamma} + \\epsilon]\n....\n\nlatexmath:[C = \\alpha + \\beta Y^{\\gamma} + \\epsilon]\n\n[[ui-macros]]\n=== icon:keyboard-o[] Keyboard shortcuts and more\n\n:url-ui-macros: http://asciidoctor.org/docs/user-manual/#user-interface-macros\n\nThis is a common shortcut on Windows systems: kbd:[Ctrl+Alt+Delete].\n\nHere's the source:\n\n[source,asciidoc]\n....\nkbd:[Ctrl+Alt+Delete]\n....\n\nYou might want to represent a user interface button like btn:[Save].\n\nHere's how to do it:\n\n[source,asciidoc]\n....\nbtn:[Save]\n....\n\n[NOTE]\nHere on DocGist we use actual (extra small) buttons from Bootstrap.\nIn normal Asciidoctor it would have looked more along the lines of *[ Save ]*.\n\nYet another nifty feature, representing a menu item:\n\nmenu:File[New...]\n\nSource:\n\n[source,asciidoc]\n....\nmenu:File[New...]\n....\n\n[IMPORTANT]\nRepresenting keyboard shortcuts, buttons, and menu items are experimental features in Aciidoctor.\nDocGist has the `experimental` flag set by default for your convenience!\n\nFor the reference documentation, see {url-ui-macros}[User Interface Macros].\n\n[[tips]]\n=== icon:exclamation-circle[] Tips and tricks\n\nLinks to other DocGists can use this syntax: `+link:./?5897167[DocGist intro]+` which renders as link:./?5897167[DocGist intro].\nThis makes things easier in case you run DocGist locally to fiddle with the \"`backend`\" (it's a frontend really).\n\nYou can view the source Gist of this page by clicking on the green button in the navbar.\n\nHow about some UML?\nThe following image is included using the syntax [src-asciidoc]`image::http://yuml.me/c9ce39b0.png[]`.\n\nimage::http://yuml.me/c9ce39b0.png[]\n\nThe URL is a reference to a yUML image.\nyUML is tool for creating UML diagrams online.\n\n[[source-documents]]\n=== icon:file-text-o[] Source documents\n\nDocGist can view documents fetched from a number of different sources.\nIt parses the URL to find out how to use it, and tries to be a bit smart to keep DocGist URLs short.\n\n[horizontal]\nGitHub Gist::\nA public or private GitHub Gist can be used.\nExample URL: https://gist.github.com/nawroth/5897167\nA GitHub Gist allows for storing multiple documents, but DocGist will only the first AsciiDoc document it finds.\n\nGitHub File::\nA file in a public git repo hosted at GitHub.\nExample URL: https://github.com/asciidoctor/docgist/blob/master/gists/example.adoc\n\nDropbox Public folder::\nPut a file in the _Public_ folder of your Dropbox, grab the URL to it.\nExample URL: https://dl.dropboxusercontent.com/u/10666617/AsciiDoc/example.adoc\n\nDropbox shared private file::\nUse the share-link of a private file in Dropbox.\nExample URL: https://www.dropbox.com/s/ttib5v9pfs23p9z/example.adoc\n\nCopy.com::\nUse the public link to the document.\nExample URL: https://copy.com/LdKsHnQbEZsl29BW\n\nEtherpad::\nhttp://etherpad.org/[Etherpad] is an online editor providing collaborative editing in real-time.\nThere are different Etherpad hosts, these are ones that worked well when we tried them:\nhttps://beta.etherpad.org/, https://piratepad.ca/, https://factor.cc/pad/, https://pad.systemli.org/, https://pad.fnordig.de/, https://notes.typo3.org/, https://pad.lqdn.fr/, https://pad.okfn.org/, https://beta.publishwith.me/, https://etherpad.tihlde.org/, https://pad.tihlde.org/, https://etherpad.wikimedia.org/, https://etherpad.fr/, https://piratenpad.de/, https://bitpad.co.nz/, http://notas.dados.gov.br/, http://free.primarypad.com/, http://board.net/, https://pad.odoo.com/, http://pad.planka.nu/, http://qikpad.co.uk/, http://pad.tn/, http://lite4.framapad.org/, http://pad.hdc.pw/\nNote that the content might get removed from the host after some time.\nExample URL: https://beta.etherpad.org/p/docgist\n\nGoogle Docs Documents::\nWrite normal AsciiDoc in the document.\nThen use the _share_ link, set so that anyone with the link can view (at least) the document.\nExample URL: https://docs.google.com/document/d/1lEQTEAQRVxTtDfQ1N9HJ6azeOLYCKlGG17NOs72NWsU/edit\n\nAny URL::\nDocGist accepts documents from any host which allows for cross-domain requests.\nThis is the kind of error you'll see in the console when a host doesn't support it:\n+\n....\nNo 'Access-Control-Allow-Origin' header is present on the requested resource.\nOrigin 'http://gist.asciidoctor.org' is therefore not allowed access.\n....\n+\nTo make it work, the server should respond with one of the following headers:\n`Access-Control-Allow-Origin:http://gist.asciidoctor.org` or\n`Access-Control-Allow-Origin:*`.\n\n[TIP]\n.Additional services that should get added?\n====\nPlease tell us if there's some additional service you'd like to see support for.\nThere's two different ways a host can be integrated:\n\nDirect file access::\nDropbox and Google Docs are examples of this.\nWe only calculate the URL of the file, and request it.\nThe server must respond with the correct headers as outlined above.\n\nThrough a public API::\nThis is what we use for GitHub.\nNote that we can only use an API as long as authorization isn't required.\n\n//\nTo suggest an addition, file an https://github.com/asciidoctor/docgist/issues/[issue]!\n====\n","fields":{"slug":"/post/2020-01-01/","birthTime":"2021-06-13T07:23:38.341Z","modifiedTime":"2021-06-13","year":2021},"document":{"title":"Asciidoctor Demo"}},{"content":"= 关于\n:page-exclude: true\n:page-image: https://rmt.dogedoge.com/fetch/fluid/storage/hexo-static/cover.jpg?w=480&fmt=webp\n:page-created: 1536269239000\n:page-modified: 1567077466773\n\n普通二本第一届软件工程小白鼠。自己选了软工，从小接触计算机，但是只会打游戏。大二真正开始学习，然后慢慢的了解计算机，渐渐的接触了编程，开始走自己的路。不过很多时候还是一个没有长大的小孩子，喜欢三毛，所以用了她的英文名 Echo，自己属性为牛，也是头顶双漩很是浑，于是定下 Echo Cow——回响的牛。亦是我性格的写照，不过依旧活的很开心，家庭幸福，爸妈爱我，直到现在发现，学习是一件很快乐的事。自律是作用最大的，自己的路还很长，97年的我，在我的眼里，依旧十八(逃。。。。\n\n> 嘘，用心去听，他在回响。\n\n. 主 java ，想做前端，想搞安全，想走运维，想弄Android，想搞人工智能，想找另一半，啥都想哈哈哈~~然后现在还是一个 单身狗 + 后端码农 。\n. 还能对计算机保持一种兴奋，能够享受时间流逝，微微的眩晕。\n. 依旧保持一份天真，尚且存在一份活力。\n. 喜欢打游戏，喜欢做一些有成就感的事，更喜欢可爱的东西。\n. 人不帅但很暖，爱打闹但心细，不会说话但爱笑，感觉自己是个渣男。\n. 朋友很多，每天都很开心。笑起来眼睛就没有了，个子硬伤但不自卑，普通话不好但爱说普通话。\n. 很注重外表，渐渐地开始收拾自己。\n. 书屯了很多，但是看得速度跟不上自己屯书的速度。\n. 更乐意和小哥哥待在一起，但是反而女人缘不错。\n. 像个小孩子但是却不喜欢小孩子。\n. 总是向往美好的故事，常常走不出来。\n\n(未完待续)\n\n====\n今生不悔，来生不为。\n====\n\n如果你想和我交流，可以在下方留言，或者联系 lizhongyue248@163.com。\n\n[INFO]\n====\n如果觉得文章不错或者帮到了您，帮忙点点下面广告呗～谢谢啦～\n====\n","fields":{"slug":"/post/关于/","birthTime":"2018-09-06T21:27:19.000Z","modifiedTime":"2019-08-29","year":2018},"document":{"title":"关于"}},{"content":"= [归档] CentOS7 64位下 MySQL5.7 安装与配置（YUM）\n:page-description: CentOS7 64位下 MySQL5.7 安装与配置（YUM）\n:page-category: 归档\n:page-image: https://img.hacpai.com/bing/20180113.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/02/1546344583722.html\n:page-created: 1517536860000\n:page-modified: 1546346832158\n:toc:\n\n[source, bash]\n____\n安装环境：CentOS7 64位 MINI版，安装MySQL5.7\n____\n\n== 1. 配置YUM源\n\n在MySQL官网中下载YUM源rpm安装包：http://dev.mysql.com/downloads/repo/yum/\n\n下载mysql源安装包\n\n[source,shell]\n----\nshell> wget https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpm\n----\n\n安装mysql源\n\n[source,shell]\n----\nshell> yum localinstall mysql80-community-release-el7-1.noarch.rpm\n----\n\n检查mysql源是否安装成功\n\n[source,shell]\n----\nshell> yum repolist enabled | grep \"mysql.*-community.*\"\n----\n\nimage::https://resources.echocow.cn/image/blog/centos/1.2.png[2]\n\n看到上图所示表示安装成功。\n\n可以修改vim\n/etc/yum.repos.d/mysql-community.repo源，改变默认安装的mysql版本。比如要安装5.6版本，将5.7源的enabled=1改成enabled=0。然后再将5.6源的enabled=0改成enabled=1即可。改完之后的效果如下所示：\n\nimage::https://resources.echocow.cn/image/blog/centos/1.3.png[2]\n\n== 2. 安装MySQL\n\n[source,shell]\n----\nshell> yum install mysql-community-server\n----\n\n== 3. 启动MySQL服务\n\n[source,shell]\n----\nshell> systemctl start mysqld\n----\n\n查看MySQL的启动状态\n\n[source,shell]\n----\nshell> systemctl status mysqld\n● mysqld.service - MySQL Server\n   Loaded: loaded (/usr/lib/systemd/system/mysqld.service; disabled; vendor preset: disabled)\n   Active: active (running) since 五 2016-06-24 04:37:37 CST; 35min ago\n Main PID: 2888 (mysqld)\n   CGroup: /system.slice/mysqld.service\n           └─2888 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid\n\n6月 24 04:37:36 localhost.localdomain systemd[1]: Starting MySQL Server...\n6月 24 04:37:37 localhost.localdomain systemd[1]: Started MySQL Server.\n----\n\n== 4. 开机启动\n\n[source,shell]\n----\nshell> systemctl enable mysqld\nshell> systemctl daemon-reload\n----\n\n== 5. 修改root本地登录密码\n\nmysql安装完成之后，在/var/log/mysqld.log文件中给root生成了一个默认密码。通过下面的方式找到root默认密码，然后登录mysql进行修改：\n\n[source,shell]\n----\nshell> grep 'temporary password' /var/log/mysqld.log\n----\n\nimage::https://resources.echocow.cn/image/blog/centos/1.4.png[4]\n\n[source,shell]\n....\nshell> mysql -uroot -p\nmysql> ALTER USER 'root'@'localhost' IDENTIFIED BY 'MyNewPass4!';\n....\n\n或者\n\n[source,shell]\n....\nmysql> set password for 'root'@'localhost'=password('MyNewPass4!');\n....\n\n注意：mysql5.7默认安装了密码安全检查插件（validate_password），默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于8位。否则会提示ERROR\n1819 (HY000): Your password does not satisfy the current policy\nrequirements错误，如下图所示：\n\nimage::https://resources.echocow.cn/image/blog/centos/1.5.png[5]\n\n通过msyql环境变量可以查看密码策略的相关信息：\n\n[source,shell]\n....\nmysql> show variables like '%password%';\n....\n\nimage::https://resources.echocow.cn/image/blog/centos/1.6.png[6]\n\n[source,shell]\n....\nvalidate_password_policy：密码策略，默认为MEDIUM策略\nvalidate_password_dictionary_file：密码策略文件，策略为STRONG才需要\nvalidate_password_length：密码最少长度\nvalidate_password_mixed_case_count：大小写字符长度，至少1个\nvalidate_password_number_count ：数字至少1个\nvalidate_password_special_char_count：特殊字符至少1个\n....\n\n上述参数是默认策略MEDIUM的密码检查规则。\n\n共有以下几种密码策略：\n\n[width=\"100%\",cols=\"46%,54%\",options=\"header\",]\n|===\n|策略 |检查规则\n|0 or LOW |Length\n\n|1 or MEDIUM |Length; numeric, lowercase/uppercase, and special\ncharacters\n\n|2 or STRONG |Length; numeric, lowercase/uppercase, and special\ncharacters; dictionary file\n|===\n\nMySQL官网密码策略详细说明：http://dev.mysql.com/doc/refman/5.7/en/validate-password-options-variables.html#sysvar_validate_password_policy\n\n== 6. 修改密码策略\n\n在/etc/my.cnf文件添加validate_password_policy配置，指定密码策略\n\n[source,shell]\n....\n# 选择0（LOW），1（MEDIUM），2（STRONG）其中一种，选择2需要提供密码字典文件\nvalidate_password_policy=0\n# 如果不需要密码策略，添加my.cnf文件中添加如下配置禁用即可：\nvalidate_password = off\n# 重新启动mysql服务使配置生效：\nsystemctl restart mysqld\n....\n\n=== 7. 添加远程登录用户\n\n默认只允许root帐户在本地登录，如果要在其它机器上连接mysql，必须修改root允许远程连接，或者添加一个允许远程连接的帐户，为了安全起见，我添加一个新的帐户：\n\n[source,shell]\n....\nmysql> GRANT ALL PRIVILEGES ON *.* TO 'echocow'@'%' IDENTIFIED BY 'Yangxin0917!' WITH GRANT OPTION;\n....\n\n=== 8. 配置默认编码为utf8\n\n修改/etc/my.cnf配置文件，在[mysqld]下添加编码配置，如下所示：\n\n[source,shell]\n....\n[mysqld]\ncharacter_set_server=utf8\ninit_connect='SET NAMES utf8'\n....\n\n重新启动mysql服务，查看数据库默认编码如下所示：\n\nimage::https://resources.echocow.cn/image/blog/centos/1.7.png[6]\n\n____\n默认配置文件路径： - 配置文件：/etc/my.cnf -\n日志文件：/var/log//var/log/mysqld.log -\n服务启动脚本：/usr/lib/systemd/system/mysqld.service -\nsocket文件：/var/run/mysqld/mysqld.pid\n____\n","fields":{"slug":"/articles/2018/02/02/1546344583722.html","birthTime":"2018-02-02T02:01:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[归档] CentOS7 64位下 MySQL5.7 安装与配置（YUM）"}},{"content":"= [归档] 《java语言与面向对象程序设计》清华大学出版社 课后习题 答案\n:page-description: 好快啊，一个学期又没了。四个月的时光，荒废了两个月，珍惜了两个月，学习了很多东西，自己也在慢慢成长，发觉自己又老了半岁了=-=。\n:page-category: 归档\n:page-image: https://img.hacpai.com/bing/20180714.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/01/01/1546344577314.html\n:page-created: 1514799480000\n:page-modified: 1546346915799\n:toc:\n\n好快啊，一个学期又没了。四个月的时光，荒废了两个月，珍惜了两个月，学习了很多东西，自己也在慢慢成长，发觉自己又老了半岁了=-=。image:https://resources.echocow.cn/image/blog/practice/java1.1.jpg[image]\n\n写这个程序的原因，是因为在期末的那段时间，很多同学朋友都来问我这本书上的课后习题怎么做，我也仔细找过这本书到底有没有答案，可是到处找，官网上，文库里等等都找过，只有部分习题有只言片语，官网上的课件也没有习题答案。然后我们又在学习这本书，所以才想到做这么一个程序（如有错误欢迎指出）。下面贴上我们用的教材\n\nimage::https://resources.echocow.cn/image/blog/practice/java1.2.jpg[教材]\n\n不得不说这本书涉及到的知识点很多很全，但是却不是那么易懂，前面几章我学者很是轻松，只要有一点编程基础的基本都能一遍就过，但是后面涉及到了java真正的核心的地方就有点难懂了。所以我建议大家买一本书作为辅助学习资料。\n\n这个程序目前只更新到第十章，书总共十四章，原本期末前就开始弄的，但是后面花时间复习三门数学去了，然后期末完又是一个比赛初赛，上周三比赛完才开始真正的做的。到现在一周半的，零零散散的时间加起来大概两周不到的时间断断续续的完成了。代码大概两千行左右，用来简单的MVC框架（其实也不算）。\n\n自己也遇到很多困难，一个人学习是很苦逼的，自己设计界面，自己添加功能，自己调试所有bug，然后自己测试。里面也有很多题我要花很多时间去想，去设计算法，然后一步一步的实现的。自己能力也有限，而且一直都是自学，有时候也会被一道题卡个几个小时，被一个bug卡个一天，但是终究是完成了。所以可能代码不是最好的，有些代码看看就好，不值得学习。后面几章难度较大，就没有花太多时间去做了。所以只做到了第十章，因为小学期也比较忙。原本想用sql数据库连接登录的，但是想到既然作为学习使用，就没必要那么麻烦，于是自己弄了一个简单登录，固定账号密码。然后对于界面的美化个人要求较高，一遍又一遍的改，然后自己找资料，自学图形界面和IO流，用到了少许的多线程技术。登录界面贴图：\n\nimage:https://resources.echocow.cn/image/blog/practice/java1.3.jpg[login]\n\n自己设计的一个界面，觉得这是我最满意的成果了。这里感谢凡大给我找的图哈哈，配上真的感觉很不错。然后swing组件的界面真的不怎么样，然后自己重写了一下输入框的代码，再添加一个标签用来打开外部URL，个人觉得有难度的地方就是输入框的重写，还有标签的重写以及调用默认浏览器打开外部url。\n\n____\n登录账号：SoftTwo\n\n——————因为是软件工程二班的哈哈\n\n登录密码：BYLZY\n\n—————取自我名字首字母\n____\n\n接下来就是主界面\n\nimage::https://resources.echocow.cn/image/blog/practice/java1.4.jpg[main]\n\n我采用的是swing里面的JTree结构，树形结构个人还是比较喜欢的。而且相比起其他的组件更加美观好用，获取也很简单。\n\nimage::https://resources.echocow.cn/image/blog/practice/java1.5.jpg[tree]\n\n把它加入到了JScrollPane里面，这样即使超出了范围，可以出现滚动条来查看。\n\n不过设置了框体高度900，因为我不是通过获取屏幕大小然后获取相应比例的方式设定其高度宽度的，而是自己固定的，所以如果你电脑的分辨率较小，可能会出现显示不完全的情况，我的分辨率是1920*1080，如果你的不是，比这个小的话，可能会显示不全。后续我更新的时候会补上的。\n\n因为自己比较懒，概念题原本是wps下写的，应该是docx格式，还有些有图片，但我把他复制到了txt下，这时候就出现了一个问题。\n\nwps下部分是Unicode写的，保存时他转化为了ANSI编码，所以导致部分文字或英文有丢失，所以概念题最好在导出的文件夹中找对应的docx来看！\n\n在然后自己写了一个简单的复制，可以把所有文件导出到电脑里面去，\n\n我吧概念题单独封装了一个类，传入参数全部一起使用。\n编程题则是把他们作为了一个方法来调用，下面贴图\n\nimage::https://resources.echocow.cn/image/blog/practice/java1.6.jpg[页面]\n\n界面很丑，但是我不想再花\n太多时间到swing上去，所以就简单做了一下，可以运行，把结果显示在下面的JTextArea里面，可以查看代码同样显示下面。然后后面几个章节，部分程序我则是为他们写了相应的图形界面，当然也很简陋。\n\n然后自己写了两个JDiago，作为提示和运行时的矿体（swing自带的真心太丑了，虽然我做的也不是很漂亮。。。）\n\n____\n注：在第十章输入输入流中，因为本人过懒=-=就没有为每一个拥有图形界面的程序做文件选择对话框，所以需要手动输入，请注意格式和使用英文下的符号输入，造成的使用不当请见谅！\n____\n\n然后自己简单的写了一个HTML网页，来记一个关于界面。也就是最下方的关于按钮。\n\n程序基本就是这样。但是就在昨天，原本我认为做完了，在IDE上可以运行的时候，我打包成jar拿出来，居然运行部了！！\n\n\nimage::https://resources.echocow.cn/image/blog/practice/java1.7.jpg[页面]\n\n\n一直报异常，我查了下对应的错误码，找不到文件！！！也就是说他无法读取jar内部的文件。所以原本计划昨天发布的，一直到了今天。唉。然后昨天想了很久，想到的一个办法就是加入文件选择框，让用户选择文件，但是这样机会暴露出来，个人不太喜欢。不过今天下午还是花时间去实行了的。不过幸运的是，我遇到一个贵州的老乡，他也是软件工程的，所以我叫他学长哈哈，他帮我很好的解决了这个问题！十分感谢！ 知道今天下午六点才算解决这个问题，\n\n然后我又纠结于一个问题，倘若用户那里没有安装jre或者jdk，这个程序是无法打开的，虽然不太可能有这种情况，但是还是要考虑周到，所以我就打算将他们捆绑成一个exe文件，事实上jar转成exe很是简单，但是要捆绑一个jre就很烦。试了很多工具都不行，也不知道为什么exe4j也不行，可能我操作不对，然后没办法，自己写了个简单bat，用cmd调用指定jre运行jar，然后打包成exe，指定下bat运行，但时在打开的一瞬间会有黑框出现，虽然只是一闪即逝，但是很烦人。然后没办法，又写了个vbs（部分电脑不支持，后续会更新修改），同样调用cmd，但是没有那一闪即逝的黑框，但是运行速度慢了很多，只能凑合着用了。可是问题又来了，打包完我一旦修改图标，杀毒软件立马报毒立马删除（WTF？？？？？）\n\n我都快抓狂了，然后试了很多工具，最后终于找到一个比较好用的ResHacker修改了图标和一些简单配置。再把jre打包进去。然后再跑去我朋友那儿用没有jre的电脑试了几次，终于成功了，整个过程有点复杂有点崩溃，但终究是成功了。成功后喜悦完全掩盖了之前所有的汗水和疲惫。\n\n这款小程序也是花了不少心血，目前更新到第十章，以后会不定期更新。这个小程序只是希望能够帮助到大家。里面所有程序并不全都是我写的，部分题目答案来源于网络，如有侵权请联系本人删除，仅供参考学习。另外希望大家不要只是看看代码，多多动手，学习编程动手学是最快的。下面给上百度云链接：\n\n> 链接：http://pan.baidu.com/s/1qXXfGOc 密码：ahqj\n\n\n\n**PS：由于捆绑了jre所以有点大，后面有空我会把没捆绑jre的一起传上来，10M不到。**\n\nPps：欢迎联系本人交流学习哈~~~ 2017.7.9\n\nBY：LZY\n\n'''''\n\n____\n2017.7.15更新\n\n如果你的电脑上没有安装jdk或jre\n\n自带jre包—— 链接：http://pan.baidu.com/s/1qYFLsp2 密码：yukx\n\n如果你的电脑上安装了jdk或jre\n\n无jre包 —— 链接：http://pan.baidu.com/s/1bpcqjj5 密码：qqqe\n____\n\n","fields":{"slug":"/articles/2018/01/01/1546344577314.html","birthTime":"2018-01-01T09:38:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[归档] 《java语言与面向对象程序设计》清华大学出版社 课后习题 答案"}},{"content":"= [归档] 突然想到把自己C语言大作业给拿出来分享给大家~\n:page-description: 最近好多朋友都在学C语言，作为软件工程的学生，是时候来装逼了哈哈哈！所以呢打算把自己以前老师要求做的C语言大作业给拿出来分享给大家。\n:page-category: 归档\n:page-image: https://img.hacpai.com/bing/20181029.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/01/01/1546344573492.html\n:page-created: 1514798760000\n:page-modified: 1546346924994\n:toc:\n\n____\n最近好多朋友都在学C语言，作为软件工程的学生，是时候来装逼了哈哈哈！所以呢打算把自己以前老师要求做的C语言大作业给拿出来分享给大家。当然我学的不深，只是些非常非常非常非常非常基础的小程序（大牛绕道。。。），但是也是弄了一个方便老师检查作业的小程序，用于实现代码查看以及运行测试，也就是靠这个拿了C语言的全班第一虽然也不是很高=-=。所有程序全都来自于《C语言程序设计（第四版）》（谭浩强\n著）\n____\n\nimage::https://resources.echocow.cn/image/blog/practice/c1.1.jpg[C语言程序设计]\n\n虽然不太喜欢这本书但是谁叫我们使用这本书做教材呢？当然我的代码不是最好的，而且还有许多瑕疵以及繁琐，所以请大家见谅！\n\n[source, java]\n----\n目录\n一、第3章——顺序程序设计\n    1、例  题\n        a、例1 (3.1)华氏度转化为摄氏度\n        b、例2 (3.3)大写字母转化为小写字母（输入错误可重新输入）\n        c、例3 (3.4)求三角形面积（系统检查是否为三角形，输入错误可重新输入），\n    2、作业题\n        a、P82 1 计算n年后我国国民生产总值与现在相比增长多少百分比\n        b、P83 3 计算购房贷款还清时间\n        c、P84 6 China编译成密码\n        d、P84 7 输入圆半径、高，求周长，面积，球表面积，球体积，圆柱体积。（自动保留两位小数）\n\n二、第4章——选择结构程序设计\n    1、例  题\n        a、例1 （4.3）输入3个数，从小到大排列\n        b、例2 （4.6）按照考试等级输出百分制分数段（switch）\n        c、例3 （4.8）判断是否为闰年\n    2、作业题\n        a、P112  4 输入三个整数，输出其中最大的值\n        b、P112  5 输入小于1000的正数（输入错误可重新输入），输出他的平方根的整数部分\n        c、P113  8 输入一百分制成绩，输出对应等第\n        d、P113 11输入4个整数，要求按从小到大的顺序输出\n\n三、第5章——循环结构程序设计\n    1、例  题\n        a、例1 （5. 4）慈善募捐达到10万元时，统计此时巨款人数\n        b、例2 （5. 8）Fibonacci数列（兔子繁殖）\n        c、例3 （5. 9）输入一个大于3的整数，判断是否为素数\n        d、例4 （5.10）求100—200间的全部素数\n    2、作业题\n        a、P140  5 Sn=a+aa+aaa+…+aa…a的值\n        b、P140  6 1！+2！+…+20！的和\n        c、P140  8 输出所有水仙花数\n        d、P141 16 输出由*组成的菱形\n\n四、第6章——利用数组处理批量数据\n    1、例  题\n        a、例1 （6.1）对十个数组元素依次赋值为0,1,2,3,4,5,6,7,8,9并按逆序输出\n        b、例2 （6.3）输入10个地区的面积，把它们从小到大排列\n        c、例3 （6.8）输入一行字符，统计其中有多少单词，单词之间用空格分开\n    2、作业题\n        a、P168  3 输入一个3×3的整形矩阵，求对角线元素之和（无初值）\n        b、P168  4 已排序好的数组，插入一个数按原来规律排序\n        c、P168  6 杨辉三角\n        d、P168 10 输入三行文字，限定80字符，统计其中英文大小写、数字、空格及其  他字符个数。\n        e、P168 11 输出由*组成的平行四边形\n\n五、第7章——用函数实现模块化程序管理\n    1、例  题.\n        a、例1 （1. 3）比较两个数的大小（函数）\n        b、例2 （7. 8）汉诺塔\n        c、例3 （7. 9）输入10个数，输出最大者及他的位置\n        d、例4 （7.17）输出1到5的阶乘\n        e、例5 （7.19）给定b的值，输入a和m，求出a*b和a的m次方（调用外部）\n        f、例6 （7.20）输入一串字符串及一个字符，输出的字符串中没有输入的字符\n    2、作业题\n        a、P218  1 输入两个数，求最大公约数和最小公倍数\n        b、P218  3 判断素数\n        c、P218  8 请输入一个4位数字，输出的4个数字每两个之间空一个空格\n        d、P218 10 用“起泡法”对输入的10个字符按从小到大排列\n        e、P219 13 用递归法求n阶勒让德多项式的值\n        f、P219 16 输入一个十进制数，输出相应的二进制数\n\n六、第8章——指针的利用\n    1、例  题\n        a、例1 （8.1）通过指针变量访问整型变量\n        b、例2 （8.9）利用指针交换数组的位置\n    2、作业题\n        a、实验题 n个人围成的圈子，数到3的人退出，输出最后一个人的号数\n        b、P291 2 输入3个字符串，按从小到大的顺序输出\n\n七、其他程序设计\n    1、实验报告题\n        a、输入正数a，b，计算a2+b2并判断，输出不同的值。\n        b、输入三角形的三边的值，判断三角形的类型，并输出其面积。\n        c、输出3025类型四位数\n        d、输入4乘4矩阵，求对角线以下元素\n        e、输入一组正整数,统计奇数和偶数\n        f、输入十个整数，删除其中的负数后输出\n    2、课外练习题\n        a、输出爱心图案\n        b、关机程序\n        c、猜拳游戏\n----\n\nimage::https://resources.echocow.cn/image/blog/practice/c1.2.jpg[界面一]\n\nimage::https://resources.echocow.cn/image/blog/practice/c1.3.jpg[界面二]\n\nimage::https://resources.echocow.cn/image/blog/practice/c1.4.jpg[界面三]\n\nimage::https://resources.echocow.cn/image/blog/practice/c1.5.jpg[界面四]\n\nimage::https://resources.echocow.cn/image/blog/practice/c1.6.jpg[界面五]\n\nimage::https://resources.echocow.cn/image/blog/practice/c1.7.jpg[界面六]\n\nimage::https://resources.echocow.cn/image/blog/practice/c1.8.jpg[界面七]\n\n所用的是百度云分享。链接：http://pan.baidu.com/s/1eRYbIQA 密码：1shh\n。另外附上目录，有需要的朋友自行下载。\n\n[TIP]\nPS：如果有哪位看得起小弟用到了小弟的框架。请说明出处，请尊重小弟的劳动成果，谢谢！在此说明，作业检查程序仅限于windows下产品。\n\nimage::https://resources.echocow.cn/image/blog/practice/c1.9.png[说明1]\n\nimage::https://resources.echocow.cn/image/blog/practice/c1.10.png[说明2]\n","fields":{"slug":"/articles/2018/01/01/1546344573492.html","birthTime":"2018-01-01T09:26:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[归档] 突然想到把自己C语言大作业给拿出来分享给大家~"}},{"content":"= [归档] CentOS7 上安装 JDK1.8\n:page-description: CentOS7 上安装 JDK1.8\n:page-category: 归档\n:page-image: https://img.hacpai.com/bing/20190221.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/02/1546344578809.html\n:page-created: 1517530080000\n:page-modified: 1546346890931\n:toc:\n\n[arabic]\n. 通过 SecureCRT 连接到阿里云 CentOS7 服务器；\n. 进入到目录 /usr/local/ 中：\n\n[source,bash]\n....\ncd /usr/local/\n....\n\n[arabic, start=3]\n. 创建目录 tools：\n\n[source,bash]\n....\n mkdir -p tools\n....\n\n[arabic, start=4]\n. 进入到目录 /usr/local/tools 中：\n\n[source,bash]\n....\n cd tools/\n....\n\n[arabic, start=5]\n. 下载 jdk-8u91-linux-x64.tar.gz：\n* wget –no-check-certificate –no-cookies –header ``Cookie:\noraclelicense=accept-securebackup-cookie''\nhttp://download.oracle.com/otn-pub/java/jdk/7u71-b14/jdk-7u71-linux-x64.rpm\n* http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html[官网地址]，找到需要的，然后加上头既可\n. 加压缩 jdk-8u91-linux-x64.tar.gz 文件：\n\n[source,bash]\n....\n tar -zxvf jdk-8u91-linux-x64.tar.gz\n....\n\n[arabic, start=7]\n. 返回到上一级并创建 /usr/local/jdk 目录： ```\n\n[source,bash]\n....\ncd .. mkdir -p jdk\n....\n\n[arabic, start=8]\n. 进入到 tools 目录后将 jdk1.8.0_91 移动到 jdk 目录中：\n\n[source,bash]\n....\ncd ../tools/ mv jdk1.8.0_91/ ../jdk/\n\n....\n[arabic, start=9]\n. 打开 /etc/ 目录下的 profile 文件：\n\n[source,bash]\n....\nvi /etc/profile\n....\n\n[arabic, start=10]\n. 将如下代码追加到 profile 文件末尾：\n\n[source,bash]\n....\n\n# idea - jdk8 settings start 2016-05-01\n\nJAVA_HOME=/usr/local/jdk/jdk1.8.0_91\nJRE_HOME=$JAVA_HOME/jre\nPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin\nCLASSPATH=:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib/dt.jar\nexport JAVA_HOME JRE_HOME PATH CLASSPATH\n\n# idea - jdk8 settings end - 2016-05-01\n....\n\n[arabic, start=11]\n. 按 Esc 键、输入 wq! 回车，保持并退出。即可启用新的配置：`source /etc/profile`\n\n[arabic, start=12]\n. 输入 java -version 查看 JDK 的版本：\n\n[source,bash]\n....\n [root@iZ94hws2fzlZ jdk1.8.0_91]# java -version\n java version \"1.8.0_91\"\n Java(TM) SE Runtime Environment (build 1.8.0_91-b14)\n Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode)\n....\n","fields":{"slug":"/articles/2018/02/02/1546344578809.html","birthTime":"2018-02-02T00:08:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[归档] CentOS7 上安装 JDK1.8"}},{"content":"= [归档] 02-03 hibernate 5.2 以后  criteria 过时 的 替换\n:page-description: 今天在学习hibernate框架时，使用的5.2.13稳定版本，而在 hibernate 5.2 版本以后，对于 Criteria 查询重点放在了 JPACriteriaQuery API 上。\n:page-category: 归档\n:page-image: https://img.hacpai.com/bing/20180307.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/09/1546344579701.html\n:page-created: 1518141420000\n:page-modified: 1546346778472\n:toc:\n\n今天在学习hibernate框架时，使用的5.2.13稳定版本，而在 hibernate 5.2\n版本以后，对于 Criteria 查询重点放在了 JPACriteriaQuery API 上，如图\n\nimage::https://resources.echocow.cn/image/blog/ssh/hibernate1.1.png[pic]\n\n所以造成的结果是\n\nimage::https://resources.echocow.cn/image/blog/ssh/hibernate1.2.png[res]\n\nimage::https://resources.echocow.cn/image/blog/ssh/hibernate1.3.png[pic]\n\n方法的过时，同时其下对应的criteria查询的许多方法都属于过时的状态。怀着一颗与时俱进的心，我在网上百般寻找答案，但是百度给出的答案寥寥无几，有限的仅有简单的查询，后来去Google搜素，找寻多个网站以及翻官方文档和API，终于集合了解决方案用以应对criteria过时的问题。下面看看官方文档给出的API\n\nimage::https://resources.echocow.cn/image/blog/ssh/hibernate1.4.png[pic]\n\nimage::https://resources.echocow.cn/image/blog/ssh/hibernate1.5.png[pic]\n\n官方给出的解决方案就是JPA 的\ncriteria，作为一名合格的爱学习的大学生，我当然不会一个一个的翻阅这些英文文档。不过呢，我还是先了解了下criteria查询的好处。\n\n* hibernate 自创的，无查询语句，面向对象查询。\n* 全都通过调用方法查询\n* 注意，很多方法在5.2版本的hibernate中已经弃用，官方API如下\n* *HQL相比，完全面向对象，不需要任何SQL基础 *\n\n当然，我是比较喜欢这种设置参数就可操作表的查询的，所以对其一些基本的操作在hibernate5.2版本以后进行了学习。由于百度收录的关于hibernate\n5.2更新版本后的\ncriteria查询资料极其稀少，所以我就打算记下来。但是由于博客正在学习与建设中，只有暂时存放于此处以便取用。在这之前，做必要的准备，例如hibernate的基本配置、导包等都不再赘述，给出数据库表结构与数据如下：\n\nimage::https://resources.echocow.cn/image/blog/ssh/hibernate1.6.png[pojo]\n\npojo类如下\n\nimage::https://resources.echocow.cn/image/blog/ssh/hibernate1.7.png[aaaa]\n\n其中由于hibernate硬性规定使用id，而我的pid使用的是string类型，所以我建立了一个代理id，用来表的业务列中,没有某业务列符合但是却,必须有,并创建一个没有业务意义的列作为主键。\n\n然后，建立一个获取session对象的工具类。\n\nimage::https://resources.echocow.cn/image/blog/ssh/hibernate1.8.png[last]\n\n== 一、基本查询\n\n曾经的方法\n\nimage::https://resources.echocow.cn/image/blog/ssh/hibernate1.9.png[last]\n\n但是同样，createCriteria已经属于过时的方法，Hibernate5.2中已不推荐使用Criteria，而是使用基于JPA规范的CriteriaQuery查询。通过百度以及API，采用新的第一种方法如下：\n\nimage::https://resources.echocow.cn/image/blog/ssh/hibernate1.10.png[last]\n\n[arabic]\n. 创建一个CriteriaBuilder +\n. 获取 CriteriaQuery +\n. 指定实体 criteria.from(Product.class); +\n. 执行查询 session.createQuery 获取结果集 .getResultList()\n\n简化后代码如下：\n\nimage::https://resources.echocow.cn/image/blog/ssh/hibernate1.11.png[last]\n\n同时，官网给出另外一种方法，*选择根实体，示例如下图*\n\nimage::https://resources.echocow.cn/image/blog/ssh/hibernate1.12.png[last]\n\n*根据官网给出的示例，书写代码如下：*\n\nimage::https://resources.echocow.cn/image/blog/ssh/hibernate1.13.png[last]\n\n不获取根实体的情况，分析如下： 1. 创建一个CriteriaBuilder +\n2. 获取 CriteriaQuery +\n3. 选择根实体 Root +\n4. 执行查询 session.createQuery +\n5. 获取结果集 .getResultList()\n\n*查询指定字段，通过CriteriaQuery的select具体设置*\n\nimage::https://resources.echocow.cn/image/blog/ssh/hibernate1.14.png[last]\n\n== 二、条件查询\n\n对于原方法，条件查询如下：\n\nimage::https://resources.echocow.cn/image/blog/ssh/hibernate1.15.png[last]\n\n由于方法的**过时**，采用5.2新定义的方法，此时，必须为其定义根实体\n\nimage::https://resources.echocow.cn/image/blog/ssh/hibernate1.16.png[last]\n\n此处需要使用CriteriaQuery的where方法，其中参数为Predicate类型，所以我们用CriteriaBuilder的方法来进行查询，包括equal、gt等，对应如下：\n\n[cols=\",\",options=\"header\",]\n|===\n|关系 |方法\n|大于（>） |gt\n|大于等于（>=） |ge\n|小于（<） |lt\n|小于等于（<=） |le\n|等于（==） |eq\n|不等于（！=） |ne\n|in |in\n|between and |between\n|like |lisk\n|not null |isNotNull\n|is not null |isNull\n|or |or\n|and |and\n|===\n\n不过在处理OR或者AND是，是一层又一层的嵌套。\n\nimage::https://resources.echocow.cn/image/blog/ssh/hibernate1.17.png[last]\n\n此时即完成了条件查询\n\n根据条件查询指定字段。将以上两种方式结合即可。\n\nimage::https://resources.echocow.cn/image/blog/ssh/hibernate1.18.png[last]\n\n== 三、分页查询\n\nhibernate 5.2以前\n\nimage::https://resources.echocow.cn/image/blog/ssh/hibernate1.19.png[last]\n\n现在5.2修改后，找遍多种途径都没寻求到方法，不得已，我使用了其他的方法，采用\nJPA 标准下的persistence 包下的 TypedQuery 来进行分页。\n\nimage::https://resources.echocow.cn/image/blog/ssh/hibernate1.20.png[last]\n\n如此，hibernate 5.2的分页查询就实现了。当然此方法由文档所给出的如下 >\nThis is useful when the aim is to create dynamic, failure-safe queries.\nIn contrast to ``hard-coded'', ``string-based'' JQL or HQL queries, JPA\nCriteria reduces run-time failures because the compiler dynamically\nchecks for query errors.\n\n____\n翻译：当创建动态的、故障安全的查询时，这一点非常有用。相对于``硬编码''、“基于字符串的“JQL\n或HQL查询，JPA标准降低了运行时失败，因为编译器动态检查查询错误。\n____\n\n== 四、分页查询之查询总条数\n\nimage::https://resources.echocow.cn/image/blog/ssh/hibernate1.21.png[last]\n\n同样，由于使用JPA，我们不得不更换方式。这个时候就需要使用到mysql的聚合函数来处理数据，在百度查询无果后，去查询官方API文档，他给出了聚合函数使用如下：\n\nimage::https://resources.echocow.cn/image/blog/ssh/hibernate1.22.png[last]\n\n研究半天终于使用其聚合函数获取到了，后面的聚合函数都可以使用同样的方式\n\nimage::https://resources.echocow.cn/image/blog/ssh/hibernate1.23.png[last]\n\nimage::https://resources.echocow.cn/image/blog/ssh/hibernate1.24.png[last]\n\n如此即成功使用其聚合函数获取到了其总条数。\n\n致此，简单的查询就这些了。差不多如此，花了不少时间终于全部弄懂了。相比起HQL，在自己研究的下，还是Criteria\n查询较为难，hibernate这个框架感觉相比于mybatis更加上升了一个高度，如果说jdbc底层，连接池上升一层，mybatis再升一层，那么hibernate相比于mybatis应该上升了两层吧。\n\n差不多就这些了，晚安各位~月亮\n\n再吐槽一遍QQ空间的编辑器=-=要不是因为我博客还没建好，我也不会用这个=-=希望下次不用了。上传图片截屏排版键值要我老命。。。。唯一好点的就是挺喜欢荧光字体。\n","fields":{"slug":"/articles/2018/02/09/1546344579701.html","birthTime":"2018-02-09T01:57:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[归档] 02-03 hibernate 5.2 以后  criteria 过时 的 替换"}},{"content":"= [rhce] 1 配置 SeLinux 为 enforcing\n:page-description: 配置 SeLinux 为 enforcing\n:page-category: rhce\n:page-image: https://img.hacpai.com/bing/20180401.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/14/1546344581049.html\n:page-created: 1518606660000\n:page-modified: 1546346712257\n:toc:\n\n修改配置文件\n\n[source,bash]\n----\nvim /etc/sysconfig/selinux\n----\n\nimage:https://resources.echocow.cn/image/rhce/1.png[rhce]\n\n修改为题目所需要的即可\n\n退出后，执行\n\n[source,bash]\n----\nsetenforce  1             //使强制模式立即生效\n----\n","fields":{"slug":"/articles/2018/02/14/1546344581049.html","birthTime":"2018-02-14T11:11:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[rhce] 1 配置 SeLinux 为 enforcing"}},{"content":"= [rhce] 2 配置防火墙对 SSH 的限制\n:page-description: 配置防火墙对 SSH 的限制\n:page-category: rhce\n:page-image: https://img.hacpai.com/bing/20180104.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/15/1546344574537.html\n:page-created: 1518646560000\n:page-modified: 1546346712259\n:toc:\n\n____\n在 serverx和 desktopx上设置防火墙，对 SSH实现访问限制： - 允许\nexample.com域的客户对 serverx和 desktopx进行 ssh访问。 - 禁止\nmy133t.org域的客户对 serverx和 desktopx进行 ssh访问。 - 备注：\nmy133t.org是在172．17．10℃/24网络。 - 根据考试实际提供的网段配置\n____\n\n== 操作\n\n—>防火墙会检查的部分\n\n（1）IP来源 （信任域、非信任域）\n\n（2）访问的对象 （服务ssh/http、端口）\n\n（3）访问的协议 （TCP/UDP）\n\n（4）目标IP （防火墙设备，例如路由器NAT）\n\n[arabic]\n. 关闭与屏蔽 iptables 以及其他防火墙\n\n[source,bash]\n....\nsystemctl  mask  ebtables.service\nsystemctl  mask  iptables\nsystemctl  mask  ip6tables\n....\n\n[arabic, start=2]\n. 开启 firewalld 防火墙以及开机启动\n\n[source,bash]\n....\nsystemctl  enable  firewalld\nsystemctl  start  firewalld\n....\n\n[arabic, start=3]\n. 配置防火墙富规则\n\n[source,bash]\n....\nmandb                   //更新 man\nman  -k  rich              //查询防火墙副规则的 man 路径\nman  firewalld.richlanguage     //防火墙富规则查询\n....\n\nimage::https://resources.echocow.cn/image/rhce/2.1.png[规则查看]\n\nimage::https://resources.echocow.cn/image/rhce/2.2.png[规则]\n\n[width=\"100%\",cols=\"41%,33%,26%\",options=\"header\",]\n|===\n|名称 |含义 |值\n|rule |类型 |family=``ipv4 | ipv6''\n\n|source |来源/源地址 |source address=``address[/mask]''\n[invert=``True'']\n\n|destination |目的地址 |destination address=``address[/mask]''\ninvert=``True''\n\n|service |服务 |service name=``service name''\n\n|port |端口 |port port=``port value'' protocol=``tcp | udb''\n\n|protocol |协议 |protocol value=``protocol value''\n\n|ICMP-Block |报文块 |icmp-block name=``icmptype name''\n\n|Masquerade |伪装 |masquerade\n\n|Forward-Port |转发 |forward-port port=``port value''\nprotocol=``tcp|udp'' to-port=``port value'' to-addr=``address''\n\n|Log |日志 |log [prefix=``prefix text''] [level=``log level''] [limit\nvalue=``rate/duration'']\n\n|Action |审计 |\n\n|action |行为 |accept, reject or drop\n|===\n\n配置具体规则\n\n[source,bash]\n....\nfirewall-cmd --add-rich-rule=\"rule family=ipv4 source address=172.25.47.10/24 service name=ssh reject\" --permanent\n....\n\n[source,bash]\n....\nfirewall-cmd --reload\n....\n\nimage:https://resources.echocow.cn/image/rhce/2.3.png[image]\n","fields":{"slug":"/articles/2018/02/15/1546344574537.html","birthTime":"2018-02-14T22:16:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[rhce] 2 配置防火墙对 SSH 的限制"}},{"content":"= [rhce] 5 自定义用户环境\n:page-description: 自定义用户环境\n:page-category: rhce\n:page-image: https://img.hacpai.com/bing/20180309.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/17/1546344577581.html\n:page-created: 1518804720000\n:page-modified: 1546346614697\n:toc:\n\n____\n在系统server0和desktop0上创建自定义命令为qstat\n,此自定义命令将执行以下命令： - /bin/ps -Ao pid,tt,user,fname,rsz -\n此命令对系统中的所有用户有效。\n____\n\n== 操作\n\n默认使用bash shell，所以就修改它的配置文件。配置文件一般存在于： 1.\n/etc/bashrc 全局生效 2. /home/用户家目录/.bashrc当前用户生效。\n\n这里要求对所有用户生效，明显是修改前者。\n\n*vim /etc/bashrc* 增加如下配置至文件末尾\n\n....\nalias qstat='/bin/ps -Ao pid,tt,user,fname,rsz'\n....\n\n*source /etc/bashrc* 重新加载一下，使得当前bash生效。\n\n== 测试自定义的命令\n\n`qstat`\n\nimage:https://resources.echocow.cn/image/rhce/5.1.png[image]\n\n","fields":{"slug":"/articles/2018/02/17/1546344577581.html","birthTime":"2018-02-16T18:12:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[rhce] 5 自定义用户环境"}},{"content":"= [rhce] 6 配置本地邮件服务\n:page-description: 配置本地邮件服务\n:page-category: rhce\n:page-image: https://img.hacpai.com/bing/20181025.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/17/1546344576024.html\n:page-created: 1518862620000\n:page-modified: 1546346600605\n:toc:\n\n____\n在系统server0和desktop0上配置邮件服务，满足以下要求： -\n这些系统不接收外部发送来的邮件 -\n这些系统上本地发送的任何邮件都会自动路由到 classroom.example.com -\n从这些系统上发送的邮件都显示来自 example.com -\n你可以通过发送邮件到本地用户student来测试你的配置，\n\n* classroom.example.com已经配置好。把此用户的邮件转到下列URL\nhttp://classroom.example.com/cgi-bin/recevied_mail\n____\n\n____\n*使用 postfix\n服务完成上述题目。一般都默认安装了这个服务，并处于默认开机启动状态。但是建议还是检查一下。\n*\n____\n\nserver47 和 desktop47 配置一致，仅用 server47 做演示。\n\n== 方法一：直接修改配置文件\n\n*/etc/postfix/main.cf* 主要修改下面几处\n\n....\ninet_interfaces = loopback-only #监听本地回环接口\nmyorigin = example.com #设置来源域名\nrelayhost = [classroom.example.com] #中转的服务器，没有MX记录的用中括号包起来\nmydestination =  #不接受任何邮件\nmynetworks = 127.0.0.0/8, [::1]/128 #本地网络\nlocal_transport = error: local delivery disabled #其实是非必须的\n....\n\n`systemctl restart postfix`重启邮件服务\n\n== 方法二：使用 postconf 修改\n\n这是专门用来查看 postfix 配置和修改 postfix\n配置的工具。个人也是推荐这种做法。\n\n....\n[root@server0 ~]# postconf -e 'inet_interfaces=loopback-only'\n[root@server0 ~]# postconf -e 'myorigin=example.com'\n[root@server0 ~]# postconf -e 'relayhost=[classroom.example.com]'\n[root@server0 ~]# postconf -e 'mydestination='\n[root@server0 ~]# postconf -e 'mynetworks=127.0.0.0/8, [::1]/128'\n[root@server0 ~]# postconf -e 'local_transport=error: local delivery disabled'\n[root@server0 ~]# systemctl restart postfix\n....\n\n测试\n\n....\n[root@server0 ~]# mail -s 'fuxk' student@classroom.example.com\nerwerwr\n.\nEOT\n[root@server0 ~]# curl http://classroom.example.com/cgi-bin/recevied_mail\n\nFrom root@example.com  Tue Jan  3 14:43:46 2017<br>Return-Path: <root@example.com><br>X-Original-To: student@classroom.example.com<br>Delivered-To: student@classroom.example.com<br>Received: from server0.example.com (server0.example.com [172.25.0.11])<br>&nbsp;&nbsp;&nbsp;&nbspby classroom.example.com (Postfix) with ESMTP id 1BB802ACC19<br>&nbsp;&nbsp;&nbsp;&nbspfor <student@classroom.example.com>; Tue,  3 Jan 2017 14:43:46 +0800 (CST)<br>Received: by server0.example.com (Postfix, from userid 0)<br>&nbsp;&nbsp;&nbsp;&nbspid D05FEEAEEA; Tue,  3 Jan 2017 14:43:44 +0800 (CST)<br>Date: Tue, 03 Jan 2017 14:43:44 +0800<br>To: student@classroom.example.com<br>Subject: fuxk<br>User-Agent: Heirloom mailx 12.5 7/5/10<br>MIME-Version: 1.0<br>Content-Type: text/plain; charset=us-ascii<br>Content-Transfer-Encoding: 7bit<br>Message-Id: <20170103064344.D05FEEAEEA@server0.example.com><br>From: root@example.com (root)<br><br>erwerwr<br><br>\n....\n\n== 练习题\n\n____\n在系统 serverX 和 desktopX 上配置邮件服务，满足以下要求：\n\n这些系统不接收外部发送来的邮件\n\n这些系统上本地发送的任何邮件都会自动路由到 smtpX.example.com\n\n从这些系统上发送的邮件都显示来自 desktopX.example.com\n\n你可以通过发送邮件到本地用户 student 来测试你配置，desktop47.example.com\n已配置好\n\n注意：模拟环境只需配置 serverX 即可，但考试时需要同配置 serverX 和\ndesktopX\n____\n\n*练习时务必在 serverX 和 desktopX 上先启动练习环境*\n\n....\nlab smtp-nullclient setup\n....\n\n使用 postconf 修改\n\n....\npostconf -e \"inet_interfaces=loopback-only\" 监听本地回环接口\npostconf -e \"relayhost=[smtp47.example.com]\" 因为需要自动路由到 smtpX.example.com\npostconf -e \"myorigin=desktop47.example.com\" 需要系统上发送的邮件都显示来自 desktopX.example.com \npostconf -e \"mydestination=\" 不接受任何邮件\npostconf -e \"mynetworks=127.0.0.0/8 [::1]/128\" 设置本地网络\npostconf -e \"local_transport=error:local delivery disable\" 阻止本地空客户端所有邮件在本地转发到/var/spool邮箱中\n....\n\nsystemctl restart postfix 重启服务\n\n测试\n\n发送一封主题为 server47 null client 的邮件，内容为 null client test\n\n....\nmail -s \"server47 null client\" student@desktop47.example.com\nnull client test.\n\nEOT\n....\n\n使用用户名 student 和密码 student 登录\n\nimage:https://resources.echocow.cn/image/rhce/6.1.png[image]\n\nimage:https://resources.echocow.cn/image/rhce/6.2.png[image]\n\nimage:https://resources.echocow.cn/image/rhce/6.3.png[image]\n\nimage:https://resources.echocow.cn/image/rhce/6.4.png[image]\n\n`lab smtp-nullclient grade` 测试\n\nimage:https://resources.echocow.cn/image/rhce/6.5.png[image]\n\n","fields":{"slug":"/articles/2018/02/17/1546344576024.html","birthTime":"2018-02-17T10:17:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[rhce] 6 配置本地邮件服务"}},{"content":"= [rhce] 7 配置端口转发\n:page-description: rhce 7 配置端口转发\n:page-category: rhce\n:page-image: https://img.hacpai.com/bing/20190118.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/19/1546344575180.html\n:page-created: 1518985380000\n:page-modified: 1546346587347\n:toc:\n\n____\n在 serverX 上配置端口转发，要求如下：\n\n[arabic]\n. 在 172.25.X.0/24 网络中的系统，访问 serverX 的本地端口 5423\n将被转发到端口 80\n. 此设置必须永久有效。\n____\n\n....\nfirewall-cmd --permanent --add-rich-rule 'rule family=ipv4 source address=172.25.0.0/24 forward-port port=5423 protocol=tcp to-port=80' --permanent\n\nfirewall-cmd --permanent --add-rich-rule 'rule family=ipv4 source address=172.25.0.0/24 forward-port port=5423 protocol=udp to-port=80' --permanent\n\nfirewall-cmd --reload\n....\n\nimage::https://resources.echocow.cn/image/rhce/7.png[哈哈哈哈]\n\n","fields":{"slug":"/articles/2018/02/19/1546344575180.html","birthTime":"2018-02-18T20:23:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[rhce] 7 配置端口转发"}},{"content":"= [rhce] 8 通过 SMB 共享目录\n:page-description: rhce 8 通过 SMB 共享目录\n:page-category: rhce\n:page-image: https://img.hacpai.com/bing/20181227.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/19/1546344574210.html\n:page-created: 1519042500000\n:page-modified: 1546346570847\n:toc:\n\n____\n在 serverX 上配置 SMB 服务 - 您的 SMB 服务器必须是 STAFF\n工作组的一个成员 - 共享 /common 目录，共享名必须为 common - 只有\nexample.com 域内的客户端可以访问 common 共享 - common 必须是可以浏览的 -\n用户 rob，samba 密码为 redhat，只读权限访问 common 共享 - 用户\nbrian，samba 密码为 redhat，读写权限访问 common 共享\n____\n\n____\n备注：考试时，用户名和密码根据题目实际情况进行设定，有的时候题目简单一点，测试用户早已建立，有的时候题目较难一点，用户和密码都必须自己设定。\n____\n\n== 操作\n\n安装 samba 和 samba-client\n\n....\nyum install samba samba-client\n....\n\n通过 camba-client 查看分享出来的目录\n\n....\nsmbclient -L server47 -U brian\n....\n\nimage::https://resources.echocow.cn/image/rhce/8.1.png[查看]\n\n查看是否存在用户 rob 和 brain\n\n....\nid rob\nid brian\n....\n\n倘若不存在，创建用户，由于只仅限于 samba\n的系统用户，所以必须锁定密码并防止直接用户登录和 ssh 远程登录。\n\n....\nuseradd -s /sbin/nologin rob\nuseradd -s /sbin/nologin brian\n....\n\n再次查看同时记录下 uid\n\n....\nid rob\nid brian\n....\n\nimage::https://resources.echocow.cn/image/rhce/8.2.png[查看]\n\nimage::https://resources.echocow.cn/image/rhce/8.3.png[查看]\n\n因为用户作为 samba 用户，所以为 samba 用户库添加 rob 和brain\n冰壶并设置密码。\n\n....\nsmbpasswd -a rob\nsmbpasswd -a brian\n....\n\n创建共享挂载目录 /common**（注意根据题目要求）**\n\n....\nmkdir /common\n....\n\n将目录共享文件添加至 SELinux 策略中，也就是为他们打标签\n\n....\nsemanage fcontext -a -t samba_share_t '/common(/.*)?'\n....\n\n使其目录立刻采用 SELinux 规则，F 代表强制重置文件环境，R\n代表递归的变更文件和目录的文件标签，v 代表显示变更情况。\n\n....\nrestorecon -RFv /common/\n....\n\n为 samba 用户设置 ACL 权限\n\nrob 只能读，*但目录下的文件没有被执行的权限，所以为\nX*，代表目录可以被访问。所以为 r-X brian 可读可写，所以为 rwx\n\n....\nsetfacl -m u:rob:r-X /common/setfacl -m u:brian:rwx /common/\n....\n\n修改配置文件，按照题目要求，将工作组设置为 STAFF\n\n....\nvim /etc/samba/smb.conf\n\n\nworkgroup = STAFF\nsecurity = user\n....\n\nimage::https://resources.echocow.cn/image/rhce/8.4.png[查看]\n\nimage::https://resources.echocow.cn/image/rhce/8.5.png[查看]\n\n配置共享目录\n\n....\n[common]\npath = /common                             //共享目录\nwrite list = brian                              //可写的用户列表，默认 read-only\nbrowseable = yes                           //是否可浏览\nhosts allow = 172.25.47.0/24         //允许访问的域，必须使用 IP 地址\n....\n\nimage::https://resources.echocow.cn/image/rhce/8.6.png[查看]\n\n开启服务以及设置服务开机启动、开启防火墙\n\n....\nsystemctl enable smb.service  nmb.service\nsystemctl start smb.service  nmb.service\nfirewall-cmd --permanent --add-service=samba\nfirewall-cmd --reload\n....\n\n服务器端 SMB 配置完成\n\n","fields":{"slug":"/articles/2018/02/19/1546344574210.html","birthTime":"2018-02-19T12:15:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[rhce] 8 通过 SMB 共享目录"}},{"content":"= [rhce] 10 配置 NFS 服务\n:page-description: rhce 10 配置 NFS 服务\n:page-category: rhce\n:page-image: https://img.hacpai.com/bing/20180304.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/20/1546344584166.html\n:page-created: 1519086900000\n:page-modified: 1546346546670\n:toc:\n\n____\n在 serverX 配置 NFS 服务，要求如下： - 以只读的形式共享目录 /public\n同时只能被 example.com 域中的系统访问。 - 以读写的形式共享目录\n/protected 同时只能被 example.com 域中的系统访问。 - 访问 /protected\n需要通过 Kerberos 安全加密，您可以使用下面提供的密钥：\nhttp://classroom.example.com/pub/keytabs/serverX.keytab - 目录\n/protected 应该包含名为 project 拥有人为 ldapuserX 的子目录 - 用户\nldapuserX 能以读写形式访问/ protected/project\n____\n\n== 操作\n\n创建目录\n\n....\nmkdir /publicmkdir -p /protected/project\n....\n\n修改目录权限，protected 需要有读写权限，project 需要修改拥有人身份\n\n....\nchmod o+w /protected/ -R\nchown ldapuser0 /protected/project/\n....\n\n打标签\n\n....\nsemanage fcontext -a -t public_content_t '/protected(/.*)?'\nrestorecon -RvF /protected/\n....\n\n下载kerberos证书到 /etc/krb5.keytab\n\n....\nwget -O /etc/krb5.keytab http://classroom.example.com/pub/keytabs/server0.keytab\n....\n\n`vim /etc/exports` 修改文件，增加共享信息。\n\n....\n/public 172.25.0.0/24(ro) #要共享的目录 允许访问的ip段 参数\n/protected 172.25.0.0/24(rw,sec=krb5p)\n....\n\n启动NFS相关服务，并设置开机启动 nfs-server 和 nfs-secure-server\n\n....\nsystemctl restart nfs-server nfs-secure-server  \nsystemctl enable nfs-server nfs-secure-server\n....\n\n如果没有下载kerberos证书，或者下载不正确，是不能正常启动nfs-secure-server的\n\n配置防火墙 允许相关服务 nfs、rpc-bind和mountd\n\n....\nfirewall-cmd --permanent --add-service=nfs\nfirewall-cmd --permanent --add-service=rpc-bind\nfirewall-cmd --permanent --add-service=mountd\nfirewall-cmd --reload\n....\n\n配置到这里就完成了。如果想要查看输出的共享信息，可以使用\n`exportfs -v`查看\n\n....\n[root@server0 ~]# exportfs -v/public         172.25.0.0/24(ro,wdelay,root_squash,no_subtree_check,sec=sys,ro,secure,root_squash,no_all_squash)/protected      172.25.0.0/24(rw,wdelay,root_squash,no_subtree_check,sec=krb5p,rw,secure,root_squash,no_all_squash)\n....\n\n如果你修改了 /etc/exports 配置，不想重启服务又想立即生效，可以使用\n`exportfs -arv`\n\n","fields":{"slug":"/articles/2018/02/20/1546344584166.html","birthTime":"2018-02-20T00:35:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[rhce] 10 配置 NFS 服务"}},{"content":"= [rhce] 11 挂载一个NFS共享\n:page-description: rhce 11 挂载一个NFS共享\n:page-category: rhce\n:page-image: https://img.hacpai.com/bing/20181128.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/20/1546344584550.html\n:page-created: 1519115880000\n:page-modified: 1546346534441\n:toc:\n\n____\n在 desktopX 上挂载一个来自 serverX 上的 NFS 共享，并符合下列要求： -\n/pulbic 共享挂载到本地的 /mnt/nfsmount。 - /protected 挂载到本地的/\nmnt/nfssecure, 并使用安全的方式，密钥下载地址：\nhttp://classroom.example.com/pub/keytabs/desktop0.keytab - 用户\nldapuserX 能够在 /mnt/nfssecure/project 上创建文件。 -\n这些文件系统在系统启动时自动挂载。\n____\n\n== 操作\n\n先 `showmount` 查看一下server0的共享。如果没有，返回检查 server0.\n\n....\nshowmount -e server0\nExport list for server0:\n/protected 172.25.0.0/24\n/public    172.25.0.0/24\n....\n\n建立相应的挂载点 /mnt/nfsmount 、 /mnt/nfssecure\n\n....\nmkdir /mnt/nfsmount mkdir /mnt/nfssecure\n....\n\n下载kerberos证书到/etc/krb5.keytab\n\n....\nwget -O /etc/krb5.keytab http://classroom.example.com/pub/keytabs/desktop0.keytab\n....\n\n启动相关服务并设置开机启动\n\n....\nsystemctl restart nfs-secure\nsystemctl enable nfs-secure\n....\n\n`vim /etc/fstab` 使得开机能自动挂载\n\n....\n172.25.0.11:/public        /mnt/nfsmount   nfs     defaults                                   0       0\n172.25.0.11:/protected  /mnt/nfssecure   nfs     defaults,sec=krb5p,v4.2        0       0\n....\n\n重启服务\n\n....\nsystemctl restart nfs-server.service\n....\n\n`mount -a` 挂载所有选项\n\n切换用户，尝试访问\n\n....\nsu - ldapuserX\n....\n\nimage::https://resources.echocow.cn/image/rhce/1.png[test]\n\n","fields":{"slug":"/articles/2018/02/20/1546344584550.html","birthTime":"2018-02-20T08:38:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[rhce] 11 挂载一个NFS共享"}},{"content":"= [rhce] 12 实现一个web服务器\n:page-description: rhce 12 实现一个web服务器\n:page-category: rhce\n:page-image: https://img.hacpai.com/bing/20171217.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/20/1546344585618.html\n:page-created: 1519123320000\n:page-modified: 1546346003968\n:toc:\n\n____\n在 server0 上配置一个站点 http://server0.example.com，然后执行以下步骤:\n- 从 http://classroom.example.com/materials/station.html 下载文件，并且\n- 将文件重命名为 index.html,绝对不能修改此文件的内容。 - 将 index.html\n拷贝到你的 web 服务器的 DocumentRoot 目录下。 - 来自 example.com\n172.25.0.0/24 域的客户端可以访问此 web 站点。 - 来自 my133t.org\n172.17.10.0/24 域的客户端拒绝访问此 web 站点。\n____\n\n____\n*备注：网站的 DocumentRoot 如果题目没有指定，那么随意。*\n____\n\n== 操作\n\n先获取题目指定的 index.html\n\n....\nwget -O /var/www/html/index.html  http://classroom.example.com/materials/station.html\n....\n\n建立一个虚拟主机\n\n....\nvim  /etc/httpd/conf.d/server47.conf\n....\n\n配置文件如下\n\n....\n<VirtualHost *:80>\n  ServerName server47.example.com\n  DocumentRoot \"/var/www/html\"\n  <Directory \"/var/www/html\">\n    <RequireAll>\n      Require all granted\n      Require not ip 172.17.10.0/24\n    </RequireAll>\n  </Directory>\n</VirtualHost>\n....\n\n测试配置是否有误\n\n....\napachectl  configtest\n....\n\n然后重启服务，开放防火墙\n\n....\nsystemctl  enable  httpd\nsystemctl  restart   httpd\nfirewall-cmd  --permanent  --add-service=http\nfirewall-cmd  --reload\n....\n\n","fields":{"slug":"/articles/2018/02/20/1546344585618.html","birthTime":"2018-02-20T10:42:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[rhce] 12 实现一个web服务器"}},{"content":"= [rhce] 9 配置多用户 SMB 挂载\n:page-description: rhce 9 配置多用户 SMB 挂载\n:page-category: rhce\n:page-image: https://img.hacpai.com/bing/20180110.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/20/1546344586111.html\n:page-created: 1519080300000\n:page-modified: 1546346558038\n:toc:\n\n____\n在 desktopX 上完成以下要求的配置： - desktopX 把 serverX 的 common\n共享通过多用户的方式挂载到本地的 /mnt/multiuser - 用户 rob，samba 密码为\nredhat，只读权限访问 common 共享。 - 用户 brain，samba 密码为\nredhat，读写权限访问 common 共享。 - 该共享要求在系统启动时自动挂载。\n____\n\n____\n备注：实际的共享和挂载点请根据考试题目设定\n____\n\n== 操作\n\n安装 cifs-utils 软件包以及 samb-client，因为其提供了 mount.cifs 命令\n\n....\nyum install cifs-utils.x86_64 -y\nyum install samba-client.x86_64 -y\n....\n\n创建挂载目录\n\n....\nmkdir /mnt/multiuser\n....\n\n使用 brian 的用户名和密码（使用权限较多的用户，如可读写的\nbrian）创建证书（凭据）文件。\n\n....\necho 'username=brian' > /root/smb-multiuser.txt\necho 'password=redhat' >> /root/smb-multiuser.txt\n....\n\n编辑挂载文件 `vim /etc/fstab`\n\n....\n//server47.example.com/common  /mnt/multiuser  cifs  credentials=/root/smb-multiuser.txt,sec=ntlmssp,multiuser   0 0\n....\n\n保存退出后，挂载 `mount -a`\n\n查看是否存在用户 rob 和 brian，如果不存在，创建，同时指定其 UID\n和服务端相同\n\n....\nuseradd -u 1001 robuseradd -u 1002 brian\n....\n\n设置密码\n\n....\necho \"redhat\" | passwd --stdin rob\necho \"redhat\" | passwd --stdin brian\n....\n\n由于要测试 rob 用户的可读权限，所以先用 brian 用户测试创建文件\n\n切换到 brian 用户\n\n....\n su - brian\n....\n\n添加 brian 的 samba 凭据，只读\n\n....\ncifscreds add server47\n....\n\n尝试写入文件\n\n....\necho \"multiuser\" > /mnt/multiuser/brian .txt\n....\n\n成功，`cat` 读取查看。\n\n退出\n\n切换到 rob 用户\n\n添加 rob 的 samba 凭据，只读\n\n....\ncifscreds add server47\n....\n\n尝试写入文件\n\n....\n echo \"multiuser\" > /mnt/multiuser/rob.txt\n....\n\n显示 image:https://resources.echocow.cn/image/rhce/9.1.png[显示]\n尝试读取 brian 创建的文件\n\n....\ncat /mnt/multiuser/brian.txt\n....\n\nimage::https://resources.echocow.cn/image/rhce/9.1.png[查看]\n\n成功！\n\n","fields":{"slug":"/articles/2018/02/20/1546344586111.html","birthTime":"2018-02-19T22:45:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[rhce] 9 配置多用户 SMB 挂载"}},{"content":"= [rhce] 13 配置安全web服务\n:page-description: rhce 13 配置安全web服务\n:page-category: rhce\n:page-image: https://img.hacpai.com/bing/20171217.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/21/1546344572836.html\n:page-created: 1519164660000\n:page-modified: 1546346055538\n:toc:\n\n____\n站点 http://serverX.example.com 配置 TLS 加密。 - 一个已经签名证书从\nhttp://classroom.example.com/pub/tls/certs/server47.crt 获取 -\n此证书的密钥从 http://classroom.example.com/pub/tls/private/server47.key\n获取 - 此证书的授权信息从\nhttp://classroom.example.com/pub/example-ca.crt 获取\n____\n\n____\n*备注：由于这里说法比较模糊，理解成为上一题配置加密 https 即可 *\n____\n\n== 操作\n\n安装 mod_ssl\n\n....\nyum install mod_ssl\n....\n\n获取证书\n\n....\nwget -O /etc/pki/tls/certs/server47.crt http://classroom.example.com/pub/tls/certs/server47.crt\nwget -O /etc/pki/tls/private/server47.key http://classroom.example.com/pub/tls/private/server47.key\nwget -O /etc/pki/tls/certs/example-ca.crt http://classroom.example.com/pub/example-ca.crt\n....\n\n修改 ssl.conf\n\n....\nvim /etc/httpd/conf.d/ssl.conf\n....\n\n修改为获取的路径以及名称\n\n....\nSSLCertificateFile /etc/pki/tls/certs/server47.crt\nSSLCertificateKeyFile /etc/pki/tls/private/server47.key\nSSLCACertificateFile /etc/pki/tls/certs/example-ca.crt\n....\n\n重启服务，添加服务\n\n....\nsystemctl  restart   httpd\nfirewall-cmd  --permanent  --add-service=https\nfirewall-cmd  --reload\n....\n\n","fields":{"slug":"/articles/2018/02/21/1546344572836.html","birthTime":"2018-02-20T22:11:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[rhce] 13 配置安全web服务"}},{"content":"= [rhce] 14 配置虚拟主机\n:page-description: rhce 14 配置虚拟主机\n:page-category: rhce\n:page-image: https://img.hacpai.com/bing/20180915.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/21/1546344576678.html\n:page-created: 1519174140000\n:page-modified: 1546346096678\n:toc:\n\n____\n在 serverX 上扩展你的 web 服务器，为站点 http://wwwX.example.com\n创建一个虚拟主机，然后执行以下步骤 - 设置 DocumentRoot 为\n/var/www/virtual - 从 http://classroom.example.com/materials/www.html\n下载文件并重命名为 index.html ，不要对文件 index.html 内容做任何修改。 -\n将 index.html 文件放到虚拟主机的 DocumentRoot 目录下，确保floyd\n用户能够在 /var/www/virtual 目录下创建文件。\n____\n\n____\n*注意：原始站点 http://serverX.example.com\n必须仍然能够访问，站点的所用的域名网络中已有 DNS 服务器解析*\n____\n\n== 操作\n\n创建文件夹，并下载文件\n\n....\nmkdir -p /var/www/virtual\nwget -O /var/www/virtual/index.html http://classroom.example.com/materials/www.html\n....\n\n创建新的虚拟主机\n\n....\nvim /etc/httpd/conf.d/www47.conf\n<VirtualHost *:80>\n  ServerName www47.example.com\n  DocumentRoot \"/var/www/virtual\"\n  <Directory \"/var/www/virtual\">\n    Require all granted\n  </Directory>\n</VirtualHost>\n....\n\n测试配置是否有误\n\n....\napachectl  configtest\n....\n\n添加用户，并设置 ACL 权限\n\n....\nuseradd floyd\nsetfacl -m u:floyd:rwX /var/www/virtual\n....\n\n然后重启服务\n\n....\nsystemctl  restart   httpd\n....\n\n","fields":{"slug":"/articles/2018/02/21/1546344576678.html","birthTime":"2018-02-21T00:49:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[rhce] 14 配置虚拟主机"}},{"content":"= [rhce] 15 配置 web 内容的访问\n:page-description: rhce 15 配置 web 内容的访问\n:page-category: rhce\n:page-image: https://img.hacpai.com/bing/20180608.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/21/1546344577105.html\n:page-created: 1519206720000\n:page-modified: 1546346111004\n:toc:\n\n[source, bash]\n____\n在你的 serverX 上的 web 服务器的 DocumentRoot 目录下创建一个名为 private\n的目录，要求如下： - 从\nhttp://classroom.example.com/materials/private.html\n下载一个文件副本到这个目录，并且重命名为 index.html -\n不要对这个文件的内容作任何修改。 - 从 systemX 上，任何人都可以浏览\nprivate\n的内容，但是从其他系统就不能访问这个目录的内容。（注意题目要求谁可以访问，灵活变化）\n____\n\n____\n*备注，此题是接着上一题，所以这里的 DocumentRoot 指的就是上面的\n/var/www/virtual/。*\n____\n\n== 操作\n\n创建文件夹\n\n....\nmkdir /var/www/virtual/private\n....\n\n获取文件\n\n....\nwget -O /var/www/virtual/private/index.html http://classroom.example.com/materials/private.html\n....\n\n编辑虚拟主机配置文件\n\n....\nvim www47.conf\n....\n\n添加配置\n\n[source,xml]\n----\n<VirtualHost *:80>\n  ServerName www47.example.com\n  DocumentRoot \"/var/www/virtual\"\n  <Directory \"/var/www/virtual\">\n    Require all granted\n  </Directory>\n  <!--添加一下内容-->\n  <Directory \"/var/www/virtual/private\">\n    Require all granted\n    Require local\n  </Directory>\n</VirtualHost>\n----\n\n测试配置是否有误\n\n....\napachectl  configtest\n....\n\n然后重启服务\n\n....\nsystemctl  restart   httpd\n....\n\n","fields":{"slug":"/articles/2018/02/21/1546344577105.html","birthTime":"2018-02-21T09:52:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[rhce] 15 配置 web 内容的访问"}},{"content":"= [rhce] 16 实现动态WEB 内容\n:page-description: rhce 16 实现动态WEB 内容\n:page-category: rhce\n:page-image: https://img.hacpai.com/bing/20181213.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/21/1546344579104.html\n:page-created: 1519215300000\n:page-modified: 1546346234004\n:toc:\n\n____\n在 system1 上配置提供动态web内容，要求如下： -\n动态内容由名为wsgi.group8.example.com 的虚拟主机提供 -\n虚拟主机侦听在端口 8909 - 从\nhttp://server.group8.example.com/pub/webinfo.wsgi\n下载一个脚本，然后放在适当的位置，无论如何不要修改此文件的内容 -\n客户端访问 http:// wsgi.group8.example.com:8909/\n时，应该接收到动态生成的web页面 - 此 http://\nwsgi.group8.example.com:8909/ 必须能被 group8.example.com\n域内的所有系统访问\n____\n\n== 操作\n\n安装 wsgi 的模块，才能运行 .wsgi 后缀的文件\n\n....\nyum  install mod_wsgi\n....\n\n创建文件夹并获取文件\n\n....\nmkdir /var/www/webappcd /var/www/webapp\nwget -O webinfo.wsgi http://server.group8.example.com/pub/webinfo.wsgi\n....\n\n配置虚拟主机\n\n[source,xml]\n----\nvim wsgi.conf\n\nListen 8908\n<VirtualHost *:8908>\n  DocumentRoot \"/var/www/webapp\"\n  ServerName wsgi.group8.example.com\n  WSGIScriptAlias      /    /var/www/webapp/webinfo.wsgi\n</VirtualHost>\n----\n\n测试配置\n\n....\napachectl configtest\n....\n\n开启防火墙，只允许 group8.example.com 域内的所有系统访问\n\n....\nfirewall-cmd --add-rich-rule 'rule family=\"ipv4\" source address=\"172.24.8.0/24\" port port=\"8909\" protocol=\"tcp\" accept' --permanent\n....\n\n重启防火墙，并设置端口，重启服务\n\n....\nfirewall-cmd --reloadsemanage port -a -t http_port_t -p tcp 8909\nsystemctl restart httpd\n....\n\n测试\n\nimage:https://resources.echocow.cn/image/rhce/16.1.png[image]\n\n","fields":{"slug":"/articles/2018/02/21/1546344579104.html","birthTime":"2018-02-21T12:15:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[rhce] 16 实现动态WEB 内容"}},{"content":"= [rhce] 3 配置 IPV6 地址\n:page-description: 配置 IPV6 地址\n:page-category: rhce\n:page-image: https://img.hacpai.com/bing/20180829.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/15/1546344586289.html\n:page-created: 1518657900000\n:page-modified: 1546346640054\n:toc:\n\n____\n在你的考试系统上配置接口 eth0 使用以下 IPV6地址： -\nserverx上的地址应该是 fddb:fe2a:ab1e::c0a8:1/64 -\n根据考试实际提供的地址配置 - desktopx上的地址应该是\nfddb:fe2a:ab1e::c0a8:2/64 - 两个系统必须能够与网络\nfddb:fe2a:able/64内的系统通信。 - 地址必须在重启后依旧生效。 -\n两个系统必须保持当前的 IPV4 地址并能通信\n____\n\n== 方法一：\n\n修改/etc/sysconfig/network-scripts/ifcfg-eth0\n\n[source,bash]\n----\n/etc/sysconfig/network-scripts/ifcfg-eth0\n----\n\n[source,bash]\n----\nDEVICE=eth0\nBOOTPROTO=static\nONBOOT=yes\nTYPE=Ethernet\nUSERCTL=yes\nPEERDNS=yes\nIPV6INIT=yes\nIPADDR=172.25.47.11\nPREFIX=24\nGATEWAY=172.25.47.254\nDNS1=172.254.254.254\nIPV6ADDR=\"fddb:fe2a:ab1e::c0a8:1/64\"\nIPV6_AUTOCONF=no\n----\n\n[source,bash]\n----\nsystemctl restart network\n----\n\nimage::https://resources.echocow.cn/image/rhce/3.1.png[see]\n\n== 方法二：\n\n通过nmcli控制\n\n[source,bash]\n----\nnmcli connection show              //查看当前的连接\n----\n\nimage::https://resources.echocow.cn/6.png[see]\n\n[source,bash]\n----\nnmcli connection modify \"System eth0\" ipv6.method manual ipv6.addresses \"fddb:fe2a:ab1e::c0a8:2/64\"\n\n# 重启查看\n\nsystemctl restart NetworkManager\n----\n\n配置完毕后nmcli con show查看\n\nimage::https://resources.echocow.cn/image/rhce/3.2.png[see]\n\n重启reboot\n\nimage::https://resources.echocow.cn/image/rhce/3.3.png[see]\n\n只有一个\n","fields":{"slug":"/articles/2018/02/15/1546344586289.html","birthTime":"2018-02-15T01:25:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[rhce] 3 配置 IPV6 地址"}},{"content":"= [rhce] 4 配置链路聚合\n:page-description: 配置链路聚合\n:page-category: rhce\n:page-image: https://img.hacpai.com/bing/20190228.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/16/1546344579957.html\n:page-created: 1518789120000\n:page-modified: 1546346626101\n:toc:\n\n____\n注意：此题最好切换成英文模式，查看一下其需要的模式是什么 - 在 serverX 和\ndesktopX 之间按以下要求配置： - 此链路使用接口 eth1 和 eth2 -\n此链路在一个接口失效时仍然能工作 - 此链路在 serverX 使用下面的地址\n192.168.0.101/255.255.255.0 - 此链路在 desktopX 使用下面的地址\n192.168.0.102/255.255.255.0 - 此链路在系统重启之后依然保持正常状态\n____\n\n模式：activebackup\n\n可能出现 roundrobin\n\n两台主机之间可以互 ping\n\n在练习前，需要启动网桥实验环境\n\n[source,bash]\n----\nlab teambridge setup\n----\n\nimage:https://resources.echocow.cn/image/rhce/4.1.png[链路] 存在 eno1 和\neno2，下面开始配置链路聚合，由于此链路在一个接口失效时仍然能工作，模式为\n*activebackup*\n\n== 方法一：修改配置文件\n\n从提供的文件复制过来，查看已提供的参考文件：\n\n[source,bash]\n----\ncd /usr/share/doc/teamd-1.9/example_ifcfgs\n----\n\nimage::https://resources.echocow.cn/image/rhce/4.2.png[链路]\n\n分别对应不同模式的配置文件\n\n1 —-> roundrobin\n\n2 —-> lacp\n\n3 —-> activebackup\n\n需要的是 activebackup ，复制其下的三个文件到网络配置文件夹下\n\n[source,bash]\n----\ncp -r  3 /etc/sysconfig/network-scripts/\n----\n\n然后移除并修改其名称与网卡对应，网卡名为 eno1、eno2\n\n[source,bash]\n----\nmv ifcfg-eth1  ../ifcfg-eno1\nmv ifcfg-eth2  ../ifcfg-eno2\nmv ifcfg-team_test0 ../ifcfg-team_test0\n----\n\n由于名称改变了，进入对应的配置文件修改为对应的名称\n\nimage::https://resources.echocow.cn/image/rhce/4.3.png[链路]\n\nimage::https://resources.echocow.cn/image/rhce/4.4.png[链路]\n\n同时修改网桥的 ip 地址以及 TEAM_CONFIG\n\nimage::https://resources.echocow.cn/image/rhce/4.5.png[链路]\n\n然后重启网络以及网络管理\n\n[source,bash]\n----\nsystemctl restart network\nsystemctl restart NetworkManager\n----\n\n然后 ip a 查看配置情况\n\nimage::https://resources.echocow.cn/image/rhce/4.6.png[链路]\n\n再尝试 ping 一下\n\nimage::https://resources.echocow.cn/image/rhce/4.7.png[链路]\n\n成功\n\n== 方法二：nmcli 命令修改\n\n添加一个team类型的接口，配置名叫team0，接口名叫team0，JSON配置，由于需要一个接口失效的时候，依然能工作，所以指定的是\nactivebackup。\n\n[source,bash]\n----\nnmcli connection add type team con-name team0 ifname team0 config '{\"runner\":{\"name\":\"activebackup\"}}‘\n----\n\n将eno1和eno2添加进，team0。\n\n[source,bash]\n----\nnmcli connection add type team-slave con-name team0-eth1 ifname eth1 master team0\nnmcli connection add type team-slave con-name team0-eth2 ifname eth2 master team0\n----\n\n修改IP地址\n\n[source,bash]\n----\nnmcli connection modify team0 ipv4.method manual ipv4.addresses '192.168.0.101/24'\n----\n\n重启网络服务 `systemctl restart network`\n\n检验`ip addr` 和 `teamdctl <team name> state`\n\nimage::https://resources.echocow.cn/image/rhce/4.8.png[链路]\n\nimage::https://resources.echocow.cn/image/rhce/4.9.png[链路]\n\n'''''\n\n== 补充 常用的网卡绑定模式\n\n[cols=\",\",options=\"header\",]\n|===\n|类型 |描述\n|activebackup |自动备援模式\n|loadbalance |负载均衡模式\n|roundrobin |轮换模式\n|===\n","fields":{"slug":"/articles/2018/02/16/1546344579957.html","birthTime":"2018-02-16T13:52:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[rhce] 4 配置链路聚合"}},{"content":"= [rhce] 17 创建一个脚本\n:page-description: rhce 17 创建一个脚本\n:page-category: rhce\n:page-image: https://img.hacpai.com/bing/20180301.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/22/1546344580391.html\n:page-created: 1519309080000\n:page-modified: 1546349362004\n:toc:\n\n____\n在system1上创建一个名为/root/foo.sh的脚本，让其提供下列特性： -\n当运行/root/foo.sh redhat,输出为fedora - 当运行/root/foo.sh\nfedora,输出为redhat -\n当没有任何参数或者参数不是redhat或者fedora时，其错误输出产生以下的信息：/root/foo.sh\nredhat:fedora\n____\n\n== 操作\n\n切换到 root 目录，并编辑文件\n\n....\ncd ~\nvim foo.sh\n....\n\n编写脚本\n\n[source,shell]\n----\n#!/bin/bash\ncase $1 in\n   redhat)\n     echo fedora\n     ;;\n   fedora)\n     echo redhat\n     ;;\n   *)\n   echo '/root/foo.sh redhat:fedora'\nesac\n\n:wq\n----\n\n添加可执行权限并测试\n\n....\n[root@system1 ~]# chmod +x foo.sh\n[root@system1 ~]# ./foo.sh\n/root/foo.sh redhat:fedora\n[root@system1 ~]# ./foo.sh red\n/root/foo.sh redhat:fedora\n[root@system1 ~]# ./foo.sh redhat\nfedora\n....\n\n","fields":{"slug":"/articles/2018/02/22/1546344580391.html","birthTime":"2018-02-22T14:18:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[rhce] 17 创建一个脚本"}},{"content":"= [rhce] 18 创建一个添加用户的脚本\n:page-description: rhce 18 创建一个添加用户的脚本\n:page-category: rhce\n:page-image: https://img.hacpai.com/bing/20180304.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/23/1546344585394.html\n:page-created: 1519315260000\n:page-modified: 1546346255607\n:toc:\n\n____\n在system1上创建一个脚本，名为/root/mkusers\n,此脚本能实现为系统system1创建本地用户，并且这些用户的用户名来自一个包含用户名列表的文件，同时满足下列要求：\n1. 此脚本要求提供一个参数，此参数就是包含用户名列表的的文件 2.\n如果没有提供参数，此脚本应该给出下面的提示信息Usage：/root/mkusers然后退出并返回相应的值\n3. 如果提供一个不存在的文件名，此脚本应该给出下面的提示信息Input file\nnot found 然后退出并返回相应的值 4. 创建的用户登录shell为/bin/false 5.\n此脚本不需要为用户设置密码 6.\n您可以从下面的URL中获取用户名列表作为测试用http://server.group8.example.com/pub/userlist\n**注意题目要求的脚本文件名称是否带.sh后缀，有就加没有就不加**\n____\n\n'''''\n\n== 操作\n\n切换到 root 目录，并编辑文件\n\n....\n    cd ~\n    vim mkusers\n....\n\n编写脚本\n\n....\n#! /bin/bash\nif [ $# -eq 0 ];then\n echo 'Usage:/root/mkusers'\n  exit 1\nfi\nif [ ! -f $1 ]; then\n echo 'Input file not found'\n exit 1\nfi\nwhile read line\ndo\n  useradd -s /bin/false $line\ndone < $1\n\n:wq\n....\n\n测试\n\n....\nchmod  +x  mkusers.sh\nwget  -O /root/userlist http://server.group8.example.com/pub/userlist\n./mkusers userlist\n\nid 用户名  查看用户是否添加\n然后测试文件不存在和没有输入参数的情况是否符合题目要求\n\n[root@system1 ~]# ./mkusers userl\nInput file not found\n[root@system1 ~]# ./mkusers\nUsage:/root/mkusers\n....\n\n自己写的\n\n....\n#!/bin/bash\n[ ! \"$1\" ] && {\n    echo \"Usage：/root/mkusers\";\n    exit 1;\n}\npath=\"$1\";\n[ ! -f \"$path\" ] && {\n    echo \"Input file not found\";\n    exit 2;\n}\n\nfor u in `cat $path`\ndo\n    echo $u;\n    useradd -s /bin/false $u;\ndone\n....\n\n","fields":{"slug":"/articles/2018/02/23/1546344585394.html","birthTime":"2018-02-22T16:01:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[rhce] 18 创建一个添加用户的脚本"}},{"content":"= [rhce] 19 配置ISCSI服务端\n:page-description: rhce 19 配置ISCSI服务端\n:page-category: rhce\n:page-image: https://img.hacpai.com/bing/20180510.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/23/1546344587014.html\n:page-created: 1519351320000\n:page-modified: 1546346285514\n:toc:\n\n____\n配置system1提供一个ISCSI 服务磁盘名为 iqn.2014-08.com.example:system1\n并符合下列要求： 1. 服务端口为3260 2.\n使用iscsi_store作其后端卷名称，其大小为3G 3.\n此服务只能被system2.group8.example.com访问\n____\n\n== 操作\n\n安装 target 、开启服务并开机启动\n\n....\nyum install targetcli.noarch -y\nsystemctl enable target\nsystemctl start target\nfirewall-cmd --permanent --add-port=3260/tcp    //需要配置访问控制、富规则\nfirewall-cmd --reload\n....\n\n为其创建后端卷并查看\n\n....\n[root@system1 ~]# fdisk /dev/sda\nWelcome to fdisk (util-linux 2.23.2).\n\nChanges will remain in memory only, until you decide to write them.\nBe careful before using the write command.\n\n\nCommand (m for help): n\nPartition type:\n   p   primary (2 primary, 0 extended, 2 free)\n   e   extended\nSelect (default p): p\nPartition number (3,4, default 3):\nFirst sector (26626048-41943039, default 26626048):\nUsing default value 26626048\nLast sector, +sectors or +size{K,M,G} (26626048-41943039, default 41943039): +3G\nPartition 3 of type Linux and of size 3 GiB is set\n\nCommand (m for help): w\nThe partition table has been altered!\n\nCalling ioctl() to re-read partition table.\n\nWARNING: Re-reading the partition table failed with error 16: Device or resource busy.\nThe kernel still uses the old table. The new table will be used at\nthe next reboot or after you run partprobe(8) or kpartx(8)\nSyncing disks.\n[root@system1 ~]# lsblk\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsda      8:0    0   20G  0 disk\n├─sda1   8:1    0  9.8G  0 part /\n└─sda2   8:2    0    3G  0 part [SWAP]\n[root@system1 ~]# partprobe\n[root@system1 ~]# lsblk\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsda      8:0    0   20G  0 disk\n├─sda1   8:1    0  9.8G  0 part /\n├─sda2   8:2    0    3G  0 part [SWAP]\n└─sda3   8:3    0    3G  0 part\n配置 ISCSI 并重启服务\n[root@system1 ~]# targetcli\nWarning: Could not load preferences file /root/.targetcli/prefs.bin.\ntargetcli shell version 2.1.fb34\nCopyright 2011-2013 by Datera, Inc and others.\nFor help on commands, type 'help'.\n\n/> ls\no- / ......................................................................................................................... [...]\n  o- backstores .............................................................................................................. [...]\n  | o- block .................................................................................................. [Storage Objects: 0]\n  | o- fileio ................................................................................................. [Storage Objects: 0]\n  | o- pscsi .................................................................................................. [Storage Objects: 0]\n  | o- ramdisk ................................................................................................ [Storage Objects: 0]\n  o- iscsi ............................................................................................................ [Targets: 0]\n  o- loopback ......................................................................................................... [Targets: 0]\n/> /backstores/block create name=iscsi_store dev=/dev/sda3\nCreated block storage object iscsi_store using /dev/sda3.\n// 创建后端卷\n\n/> ls\no- / ......................................................................................................................... [...]\n  o- backstores .............................................................................................................. [...]\n  | o- block .................................................................................................. [Storage Objects: 1]\n  | | o- iscsi_store ................................................................... [/dev/sda3 (3.0GiB) write-thru deactivated]\n  | o- fileio ................................................................................................. [Storage Objects: 0]\n  | o- pscsi .................................................................................................. [Storage Objects: 0]\n  | o- ramdisk ................................................................................................ [Storage Objects: 0]\n  o- iscsi ............................................................................................................ [Targets: 0]\n  o- loopback ......................................................................................................... [Targets: 0]\n/> /iscsi create wwn=iqn.2014-08.com.example:system1\nCreated target iqn.2014-08.com.example:system1.\nCreated TPG 1.\n\n/> ls\no- / ......................................................................................................................... [...]\n  o- backstores .............................................................................................................. [...]\n  | o- block .................................................................................................. [Storage Objects: 1]\n  | | o- iscsi_store ................................................................... [/dev/sda3 (3.0GiB) write-thru deactivated]\n  | o- fileio ................................................................................................. [Storage Objects: 0]\n  | o- pscsi .................................................................................................. [Storage Objects: 0]\n  | o- ramdisk ................................................................................................ [Storage Objects: 0]\n  o- iscsi ............................................................................................................ [Targets: 1]\n  | o- iqn.2014-08.com.example:system1 ................................................................................... [TPGs: 1]\n  |   o- tpg1 ............................................................................................... [no-gen-acls, no-auth]\n  |     o- acls .......................................................................................................... [ACLs: 0]\n  |     o- luns .......................................................................................................... [LUNs: 0]\n  |     o- portals .................................................................................................... [Portals: 0]\n  o- loopback ......................................................................................................... [Targets: 0]\n/> /iscsi/iqn.2014-08.com.example:system1/tpg1/acls create\nadd_mapped_luns=  wwn=\n...........................................................wwn|keyword=\n/> /iscsi/iqn.2014-08.com.example:system1/tpg1/acls create iqn.2014-08.com.example:system2\nCreated Node ACL for iqn.2014-08.com.example:system2\n//访问控制\n\n/> ls\no- / ......................................................................................................................... [...]\n  o- backstores .............................................................................................................. [...]\n  | o- block .................................................................................................. [Storage Objects: 1]\n  | | o- iscsi_store ................................................................... [/dev/sda3 (3.0GiB) write-thru deactivated]\n  | o- fileio ................................................................................................. [Storage Objects: 0]\n  | o- pscsi .................................................................................................. [Storage Objects: 0]\n  | o- ramdisk ................................................................................................ [Storage Objects: 0]\n  o- iscsi ............................................................................................................ [Targets: 1]\n  | o- iqn.2014-08.com.example:system1 ................................................................................... [TPGs: 1]\n  |   o- tpg1 ............................................................................................... [no-gen-acls, no-auth]\n  |     o- acls .......................................................................................................... [ACLs: 1]\n  |     | o- iqn.2014-08.com.example:system2 ...................................................................... [Mapped LUNs: 0]\n  |     o- luns .......................................................................................................... [LUNs: 0]\n  |     o- portals .................................................................................................... [Portals: 0]\n  o- loopback ......................................................................................................... [Targets: 0]\n/> /iscsi/iqn.2014-08.com.example:system1/tpg1/luns\n@last      cd         delete     get        ls         refresh    status\nbookmarks  create     exit       help       pwd        set\n....................................................command\n/> /iscsi/iqn.2014-08.com.example:system1/tpg1/luns create /backstores/block/iscsi_store\nCreated LUN 0.\nCreated LUN 0->0 mapping in node ACL iqn.2014-08.com.example:system2\n/> ls\no- / ......................................................................................................................... [...]\n  o- backstores .............................................................................................................. [...]\n  | o- block .................................................................................................. [Storage Objects: 1]\n  | | o- iscsi_store ..................................................................... [/dev/sda3 (3.0GiB) write-thru activated]\n  | o- fileio ................................................................................................. [Storage Objects: 0]\n  | o- pscsi .................................................................................................. [Storage Objects: 0]\n  | o- ramdisk ................................................................................................ [Storage Objects: 0]\n  o- iscsi ............................................................................................................ [Targets: 1]\n  | o- iqn.2014-08.com.example:system1 ................................................................................... [TPGs: 1]\n  |   o- tpg1 ............................................................................................... [no-gen-acls, no-auth]\n  |     o- acls .......................................................................................................... [ACLs: 1]\n  |     | o- iqn.2014-08.com.example:system2 ...................................................................... [Mapped LUNs: 1]\n  |     |   o- mapped_lun0 ........................................................................... [lun0 block/iscsi_store (rw)]\n  |     o- luns .......................................................................................................... [LUNs: 1]\n  |     | o- lun0 .................................................................................. [block/iscsi_store (/dev/sda3)]\n  |     o- portals .................................................................................................... [Portals: 0]\n  o- loopback ......................................................................................................... [Targets: 0]\n/> /\n/*            /backstores/  /iscsi/       /loopback/\n...path\n/> /iscsi/iqn.2014-08.com.example:system1/tpg1/portals\n@last      cd         delete     get        ls         refresh    status\nbookmarks  create     exit       help       pwd        set\n.......................................................command\n/> /iscsi/iqn.2014-08.com.example:system1/tpg1/portals create 172.24.8.11\nUsing default IP port 3260\nCreated network portal 172.24.8.11:3260.\n/> saveconfig\nLast 10 configs saved in /etc/target/backup.\nConfiguration saved to /etc/target/saveconfig.json\n/> exit\nGlobal pref auto_save_on_exit=true\nLast 10 configs saved in /etc/target/backup.\nConfiguration saved to /etc/target/saveconfig.json\n[root@system1 ~]# systemctl restart target.service\n[root@system1 ~]# systemctl enable target.service\n....\n\n","fields":{"slug":"/articles/2018/02/23/1546344587014.html","birthTime":"2018-02-23T02:02:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[rhce] 19 配置ISCSI服务端"}},{"content":"= [rhce] 20 配置 ISCSI 的客户端\n:page-description: rhce 20 配置 ISCSI 的客户端\n:page-category: rhce\n:page-image: https://img.hacpai.com/bing/20180415.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/24/1546344585841.html\n:page-created: 1519420020000\n:page-modified: 1546346301509\n:toc:\n\n____\n配置system2使其能链接在system1上提供的 iqn.2014-08.com.example:system1\n并符合以下要求： 1. ISCISI设备在系统启动的期间自动加载 2.\n块设备ISCISI上包含一个大小为2100MIB的分区，并格式化为ext4 3.\n此分区挂载在/mnt/data上 同时在系统启动的期间自动挂载\n____\n\n== 操作\n\n安装 ISCSI 客户端工具\n\n....\n    yum install iscsi-initiator-utils.i686 -y\n....\n\n编辑配置文件\n\n....\n    vim /etc/iscsi/initiatorname.iscsi\n    //编辑\n    InitiatorName=iqn.2014-08.com.example:system2\n....\n\n通过 ==man iscsiadm== 查找命令发现服务端 ISCSI 并连接\n\n....\n···\nEXAMPLES\n       Discover targets at a given IP address:\n\n            iscsiadm --mode discoverydb --type sendtargets --portal 192.168.1.10 --discover\n\n       Login, must use a node record id found by the discovery:\n\n            iscsiadm --mode node --targetname iqn.2001-05.com.doe:test --portal 192.168.1.1:3260 --login\n\n       Logout:\n\n            iscsiadm --mode node --targetname iqn.2001-05.com.doe:test --portal 192.168.1.1:3260 --logout\n···\n\n    [root@system2 Desktop]# iscsiadm --mode discoverydb --type sendtargets --portal 172.24.8.11 --discover\n    172.24.8.11:3260,1 iqn.2014-08.com.example:system1\n    [root@system2 Desktop]# iscsiadm --mode node --targetname iqn.2014-08.com.example:system1 --portal 172.24.8.11:3260 --login\n    Logging in to [iface: default, target: iqn.2014-08.com.example:system1, portal: 172.24.8.11,3260] (multiple)\n    Login to [iface: default, target: iqn.2014-08.com.example:system1, portal: 172.24.8.11,3260] successful.\n    [root@system2 Desktop]# lsblk\n    NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\n    sda      8:0    0   20G  0 disk\n    ├─sda1   8:1    0  9.8G  0 part /\n    └─sda2   8:2    0    2G  0 part [SWAP]\n    sdb      8:16   0    3G  0 disk\n....\n\n按照要求，对已成功获取的 ==sdb== 进行分区\n\n....\n    [root@system2 Desktop]# fdisk /dev/sdb\n    Welcome to fdisk (util-linux 2.23.2).\n\n    Changes will remain in memory only, until you decide to write them.\n    Be careful before using the write command.\n\n    Device does not contain a recognized partition table\n    Building a new DOS disklabel with disk identifier 0xaeacfbad.\n\n    Command (m for help): n\n    Partition type:\n       p   primary (0 primary, 0 extended, 4 free)\n       e   extended\n    Select (default p): p\n    Partition number (1-4, default 1):\n    First sector (8192-6291455, default 8192):\n    Using default value 8192\n    Last sector, +sectors or +size{K,M,G} (8192-6291455, default 6291455): +2100MIB\n    Unsupported suffix: 'MIB'.\n    Supported: 10^N: KB (KiloByte), MB (MegaByte), GB (GigaByte)\n                2^N: K  (KibiByte), M  (MebiByte), G  (GibiByte)\n    Last sector, +sectors or +size{K,M,G} (8192-6291455, default 6291455): +2100MB\n    Partition 1 of type Linux and of size 2 GiB is set\n\n    Command (m for help): w\n    The partition table has been altered!\n\n    Calling ioctl() to re-read partition table.\n    Syncing disks.\n    [root@system2 Desktop]# partprobe\n    [root@system2 Desktop]# mkdir /mnt/data\n    [root@system2 Desktop]# mkfs.ext4 /dev/sdb1\n    mke2fs 1.42.9 (28-Dec-2013)\n    Filesystem label=\n    OS type: Linux\n    Block size=4096 (log=2)\n    Fragment size=4096 (log=2)\n    Stride=0 blocks, Stripe width=1024 blocks\n    128256 inodes, 513024 blocks\n    25651 blocks (5.00%) reserved for the super user\n    First data block=0\n    Maximum filesystem blocks=526385152\n    16 block groups\n    32768 blocks per group, 32768 fragments per group\n    8016 inodes per group\n    Superblock backups stored on blocks:\n        32768, 98304, 163840, 229376, 294912\n\n    Allocating group tables: done\n    Writing inode tables: done\n    Creating journal (8192 blocks): done\n    Writing superblocks and filesystem accounting information: done\n....\n\n实现永久挂载、并查看\n\n....\n    [root@system2 Desktop]# vim /etc/fstab\n    /dev/sdb1                       /mnt/data               ext4    _netdev                         0 0\n    [root@system2 Desktop]# mount -a\n    [root@system2 Desktop]# df -hT\n    Filesystem       Type      Size  Used Avail Use% Mounted on\n    /dev/sda1        xfs       9.8G  3.1G  6.7G  32% /\n    devtmpfs         devtmpfs  765M     0  765M   0% /dev\n    tmpfs            tmpfs     773M  176K  773M   1% /dev/shm\n    tmpfs            tmpfs     773M  8.9M  765M   2% /run\n    tmpfs            tmpfs     773M     0  773M   0% /sys/fs/cgroup\n    /dev/sdb1        ext4      1.9G  5.9M  1.8G   1% /mnt/data\n....\n\n完成\n\n","fields":{"slug":"/articles/2018/02/24/1546344585841.html","birthTime":"2018-02-23T21:07:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[rhce] 20 配置 ISCSI 的客户端"}},{"content":"= [rhce] 21 部署 mariadb 数据库\n:page-description: rhce 21 部署 mariadb 数据库\n:page-category: rhce\n:page-image: https://img.hacpai.com/bing/20171126.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/24/1546344582926.html\n:page-created: 1519474080000\n:page-modified: 1546346325739\n:toc:\n\n____\n在 system1上创建一个Maria DB数据库，名为Contacts，并符合以下条件： 1.\n数据库应该包含来自数据库复制的内容，复制文件的URL为 +\nhttp://server.group8.example.com/pub/users.mdb ，数据库只能被 localhost\n访问 2. 除了root用户，此数据库只能被用户Luigi查询，此用户密码为 redhat\n3. root 用户的数据库密码为 redhat，同时不允许空密码登录\n____\n\n== 操作\n\n安装 mariadb 所需组件，为了防止遗漏，此处全部安装\n\n....\n    yum install  mariadb*\n    //设置开机启动并开启服务\n    [root@system1 ~]# systemctl enable mariadb.service\n    ln -s '/usr/lib/systemd/system/mariadb.service' '/etc/systemd/system/multi-user.target.wants/mariadb.service'\n    [root@system1 ~]# systemctl start mariadb.service\n....\n\nmariadb 安装向导，设置 root 密码\n\n....\n    [root@server47 ~]# mysql_secure_installation\n    /usr/bin/mysql_secure_installation: line 379: find_mysql_client: command not found\n\n    NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB\n          SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!\n\n    In order to log into MariaDB to secure it, we'll need the current\n    password for the root user.  If you've just installed MariaDB, and\n    you haven't set the root password yet, the password will be blank,\n    so you should just press enter here.\n\n    Enter current password for root (enter for none):\n    OK, successfully used password, moving on...\n\n    Setting the root password ensures that nobody can log into the MariaDB\n    root user without the proper authorisation.\n\n    Set root password? [Y/n]\n    New password:\n    Re-enter new password:\n    Password updated successfully!\n    Reloading privilege tables..\n     ... Success!\n\n\n    By default, a MariaDB installation has an anonymous user, allowing anyone\n    to log into MariaDB without having to have a user account created for\n    them.  This is intended only for testing, and to make the installation\n    go a bit smoother.  You should remove them before moving into a\n    production environment.\n\n    Remove anonymous users? [Y/n]\n     ... Success!\n\n    Normally, root should only be allowed to connect from 'localhost'.  This\n    ensures that someone cannot guess at the root password from the network.\n\n    Disallow root login remotely? [Y/n]\n     ... Success!\n\n    By default, MariaDB comes with a database named 'test' that anyone can\n    access.  This is also intended only for testing, and should be removed\n    before moving into a production environment.\n\n    Remove test database and access to it? [Y/n]\n     - Dropping test database...\n     ... Success!\n     - Removing privileges on test database...\n     ... Success!\n\n    Reloading the privilege tables will ensure that all changes made so far\n    will take effect immediately.\n\n    Reload privilege tables now? [Y/n]\n     ... Success!\n\n    Cleaning up...\n\n    All done!  If you've completed all of the above steps, your MariaDB\n    installation should now be secure.\n\n    Thanks for using MariaDB!\n....\n\n获取表结构以及信息\n\n....\n    [root@system1 ~]# wget http://server.group8.example.com/pub/users.mdb\n    --2018-02-28 18:45:37--  http://server.group8.example.com/pub/users.mdb\n    Resolving server.group8.example.com (server.group8.example.com)... 172.24.8.254\n    Connecting to server.group8.example.com (server.group8.example.com)|172.24.8.254|:80... connected.\n    HTTP request sent, awaiting response... 200 OK\n    Length: 4577 (4.5K)\n    Saving to: ‘users.mdb’\n\n    100%[===========================================================================================>] 4,577       --.-K/s   in 0s\n\n    2018-02-28 18:45:37 (234 MB/s) - ‘users.mdb’ saved [4577/4577]\n....\n\n登录数据库，并创建库和导入\n\n....\n    [root@system1 ~]# mysql -uroot -p\n    Enter password:\n    Welcome to the MariaDB monitor.  Commands end with ; or \\g.\n    Your MariaDB connection id is 12\n    Server version: 5.5.35-MariaDB MariaDB Server\n\n    Copyright (c) 2000, 2013, Oracle, Monty Program Ab and others.\n\n    Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n\n    MariaDB [(none)]> CREATE DATABASE Contacts;\n    Query OK, 1 row affected (0.00 sec)\n\n    MariaDB [(none)]> SHOW DATABASES;\n    +--------------------+\n    | Database           |\n    +--------------------+\n    | information_schema |\n    | Contacts           |\n    | mysql              |\n    | performance_schema |\n    +--------------------+\n    4 rows in set (0.00 sec)\n\n    MariaDB [(none)]> USE Contacts;\n    Database changed\n    MariaDB [Contacts]> source /root/users.mdb\n    Query OK, 0 rows affected (0.00 sec)\n\n    ······\n\n    Query OK, 0 rows affected (0.00 sec)\n\n    MariaDB [Contacts]> SHOW TABLES;\n    +--------------------+\n    | Tables_in_Contacts |\n    +--------------------+\n    | u_loc              |\n    | u_name             |\n    | u_passwd           |\n    +--------------------+\n    3 rows in set (0.00 sec)\n....\n\n设置用户权限，通过 ==help grant== 获取帮助\n\n....\n    MariaDB [(none)]> help grant\n    Name: 'GRANT'\n    Description:\n    Syntax:\n\n    ······\n\n    Normally, a database administrator first uses CREATE USER to create an\n    account, then GRANT to define its privileges and characteristics. For\n    example:\n\n    CREATE USER 'jeffrey'@'localhost' IDENTIFIED BY 'mypass';\n    GRANT ALL ON db1.* TO 'jeffrey'@'localhost';\n    GRANT SELECT ON db2.invoice TO 'jeffrey'@'localhost';\n    GRANT USAGE ON *.* TO 'jeffrey'@'localhost' WITH MAX_QUERIES_PER_HOUR 90;\n\n    ······\n\n    MariaDB [Contacts]> GRANT SELECT ON Contacts .* to Luigi@'localhost' IDENTIFIED BY 'redhat'; Query OK, 0 rows affected (0.00 sec)\n....\n\n完成！\n\n","fields":{"slug":"/articles/2018/02/24/1546344582926.html","birthTime":"2018-02-24T12:08:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[rhce] 21 部署 mariadb 数据库"}},{"content":"= [rhce] 22 数据库查询\n:page-description: rhce 22 数据库查询\n:page-category: rhce\n:page-image: https://img.hacpai.com/bing/20180624.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/25/1546344582745.html\n:page-created: 1519520940000\n:page-modified: 1546346340954\n:toc:\n\n____\n在系统 system1 上使用数据库 Contacts ，并使用相应的SQL\n查询以回答下列问题： 1. 密码是 tangerine 的人的名字？ 2.\n有多少人的姓名是 John 同时居住在 Santa Clara ？\n____\n\n== 操作\n\n登录数据库，查看表和表结构\n\n....\n    [root@system1 ~]# mysql -uroot -p\n    Enter password:\n    Welcome to the MariaDB monitor.  Commands end with ; or \\g.\n    Your MariaDB connection id is 16\n    Server version: 5.5.35-MariaDB MariaDB Server\n\n    Copyright (c) 2000, 2013, Oracle, Monty Program Ab and others.\n\n    Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n\n    MariaDB [(none)]> SHOW DATABASES;\n    +--------------------+\n    | Database           |\n    +--------------------+\n    | information_schema |\n    | Contacts           |\n    | mysql              |\n    | performance_schema |\n    +--------------------+\n    4 rows in set (0.01 sec)\n\n    MariaDB [(none)]> USE Contacts;\n    Reading table information for completion of table and column names\n    You can turn off this feature to get a quicker startup with -A\n\n    Database changed\n    MariaDB [Contacts]> SHOW TABLES;\n    +--------------------+\n    | Tables_in_Contacts |\n    +--------------------+\n    | u_loc              |\n    | u_name             |\n    | u_passwd           |\n    +--------------------+\n    3 rows in set (0.00 sec)\n\n    MariaDB [Contacts]> DESC u_loc;\n    +----------+-------------+------+-----+---------+----------------+\n    | Field    | Type        | Null | Key | Default | Extra          |\n    +----------+-------------+------+-----+---------+----------------+\n    | uid      | int(11)     | NO   | PRI | NULL    | auto_increment |\n    | location | varchar(50) | NO   |     | NULL    |                |\n    +----------+-------------+------+-----+---------+----------------+\n    2 rows in set (0.00 sec)\n\n    MariaDB [Contacts]> DESC u_name;\n    +-----------+-------------+------+-----+---------+----------------+\n    | Field     | Type        | Null | Key | Default | Extra          |\n    +-----------+-------------+------+-----+---------+----------------+\n    | userid    | int(11)     | NO   | PRI | NULL    | auto_increment |\n    | firstname | varchar(50) | NO   |     | NULL    |                |\n    | lastname  | varchar(50) | NO   |     | NULL    |                |\n    +-----------+-------------+------+-----+---------+----------------+\n    3 rows in set (0.00 sec)\n\n    MariaDB [Contacts]> DESC u_passwd;\n    +----------+-------------+------+-----+---------+----------------+\n    | Field    | Type        | Null | Key | Default | Extra          |\n    +----------+-------------+------+-----+---------+----------------+\n    | uid      | int(11)     | NO   | PRI | NULL    | auto_increment |\n    | password | varchar(50) | NO   |     | NULL    |                |\n    +----------+-------------+------+-----+---------+----------------+\n    2 rows in set (0.00 sec)\n....\n\n第一问，只需要用到 u_name 和 u_passwd 表就可以\n\n....\n    //嵌套子查询\n    MariaDB [Contacts]> SELECT firstname FROM u_name WHERE userid=(SELECT uid FROM u_passwd WHERE password = \"tangerine\");\n    +-----------+\n    | firstname |\n    +-----------+\n    | Georgexx  |\n    +-----------+\n    1 row in set (0.00 sec)\n\n    //多表查询\n    MariaDB [Contacts]> select firstname from u_name,u_passwd where u_name.userid=u_passwd.uid and u_passwd.password='tangerine';\n    +-----------+\n    | firstname |\n    +-----------+\n    | Georgexx  |\n    +-----------+\n    1 row in set (0.00 sec)\n....\n\n第二问，只需要用到 u_name 和 u_loc 表就可以\n\n....\n    MariaDB [Contacts]> SELECT COUNT(*) FROM u_loc l,u_name n WHERE l.uid = n.userid and n.firstname = 'John' and l.location = 'Santa Clara';\n    +----------+\n    | COUNT(*) |\n    +----------+\n    |        4 |\n    +----------+\n    1 row in set (0.01 sec)\n....\n\n","fields":{"slug":"/articles/2018/02/25/1546344582745.html","birthTime":"2018-02-25T01:09:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[rhce] 22 数据库查询"}},{"content":"= RHCE 2018 考试试题\n:page-description: RHCE 2018 考试试题\n:page-category: rhce\n:page-image: https://img.hacpai.com/bing/20181126.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/02/28/1546344573952.html\n:page-created: 1519755720000\n:page-modified: 1546346360095\n:toc:\n\n____\nyum源地址为：http://server.group8.example.com/yum\n____\n\n== 1. 配置SELINUX\n\n修改 selinux 的状态为 Enforcing 模式\n\n== 2. 配置SSH访问控制\n\n按以下要求配置SSH访问： > 1.用户能够从域 group8.example.com\n内的客户端通过SSH远程访问您的两个虚拟机系统 > 2.在域\nmy133t.org（172.13.8.0/24）内的客户端不能访问您的两个虚拟机系统\n\n== 3. 自定义用户环境\n\n在系统 system2 和 system1 上创建自定义命令名为 qstat\n，此自定义命令将执行以下命令： > /bin/ps -Ao pid,tt,user,fname,rsz\n\n此命令对系统中所有用户有效\n\n== 4. 配置端口转发\n\n在系统 system2 配置端口转发，要求如下： > 1. 在 172.24.8.0/24\n网络中的系统，访问 system2 的本地端口 5423 将被转发到 80 > 2.\n此设置必须永久有效\n\n== 5. 配置链路聚合\n\n在 system2 和 system1 之间按以下要求配置一个链路： > 1. 此链路使用接口\neth1 和 eth2 > 2. 此链路在一个接口失效时仍然能工作 > 3. 此链路在 system2\n使用下面的地址 172.16.3.20/255.255.255.0 > 4. 此链路在 system1\n使用下面的地址 172.16.3.25/255.255.255.0 > 5.\n此链路在系统重启之后依然保持正常状态\n\n== 6. 配置 IPV6 地址\n\n在您的考试系统上配置接口eth0 使用下列IPV6地址： > 1. system1\n上的地址应该是2003:ac18::305/64 > 2. system2\n上的地址应该是2003:ac18::30a/64 > 3. 两个系统必须能与网络 2003:ac18/64\n内的系统通信 > 4. 地址必须在重启后依然生效 > 5. 两个系统必须保持当前的\nIPV4 地址并能通信\n\n== 7. 配置本地邮件服务\n\n在系统 system2 和 system1 上配置邮件服务，满足以下要求： >\n1.这些系统不接受外部发送来的邮件 >\n2.在这些系统上本地发送的任何邮件都会自动路由到 mail.group8.example.com >\n3.从这些系统上发送的邮件显示来自于 server.group8.example.com >\n4.您可以通过发送邮件到本地用户’dave’来测试您的配置. >\n5.已经配置把此用户的邮件转到下列URL\n：server.group8.example.com/pub/received_mail/ >\n你只需看到对应用户名文件的大小有变化即可\n\n== 8.通过 SMB 共享目录\n\n在 system1 上配置SMB服务 > 您的 SMB 服务器必须是 STAFF 工作组一个成员 >\n共享 /common 目录，共享名必须为 common > 只有 group8.example.com\n域内的客户端可以访问 common 共享,且 common 必须是可以浏览的 > 用户 andy\n必须能够读取共享中的内容，需要的话，验证密码是 redhat\n\n== 9. 配置多用户 SMB 挂载\n\n在 system1 共享通过 SMB 目录 /devops 满足下列要求： > 1.共享名为 devops\n> 2.共享目录 devops 只能 group8.example.com 域中的客户端使用 >\n3.共享目录 devops 必须可以被浏览 > 4.用户 silene\n必须能以读的方式访问此共享，访问密码是 redhat > 5.用户 akira\n必须能以读写的方式访问此共享，访问密码是 redhat > 6.此共享永久挂载在\nsystem2.group8.example.com 上的 /mnt/dev 目录，并使用用户 silene\n作为认证任何用户，可以通过用户 akira 来临时获取写的权限\n\n== 10. 配置NFS服务\n\n在system1配置NFS服务，要求如下： >\n1.以只读的方式共享目录/public，同时只能被group8.example.com域中的系统访问\n>\n2.以读写的方式共享目录/protected，需要通过Kerberos安全加密，您可以使用下面URL提供的密钥\nhttp://server.group8.example.com/pub/keytabs/system1.keytab >\n3.目录/protected应该包含名为project拥有人为andres的子目录 >\n4.用户andres能以读写方式访问/protected/project\n\n== 11. 挂载一个NFS共享\n\n在system2上挂载一个system1.group8.example.com的NFS共享,并符合下列要求：\n> 1、/public挂载在下面的目录上：/mnt/nfsmount /protected\n挂载在下面的目录上：/mnt/nfssecure 并使用安全的方式，密钥下载URL如下： +\nhttp://server.group8.example.com/pub/keytabs/system2.keytab >\n2、用户andres能够在/mnt/nfssecure/project上创建文件 >\n3、这些文件系统在系统启动时自动挂载\n\n== 12. 实现一个 web 服务器\n\n在 system1 上配置一个站点 http://system1.group8.example.com/\n然后执行下述步骤： > 1、 从\nhttp://server.group8.example.com/pub/system1.html\n下载文件，并且将文件重名为 index.html 不要修改此文件的内容 > 2、 将文件\nindex.html 拷贝到您的 web 服务器的 DocumentRoot 目录下 > 3、 来自于\ngroup8.example.com 域的客户端可以访问此web服务 > 4、 来自于 my133t.org\n域的客户端拒绝访问此web服务\n\n== 13. 配置安全web服务\n\n为站点 http://system1.group8.example.com 配置TLS加密， >\n一个已签名证书从\nhttp://server.group8.example.com/pub/tls/certs/system1.crt 获取 >\n此证书的密钥从\nhttp://server.group8.example.com/pub/tls/private/system1.key 获取 >\n此证书的签名授权信息从\nhttp://server.group8.example.com/pub/tls/certs/ssl-ca.crt 获取\n\n== 14：配置虚拟主机\n\n在 system1 上扩展您的web服务器，为站点 http://www8.group8.example.com\n创建一个虚拟主机，然后执行下述步骤： > 1.设置 DocumentRoot 为\n/var/www/virtual > 2.从 http://server.group8.example.com/pub/www8.html >\n3.下载文件重名为index.html 不要对文件index.html 中的内容做任何修改 >\n4.将文件 index.html 放到虚拟主机的 DocumentRoot 的目录下 > 5.确保 andy\n用户能够在 /var/www/virtual 目录下创建文件\n\n注意：原始站点 http://system1.group8.example.com/\n必须仍然能够访问，名称服务器 server.group8.example.com 提供对主机名\nwww8.group8.example.com 的域名解析。\n\n== 15. 配置web内容的访问控制\n\n在您的system1\n上的web服务器的DocumentRoot目录下，创建一个名为private的目录，要求如下：\n> 1.从 http://server.group8.example.com/pub/private.html\n下载一个文件副本到这个目录，并且重命名为index.html. >\n2.不要对这个文件的内容做任何修改 > 3.从system1\n上，任何人都可以浏览private的内容，但是从其它系统不能访问这个目录的内容\n\n== 16，实现动态WEB 内容\n\n在 system1 上配置提供动态web内容，要求如下： > 1. 动态内容由名为\nwsgi.group8.example.com 的虚拟主机提供 > 2. 虚拟主机侦听在端口 8909 > 3.\n从 http://server.group8.example.com/pub/webinfo.wsgi\n下载一个脚本，然后放在适当的位置，无论如何不要求修改此文件的内容 > 4.\n客户端访问 http://wsgi.group8.example.com:8909/\n时，应该接收到动态生成的web页面 > 5. 此\nhttp://wsgi.group8.example.com:8909/ 必须能被 group8.example.com\n域内的所有系统访问\n\n== 17. 创建一个脚本\n\n在system1上创建一个名为/root/foo.sh的脚本，让其提供下列特性： > 1.\n当运行/root/foo.sh redhat,输出为fedora > 2. 当运行/root/foo.sh\nfedora,输出为redhat > 3.\n当没有任何参数或者参数不是redhat或者fedora时，其错误输出产生以下的信息：/root/foo.sh\nredhat:fedora\n\n在考试的时候注意看题目要求的创建的文件名称，如果不带sh后缀则不要加后缀，否则不得分。\n\n== 18. 创建一个添加用户的脚本\n\n在system1上创建一个脚本，名为 /root/mkusers\n,此脚本能实现为系统system1创建本地用户，并且这些用户的用户名来自一个包含用户名列表的文件，同时满足下列要求：\n> 1. 此脚本要求提供一个参数，此参数就是包含用户名列表的的文件 > 2.\n如果没有提供参数，此脚本应该给出下面的提示信息Usage：/root/mkusers然后退出并返回相应的值\n> 3. 如果提供一个不存在的文件名，此脚本应该给出下面的提示信息Input file\nnot found 然后退出并返回相应的值 > 4. 创建的用户登录shell为/bin/false >\n5. 此脚本不需要为用户设置密码 > 6.\n您可以从下面的URL中获取用户名列表作为测试用\nhttp://server.group8.example.com/pub/userlist\n\n在考试的时候注意看题目要求的创建的文件名称，如果不带sh后缀则不要加后缀，否则不得分。\n\n== 19. 配置ISCSI服务端\n\n配置system1提供一个ISCSI 服务磁盘名为 iqn.2014-08.com.example:system1\n并符合下列要求： > 1. 服务端口为3260 > 2.\n使用iscsi_store作其后端卷名称，其大小为3G > 3.\n此服务只能被system2.group8.example.com访问\n\n== 20. 配置ISCISI的客户端\n\n配置system2使其能链接在system1上提供的 iqn.2014-08.com.example:system1\n并符合以下要求： > 1. ISCISI设备在系统启动的期间自动加载 > 2.\n块设备ISCISI上包含一个大小为2100MIB的分区，并格式化为ext4 > 3.\n此分区挂载在/mnt/data上 同时在系统启动的期间自动挂载\n\n== 21. 配置一个数据库\n\n在 system1上创建一个Maria DB数据库，名为Contacts，并符合以下条件： > 1.\n数据库应该包含来自数据库复制的内容，复制文件的URL为 +\nhttp://server.group8.example.com/pub/users.mdb ，数据库只能被 localhost\n访问 > 2. 除了root用户，此数据库只能被用户Luigi查询，此用户密码为 redhat\n> 3. root 用户的数据库密码为 redhat，同时不允许空密码登录\n\n== 22. 数据库查询\n\n在系统 system1 上使用数据库 Contacts ，并使用相应的SQL\n查询以回答下列问题： > 1. 密码是 tangerine 的人的名字？ > 2.\n有多少人的姓名是 John 同时居住在 Santa Clara ？\n\n'''''\n\n____\n关于题库的重要提醒：\n1、考试时，有关url路径、用户名、密码、域名、ip等一定会不一样，请注意！\n2、有些目录比如/public等在考试时可能已经创建好，不需要再创建，请注意！\n3、有些软件包在考试时可能已经安装好，不需要再安装，请注意！\n一句话，就是一定不要死记题库中的目录、用户名、路径等这些可能变化的东西，而是记住解题步骤、思路，验证、及排错方法！\n____\n\n","fields":{"slug":"/articles/2018/02/28/1546344573952.html","birthTime":"2018-02-27T18:22:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"RHCE 2018 考试试题"}},{"content":"= [RHCE] 考试目录\n:page-description: RHCE 考试目录\n:page-category: rhce\n:page-image: https://img.hacpai.com/bing/20180707.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/03/01/1546344573160.html\n:page-created: 1519842180000\n:page-modified: 1546346416767\n:toc:\n\n* ☒ 1. 配置 SeLinux +\n* ☒ 2. 配置防火墙对 SSH 的限制\n* ☒ 3. 配置 IPV6 地址\n* ☒ 4. 配置链路聚合\n* ☒ 5. 自定义用户环境\n* ☒ 6. 配置本地邮件服务\n* ☒ 7. 配置端口转发\n* ☒ 8. 通过 SMB 共享目录\n* ☒ 9. 配置多用户 SMB 挂载\n* ☒ 10. 配置 NFS 服务\n* ☒ 11. 挂载一个 NFS 共享\n* ☒ 12. 实现一个 web 服务器\n* ☒ 13. 配置安全 web 服务\n* ☒ 14. 配置虚拟主机\n* ☒ 15. 配置 web 内容的访问\n* ☒ 16. 实现动态 web 内容 （新版已没有此题）\n* ☒ 17. 创建一个脚本\n* ☒ 18. 创建一个添加用户的脚本\n* ☒ 19. 配置 ISCSI 服务端\n* ☒ 20. 配置 ISCSI 客户端\n* ☒ 21. 部署 MariaDB 数据库\n* ☒ 22. 数据库查询填空\n\n","fields":{"slug":"/articles/2018/03/01/1546344573160.html","birthTime":"2018-02-28T18:23:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"[RHCE] 考试目录"}},{"content":"= tomcat 上配置二级域名\n:page-description: tomcat 上配置二级域名\n:page-category: 归档\n:page-image: https://img.hacpai.com/bing/20180514.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/03/04/1546344584354.html\n:page-created: 1520108340000\n:page-modified: 1546346452987\n:toc:\n\n____\n今天在 Tomcat 上配置二级域名，说实话，Tomcat 的 server.xml\n文件是我最不想碰的，上次真的被他搞出了阴影来。但是后面觉得还是有必要配一下，早晚都要经历的=-=所以还是花时间配置了。\n____\n\n== 环境\n\n一台已经安装好 Tomcat9 的 centos7 服务器，其使用 IP\n地址必须能够正常访问。已经配置好dns 解析的域名，能够 ping\n得通你所需要配置的二级域名。\n\n== 步骤\n\n进入 Tomcat9 目录下的 conf 文件夹，编辑 server.xml 文件。\n\n可选 ：寻找到标签 Connector ，将 port 设置为80\n\nimage:https://resources.echocow.cn/image/blog/tomcat.2.1.png[image]\n\n[source,xml]\n----\n<Connector port=\"80\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" \n           redirectPort=\"8443\" URIEncoding=\"UTF-8\" />\n----\n\n继续向下，寻找到 name 为 localhost 的 Host\n标签，修改为主域名（如www.echocow.cn），添加 port 等参数\n\nimage:https://resources.echocow.cn/image/blog/tomcat.2.2.png[image]\n\n端口号、协议等按需求填写\n\n[source,xml]\n----\n<Host name=\"www.echocow.cn\"  appBase=\"webapps\"  port=\"80\" protocol=\"HTTP/1.1\"\n    connectionTimeout=\"20000\" redirectPort=\"8443\" unpackWARs=\"true\" autoDeploy=\"true\">\n----\n\n第一个二级域名配置完毕，只是主要的二级域名。\n\n其他二级域名方法相同，只不过需要多添加一个 Host 标签，下面我添加一个\nyiban.echocow.cn 的二级域名。\n\nimage:https://resources.echocow.cn/image/blog/tomcat.2.3.png[image]\n\n其中 context 对应的其域名下的文件夹以及目录。这样既算是配置完毕\n\n[source,xml]\n----\n<Host name=\"yiban.echocow.cn\"  appBase=\"webapps\" port=\"80\" protocol=\"HTTP/1.1\"\n    connectionTimeout=\"20000\" redirectPort=\"8443\" unpackWARs=\"true\" autoDeploy=\"true\">\n    <Context path=\"/YBSeatOrder\" docBase=\"YBSeatOrder\" debug=\"0\" reloadable=\"true\" />\n    <Context path=\"/YBStore\" docBase=\"YBStore\" debug=\"0\" reloadable=\"true\" />\n</Host>\n----\n\nimage:https://resources.echocow.cn/image/blog/tomcat.2.4.png[image]\n\n如此，访问 yiban.echocow.cn/YBStore 即是访问 YBStore 这个项目了。\n\n","fields":{"slug":"/articles/2018/03/04/1546344584354.html","birthTime":"2018-03-03T20:19:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"tomcat 上配置二级域名"}},{"content":"= tomcat9 配置问题 403 Access Denied\n:page-description: tomcat9 配置问题 403 Access Denied\n:page-category: 归档\n:page-image: https://img.hacpai.com/bing/20180531.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/05/08/1546344578486.html\n:page-created: 1525778700000\n:page-modified: 1546346507343\n:toc:\n\n____\ntomcat9.0 管理页面如：http://10.10.10.10:8080/manager/html出现如下错误：\n____\n\n____\n*403 Access Denied*\n____\n\n== 1.需要配置：\n\nTomcat/conf/tomcat-users.xml加入：\n\n[source,xml]\n----\n <role rolename=\"manager\"/>     \n  <role rolename=\"admin\"/> \n  <role rolename=\"admin-gui\"/>\n  <role rolename=\"manager-gui\"/>\n  <user username=\"xxx\" password=\"***\" roles=\"admin-gui,manager-gui\"/>\n----\n\n以上配置好后本地可以访问，http://127.0.0.1:8080/manager/html\n\n== 2.另外，需要修改Tomcat/webapps/manager/META-INF/context.xml文件：\n\n[source,xml]\n----\n<Context antiResourceLocking=\"false\" privileged=\"true\" >\n  <!--\n    Remove the comment markers from around the Valve below to limit access to\n    the manager application to clients connecting from localhost\n  -->\n  \n  <Valve className=\"org.apache.catalina.valves.RemoteAddrValve\"\n\n         allow=\"127\\.\\d+\\.\\d+\\.\\d+|::1|0:0:0:0:0:0:0:1|\\d+\\.\\d+\\.\\d+\\.\\d+\" />\n  -</Context>\n----\n\n或注释Value节点（tomcat9.0以下默认是注释的，所以不需修改）\n\n[source,xml]\n----\n<!--\n  <Valve className=\"org.apache.catalina.valves.RemoteAddrValve\"\n         allow=\"127\\.\\d+\\.\\d+\\.\\d+|::1|0:0:0:0:0:0:0:1\" />\n  -->\n----\n\n____\n参考tomcat9.0文档：http://tomcat.apache.org/tomcat-9.0-doc/config/valve.html#Remote_Address_Filter\n____\n\n","fields":{"slug":"/articles/2018/05/08/1546344578486.html","birthTime":"2018-05-08T11:25:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"tomcat9 配置问题 403 Access Denied"}},{"content":"= windows powershell 自定义颜色\n:page-description: windows powershell 自定义颜色\n:page-category: 归档\n:page-image: https://img.hacpai.com/bing/20180828.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/05/22/1546344586774.html\n:page-created: 1526939400000\n:page-modified: 1546346501523\n:toc:\n\n折腾了二十多分钟终于改好了，真的好气。\n\n== 操作流程\n\n[arabic]\n. win+R->输入regedit->定位到HKEY_CURRENT_USERProcessor\n. 输入颜色对应的字符，可以输入两个，第一个表示背景颜色，第二个表示文本颜色；如果只输入一个，则只改变文本颜色。\n\n'''''\n\n== 颜色对应的character\n\n* 0=黑、8=灰\n* 1=蓝、9=淡蓝\n* 2=绿、A=淡绿\n* 3=湖蓝色、B=淡浅绿\n* 4=红、C=淡红\n* 5=紫、D=淡紫\n* 6=黄、E=淡黄\n* 7=白、F=亮白\n\n'''''\n\n== 示例\n\nimage::https://resources.echocow.cn/image/blog/windwos1.1.png[1]\n\n输入3e：即背景湖蓝色，文本淡黄色\n\n效果如下~~\n\nimage::https://resources.echocow.cn/image/blog/windwos1.2.png[2]\n\n即：输入3e，背景湖蓝色（3），文本淡黄色（e），效果如上所示。\n\n","fields":{"slug":"/articles/2018/05/22/1546344586774.html","birthTime":"2018-05-21T21:50:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"windows powershell 自定义颜色"}},{"content":"= 为什么 Github 没有记录你的 Contributions\n:page-description: 为什么 Github 没有记录你的 Contributions\n:page-category: 归档\n:page-image: https://img.hacpai.com/bing/20180212.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/07/18/1546344587551.html\n:page-created: 1531905360000\n:page-modified: 1546345801478\n:toc:\n\n____\n本文转载，出处未找到\n____\n\n最近在给同学看我的github时，突然发现我的Contributions\nGraph上一篇空白居然只有两三个小绿块，所以一直没发现个人repo的commit记录都没有被记录，于是外事不决问Google，发现原来是因为git初始化设定时没有设定正确的用户名和邮箱（主要是邮箱），具体可以参考Github官方写的help文档\n\n== 为什么你的 Contributions 没有在你的 Profile 里显示？\n\n那么问题来了，什么是Contributions呢，Github官网上有这么一句话 > Your\nprofile contributions graph is a record of contributions you’ve made to\n> GitHub repositories. Contributions are only counted if they meet\ncertain criteria. > In some cases, we may need to rebuild your graph in\norder for contributions to > appear. > > >\n你的个人简介中的贡献图记录的是你给Github上的仓库的贡献。它仅仅只记录某些符合标准\n>\n的commits。在某些情况下，我们需要重新建立你的贡献图以便让所有的贡献都显示出来。\n\n== 什么样的贡献才会被Github统计?\n\n英语好的同学请移步\nhttps://help.github.com/articles/why-are-my-contributions-not-showing-up-on-my-profile/[Why\nare my contributions not showing up on my profile?]\n\n=== Issues 和 pull requests\n\n* 这个操作是在一年之内\n* 这个操作是针对一个独立的仓库，不能是fork\n\n=== Commits\n\n当你的commits满足以下条件时，它才会被展示出来：\n\n* 一年之内提交的commits\n* commits使用的email地址是与你的Github账号相关联的\n* 这些commits是在一个独立的仓库而不是fork仓库\n* 这些commits是在：\n** 在默认分支上（通常是==master==）\n** 在==gh-pages==分支(包含\nhttps://help.github.com/articles/user-organization-and-project-pages/#project-pages[Project\nPages sites] 的仓库)\n\n此外，至少满足下面条件中的一个（主要针对你Commit的仓库不是你创建的）：\n\n* 你是这个仓库的协作者，或者是这个版本库的拥有组织中的一员\n* 你fork过这个仓库\n* 你对这个仓库发起过pull request或者issue\n* 你对这个仓库标记了Star\n\n____\n注意：私有库的贡献仅仅对私有库成员显示\n____\n\n== Contributions未被Github计入的几个常见原因\n\n* 进行Commits的用户没有被关联到你的Github帐号中。\n* 不是在这个版本库的默认分支进行的Commit。\n* 这个仓库是一个Fork仓库，而不是独立仓库。\n\n== 如何排查\n\n你可以在你的本地 repo 里用 ==git log== 命令查看 commit\n记录上的个人邮箱是否正确，像我就是因为之前切换到 Mac\n平台开发之后用户名没有配置，所以我之后的 commit 记录上的邮箱一直是\n==Leo@Leo-MacBook-Pro.local==，所以 Github 就会认为这些 commits\n都不是你提交的！\n\n== 补救措施\n\n然而这也并不是没有补救办法的，Github官网上就有给出详细的补救过程，英语好的同学请自行移步https://help.github.com/articles/changing-author-info/[Changing\nauthor info]，下面是我翻译自Github Help的简要步骤：\n\n== 变更作者信息\n\n为改变已经存在的 commits 的用户名和/或邮箱地址，你必须重写你 Git repo\n的整个历史。 > 警告： 这种行为对你的 repo 的历史具有破坏性。如果你的\nrepo\n是与他人协同工作的，重写已发布的历史是一种不好的习惯。仅限紧急情况执行该操作。\n\n使用脚本改变你 repo 的 Git 历史 我们写了一段能把 commit\n作者旧的邮箱地址修改为正确用户名和邮箱的脚本。\n\n=== 使用脚本来改变某个repo的Git历史\n\n我们已经创建了一个脚本，使用正确的姓名和电子邮件地址提交后，你以前提交的所有的commits中的作者信息及提交者字段中的旧的用户名和邮箱地址都将被更正\n\n____\n注意： 执行这段脚本会重写 repo 所有协作者的历史。完成以下操作后，任何\nfork 或 clone 的人必须获取重写后的历史并把所有本地修改 rebase\n入重写后的历史中。\n____\n\n在执行这段脚本前，你需要准备的信息：\n\n[arabic]\n. Mac、Linux下打开Terminal，Windows下打开命令提示符（command prompt）\n. 给你的repo创建一个全新的clone\n+\ngit clone –bare https://github.com/user/repo.git\n+\ncd repo.git\n. 复制粘贴脚本，并根据你的信息修改以下变量：==旧的Email地址==，==正确的用户名==，==正确的邮件地址==\n\n....\n#!/bin/sh\ngit filter-branch --env-filter '\nOLD_EMAIL=\"旧的Email地址\"\nCORRECT_NAME=\"正确的用户名\"\nCORRECT_EMAIL=\"正确的邮件地址\"\nif [ \"$GIT_COMMITTER_EMAIL\" = \"$OLD_EMAIL\" ]\nthen\n    export GIT_COMMITTER_NAME=\"$CORRECT_NAME\"\n    export GIT_COMMITTER_EMAIL=\"$CORRECT_EMAIL\"\nfi\nif [ \"$GIT_AUTHOR_EMAIL\" = \"$OLD_EMAIL\" ]\nthen\n    export GIT_AUTHOR_NAME=\"$CORRECT_NAME\"\n    export GIT_AUTHOR_EMAIL=\"$CORRECT_EMAIL\"\nfi\n' --tag-name-filter cat -- --branches --tags\n....\n\n[arabic, start=4]\n. 按 ==Enter键== 执行脚本。\n. 用 ==git log== 命令看看新 Git 历史有没有错误\n. 把正确历史 push 到 Github\n\n....\ngit push --force --tags origin 'refs/heads/*'\n....\n\n[arabic, start=7]\n. 删掉刚刚临时创建的 clone\n\n....\ncd ..\nrm -rf repo.git\n....\n\n== 如何正确设置你的 git 个人信息\n\n接下来全局设置好你的正确信息，以后就放心的用Github进行版本管理吧 ^_^\n\n....\ngit config --global user.email \"你的邮件地址\"\ngit config --global user.name \"你的Github用户名\"\n....\n\n查看你的Git全局设置信息 ==git config -l==\n\n....\nAir:slime admin$ git config -l\nuser.name=XXXXXX\nuser.email=XXXXXX@mail.com\ncore.repositoryformatversion=0\ncore.filemode=true\ncore.bare=false\ncore.logallrefupdates=true\ncore.ignorecase=true\nAir:slime admin$\n....\n\n转载请注明原文链接：http://xunli.xyz/2016/01/09/github-not-count/\n\n","fields":{"slug":"/articles/2018/07/18/1546344587551.html","birthTime":"2018-07-18T09:16:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"为什么 Github 没有记录你的 Contributions"}},{"content":"= CentOS7 tomcat 多域名 多应用 添加到 nginx\n:page-description: CentOS7 tomcat 多域名 多应用 添加到 nginx\n:page-category: 归档\n:page-image: https://img.hacpai.com/bing/20180815.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/09/08/1546344581233.html\n:page-created: 1536347820000\n:page-modified: 1546348524978\n:toc:\n\n最近遇到一个比较棘手的问题，以前给易班开发了两个应用 *网薪商城* 和\n*座位预约* ，都是使用 ssh 开发，是自己学习初期开发出来，将它部署在了\ncentos + tomcat 的环境上，域名对应我的二级域名 yiban.echocow.cn/YBStore\n和 yiban.echocow.cn/YBSeatOrder ，后面的路径对应不同的应用，用 tomcat\n做的多域名配置。而后面，又开发了一个 *易运动*\n应用，但是这个应用完全是前后端分离的，使用 nginx 代理静态页面，vertx\n做后端部署在服务器的 8000 端口，域名同样使用\nyiban.echocow.cn，引用对应的路径为 /YBSport\n\n== 前提\n\n目前已有的应用，部署在 tomcat 之上\n\n* tomcat admin —— admin.echocow.cn\n* 网薪商城 ———— yiban.echocow.cn/YBStore\n* 座位预约 ———— yiban.echoocw.cn/YBSeatOrder\n\n配置文件 server.xml 中 Service 如下\n\n[source,xml]\n----\n<Service name=\"Catalina\">\n  <Connector port=\"80\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\"  \n         URIEncoding='GBK' acceptCount=\"500\" maxThreads=\"400\"  maxHttpHeaderSize=\"8192\" />\n  <Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" />\n  <Engine name=\"Catalina\" defaultHost=\"localhost\">\n    <Realm className=\"org.apache.catalina.realm.LockOutRealm\">\n      <Realm className=\"org.apache.catalina.realm.UserDatabaseRealm\"\n           resourceName=\"UserDatabase\"/>\n      </Realm>\n    <!-- 管理员 -->\n    <Host name=\"admin.echocow.cn\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\">\n      <Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\"\n           prefix=\"localhost_access_log\" suffix=\".txt\"\n           pattern=\"%h %l %u %t &quot;%r&quot; %s %b\" />\n    </Host>\n    <!-- 易班 -->\n    <Host name=\"yiban.echocow.cn\" appBase=\"webapps/yiban\" port=\"80\" protocol=\"HTTP/1.1\"\n        connectionTimeout=\"20000\" redirectPort=\"8443\" unpackWARs=\"true\" autoDeploy=\"true\">\n        <Context path=\"/YBSeatOrder\" docBase=\"YBSeatOrder\" debug=\"0\" reloadable=\"true\" />\n        <Context path=\"/YBStore\" docBase=\"YBStore\" debug=\"0\" reloadable=\"true\" />\n    </Host>\n  </Engine>\n</Service>\n----\n\n有一个新应用 *易运动* ，部署在 nginx 上，配置如下：\n\n[source,conf]\n----\nserver {\n    listen 80;\n    server_name yiban.echocow.cn;\n    access_log  logs/yiban.access.log  main;\n    location /YBSport {\n        root    /root/yiban/;\n        index   index.html;\n    }\n}\n----\n\n== 问题\n\ntomcat 与 nginx 同时占用了 80 端口，只能舍掉一个，但是只能使用 nginx\n，因为 tomcat 对静态页面支持是没有 nginx 好的。\n\n*所以，我必须在 不改变原来应用 和 路径 的情况下，将 tomcat 部署到 nginx\n之中*\n\n== 解决\n\n一开始不打算修改 tomcat 的配置的，但是后来发现不修改不行。不能使用\ntomcat 的域名配置，只能使用 nginx 的域名配置，*然后将 tomcat\n的应用部署在本地不同端口上，使用 nginx\n对不同路径的应用进行重定向至其本地端口上。*\n\ntomcat server,xml修改配置文件如下：\n\n[source,xml]\n----\n<!-- 8080 端口 --- 管理员 -->\n<Service name=\"Catalina\">\n   <Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\"\n               redirectPort=\"8443\"  URIEncoding='GBK'\n              acceptCount=\"500\" maxThreads=\"400\"  maxHttpHeaderSize=\"8192\" />\n   <Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" />\n   <Engine name=\"Catalina\" defaultHost=\"localhost\">\n     <Realm className=\"org.apache.catalina.realm.LockOutRealm\">\n     <Realm className=\"org.apache.catalina.realm.UserDatabaseRealm\"\n         resourceName=\"UserDatabase\"/>\n     </Realm>\n     <!-- 部署到本地 -->\n     <Host name=\"localhost\"  appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\">\n        <Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\"\n             prefix=\"localhost_access_log\" suffix=\".txt\"\n             pattern=\"%h %l %u %t &quot;%r&quot; %s %b\" />\n     </Host>\n  </Engine>\n</Service>\n\n<!-- 8081 端口 --- 易班引用 -->\n<Service name=\"Catalina\">\n  <Connector port=\"8081\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\"  \n         URIEncoding='GBK' acceptCount=\"500\" maxThreads=\"400\"  maxHttpHeaderSize=\"8192\" />\n  <Connector port=\"8010\" protocol=\"AJP/1.3\" redirectPort=\"8443\" />\n  <!-- 部署到本地 -->\n  <Engine name=\"Catalina\" defaultHost=\"localhost\">\n    <Realm className=\"org.apache.catalina.realm.LockOutRealm\">\n    <Realm className=\"org.apache.catalina.realm.UserDatabaseRealm\"\n         resourceName=\"UserDatabase\"/>\n    </Realm>\n    <Host name=\"localhost\"  appBase=\"webapps/yiban\" port=\"80\" protocol=\"HTTP/1.1\"\n        connectionTimeout=\"20000\" redirectPort=\"8443\" unpackWARs=\"true\" autoDeploy=\"true\">\n        <Context path=\"/YBSeatOrder\" docBase=\"YBSeatOrder\" debug=\"0\" reloadable=\"true\" />\n        <Context path=\"/YBStore\" docBase=\"YBStore\" debug=\"0\" reloadable=\"true\" />\n    </Host>\n  </Engine>\n</Service>\n----\n\n这样，对应下来就是\n\n[cols=\",\",options=\"header\",]\n|===\n|应用 |url\n|管理员 |localhost:8080\n|网薪商城 |localhost:8081/YBStore\n|座位预约 |localhost:8081/YBSeatOrder\n|===\n\nnginx 就可以对其交给不同的端口的应用来处理了：\n\n[source,conf]\n----\nserver {\n    listen 80;\n    server_name yiban.echocow.cn;\n    access_log  logs/yiban.access.log  main;\n    # 易运动\n    location /YBSport {\n        root    /root/yiban/;\n        index   index.html;\n    }\n    # 网薪商城\n    location /YBStore {\n        proxy_pass http://127.0.0.1:8081/YBStore;\n        proxy_redirect default;\n    }\n    # 作为预约\n    location /YBSeatOrder/ {\n        proxy_pass http://127.0.0.1:8081/YBStore;\n        proxy_redirect default;\n    }\n}\n----\n\n这样就能实现 nginx 即代理静态页面又代理 tomcat 了。\n\n","fields":{"slug":"/articles/2018/09/08/1546344581233.html","birthTime":"2018-09-07T19:17:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"CentOS7 tomcat 多域名 多应用 添加到 nginx"}},{"content":"= eclipse 快捷方式 打开报错\n:page-description: eclipse 快捷方式 打开报错\n:page-category: 归档\n:page-image: https://img.hacpai.com/bing/20181119.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/09/09/1546344576907.html\n:page-created: 1536489420000\n:page-modified: 1546347664220\n:toc:\n\n今天室友重装系统，所有软件重新安装，然后安装到 eclipse\n的时候，发现快捷方式无法打开，但是在 eclipse 的目录下可以打开\neclipse.exe，很是奇怪。\n\n== 问题\n\n打开快捷方式报错如下：\n\nimage::https://resources.echocow.cn/image/blog/questions/eclipse1.1.png[错误啦]\n\n然后我将 eclipse.exe 复制到桌面也不行，报错如下：\n\nimage::https://resources.echocow.cn/image/blog/questions/eclipse1.2.png[错误啦]\n\n但是打开安装目录的 eclipse.exe 是没有问题的:\n\nimage::https://resources.echocow.cn/image/blog/questions/eclipse1.3.jpg[成功打开]\n\n== 解决办法\n\n查看出错原因，发现问题\n\nimage::https://resources.echocow.cn/image/blog/questions/eclipse1.4.jpg[查看原因]\n\n去寻找目录，对比文件\n\nimage::https://resources.echocow.cn/image/blog/questions/eclipse1.5.png[对比]\n\n发现文件夹名不对，修改文件夹的名字\n\nimage::https://resources.echocow.cn/image/blog/questions/eclipse1.6.png[修改]\n\n再次打开，成功！\n\nimage::https://resources.echocow.cn/image/blog/questions/eclipse1.7.jpg[修改]\n\n","fields":{"slug":"/articles/2018/09/09/1546344576907.html","birthTime":"2018-09-09T10:37:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"eclipse 快捷方式 打开报错"}},{"content":"= idea Error:failed to create a child event loop.\n:page-description: idea Error:failed to create a child event loop.\n:page-category: 归档\n:page-image: https://img.hacpai.com/bing/20180321.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/09/09/1546344585141.html\n:page-created: 1536448020000\n:page-modified: 1546347667853\n:toc:\n\n今天学弟安装 idea 的时候遇到一个问题：*idea Error:failed to create a\nchild event loop.*\n\nimage::https://resources.echocow.cn/image/blog/other/1.1.png[idea错误]\n\n然后日志报错： > Cannot start internal HTPP server…..\n\nimage::https://resources.echocow.cn/image/blog/other/1.2.png[日志错误]\n\n== 解决办法\n\n按照提示，应该是被防火墙拦截了，于是寻找 windows 的防火墙\n\nimage::https://resources.echocow.cn/image/blog/other/1.3.png[firewall]\n\n检查防火墙状态\n\nimage:https://resources.echocow.cn/image/blog/other/1.4.jpg[image]\n\n点击左侧 允许应用或功能通过 windows defender 防火墙\n\nimage:https://resources.echocow.cn/image/blog/other/1.5.jpg[image]\n\n点击右下侧 允许其他程序，添加 idea。\n\n按道理来说这样就可以了，但是后面给学弟运行的时候 jdk\n又报错，还是需要重复的操作配置 jdk。于是想用其他的办法解决。\n\n== 其他办法\n\n点击左侧 启用或关闭 windows defender 防火墙\n\nimage:https://resources.echocow.cn/image/blog/other/1.6.jpg[image]\n\n我将它们全部禁用\n\nimage:https://resources.echocow.cn/image/blog/other/1.7.jpg[image]\n\n然后发现，可以运行了\n\nimage:https://resources.echocow.cn/image/blog/other/1.8.png[image]\n\n但是不可能禁用他的防火墙啊，因为还是希望使用到的，所以我又使用推荐设置开启了防火墙\n\nimage:https://resources.echocow.cn/image/blog/other/1.9.jpg[image]\n\n防火墙自动开启\n\nimage:https://resources.echocow.cn/image/blog/other/1.10.jpg[image]\n\n开启以后发现，idea 依旧可以正常使用\n\n== 总结\n\n其实我也不太清楚原因，我的猜测是\n先去添加应用通过，添加了后，idea是可以的，但是后面发现 jdk报错，检查 jdk\n是在 d\n盘，我还要单独配置jdk通过防火墙配置，很麻烦。于是，我尝试先关闭了防火墙，让idea能够建立了连接能够通过防火墙，然后再开启防火墙，他就默认能够通过防火墙了。这样防火墙还是在的。\n\n== 问题\n\n如果 windows\n更新，或者其他的防火墙操作，那么这个就会失效，还会报一样的错。\n\n如果有哪位大佬能够解决，望告知。！\n\n","fields":{"slug":"/articles/2018/09/09/1546344585141.html","birthTime":"2018-09-08T23:07:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"idea Error:failed to create a child event loop."}},{"content":"= vmware 克隆 CentOS7 后 网络配置\n:page-description: vmware 克隆 CentOS7 后 网络配置\n:page-category: 归档\n:page-image: https://img.hacpai.com/bing/20181002.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/09/11/1546344581641.html\n:page-created: 1536616800000\n:page-modified: 1546347657839\n:toc:\n\n____\n在上一篇文章中说到了新建虚拟机，然后进行配置 主机名 + 静态\nIP。这一篇我们将要使用 vmware 的克隆功能进行虚拟机的克隆以及重新配置 IP\n地址。\n____\n\n环境： - 已配置好网络的虚拟机一台 - 配置好的 nat\n\n== 克隆虚拟机\n\n=== 1. 关闭虚拟机，右键创建克隆\n\nimage:https://resources.echocow.cn/image/blog/hodoop/2.1.png[image]\n\n=== 2. 克隆\n\n==== 2.1. 克隆向导\n\nimage::https://resources.echocow.cn/image/blog/hodoop/2.2.png[克隆向导]\n\n==== 2.2. 克隆当前状态（可自己创建快照，创建快照时状态）\n\nimage:https://resources.echocow.cn/image/blog/hodoop/2.3.png[image]\n\n==== 2.3. 创建完整克隆\n\nimage:https://resources.echocow.cn/image/blog/hodoop/2.4.png[image]\n\n==== 2.4. 设置虚拟机名字\n\nimage:https://resources.echocow.cn/image/blog/hodoop/2.5.png[image]\n\n==== 2.5. 开始克隆\n\nimage:https://resources.echocow.cn/image/blog/hodoop/2.6.png[image]\n\n==== 2.6. 克隆完成\n\nimage:https://resources.echocow.cn/image/blog/hodoop/2.7.png[image]\n\n==== 2.7. 新的一个虚拟机\n\nimage:https://resources.echocow.cn/image/blog/hodoop/2.8.png[image]\n\n=== 3. 重新生成 MAC 地址（重要）\n\n==== 3.1. 编辑虚拟机设置\n\nimage:https://resources.echocow.cn/image/blog/hodoop/2.9.png[image]\n\n==== 3.2. 选择 NAT - 高级\n\nimage:https://resources.echocow.cn/image/blog/hodoop/2.10.png[image]\n\n==== 3.3. 生成\n\nimage:https://resources.echocow.cn/image/blog/hodoop/2.11.png[image]\n\n==== 3.4. 记下新的 MAC 地址\n\nimage:https://resources.echocow.cn/image/blog/hodoop/2.12.png[image]\n\n=== 4. 打开并登录新的虚拟机，查看网络还是上一台的\n\nimage:https://resources.echocow.cn/image/blog/hodoop/2.13.png[image]\n\n=== 5. 配置网络（重要）\n\n==== 5.1. 修改配置文件\n\nimage:https://resources.echocow.cn/image/blog/hodoop/2.14.png[image]\n\n==== 5.2. 修改 IP 地址\n\nimage:https://resources.echocow.cn/image/blog/hodoop/2.15.png[image]\n\n==== 5.3. 修改 UUID，添加/编辑 MAC 地址\n\nimage:https://resources.echocow.cn/image/blog/hodoop/2.16.png[image]\n\n=== 6. 测试\n\nimage:https://resources.echocow.cn/image/blog/hodoop/2.17.png[image]\n\n____\n当然，也可以使用 命令行 修改，但是单词太长，命令也长，所以我就不写啦。\n____\n\n== 问题\n\n=== Q 我没记住新的 MAC 地址怎么办？\n\n[arabic]\n. 可以在不关闭虚拟机的情况下，右键虚拟机的名字\nimage:https://resources.echocow.cn/image/blog/hodoop/2.18.png[image]\n. 如下所示\nimage:https://resources.echocow.cn/image/blog/hodoop/2.19.png[image]\n\n","fields":{"slug":"/articles/2018/09/11/1546344581641.html","birthTime":"2018-09-10T22:00:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"vmware 克隆 CentOS7 后 网络配置"}},{"content":"= vmware 安装 CentOS7 + 主机名 + 配置静态 ip\n:page-description: vmware 安装 CentOS7 + 主机名 + 配置静态 ip\n:page-category: 归档\n:page-image: https://img.hacpai.com/bing/20181215.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/09/11/1546344587216.html\n:page-created: 1536613080000\n:page-modified: 1546347660678\n:toc:\n\n____\n学习 Hadoop ，第一件事就是需要有 linux 环境，因为他最好的运行环境是\nlinux，而我们的选择，是在服务器端占有一席之地的 centos7\n操作系统。作为老牌稳定的服务器系统，是非常值得我们花时间去学习的。\n____\n\n环境说明： - 虚拟机：vmware - 操作系统：centos7 - 网络连接：NAT -\n网络配置：静态 ip\n\n== 在这之前\n\n我们需要稍微配置下 vmware 的 nat （why？为了以后出现问题方便统一纠正）\n\n=== 1. 打开编辑\n\nimage::https://resources.echocow.cn/image/blog/hodoop/1.1.png[编辑]\n\n=== 2. 打开虚拟网络编辑器\n\nimage::https://resources.echocow.cn/image/blog/hodoop/1.2.png[虚拟网络编辑器]\n\n=== 3. 修改子网 IP\n\nimage::https://resources.echocow.cn/image/blog/hodoop/1.3.png[修改子网\nIP]\n\n=== 4. 修改 DHCP\n\n修改 DHCP 设置的 IP 地址段\n\nimage::https://resources.echocow.cn/image/blog/hodoop/1.4.png[DHCP 设置]\n\n=== 5. 修改 NAT 设置的网关 IP\n\nimage::https://resources.echocow.cn/image/blog/hodoop/1.5.png[NAT 设置]\n\n=== 6.新建虚拟机\n\nimage::https://resources.echocow.cn/image/blog/hodoop/1.6.png[新建]\n\n____\n虚拟机的简历过程我就不多赘述。重点在于网络配置\n____\n\n== CentOS7 安装\n\n=== 1. 查看网卡配置是否为 NAT\n\nimage::https://resources.echocow.cn/image/blog/hodoop/1.7.png[编辑虚拟机设置]\n\nimage::https://resources.echocow.cn/image/blog/hodoop/1.8.png[查看网络适配器]\n\n=== 2. 选择最小化安装\n\nimage::https://resources.echocow.cn/image/blog/hodoop/1.9.png[最小化]\n\n=== 3. 选择安装硬盘\n\nimage::https://resources.echocow.cn/image/blog/hodoop/1.10.png[安装硬盘]\n\n=== 4. 配置网络（重点）\n\nimage::https://resources.echocow.cn/image/blog/hodoop/1.11.png[点击网络配置]\n\n==== 4.1 configure\n\n点击右下角 configure\n\nimage::https://resources.echocow.cn/image/blog/hodoop/1.12.png[configure]\n\n==== 4.2 配置 ipv4\n\nimage::https://resources.echocow.cn/image/blog/hodoop/1.13.png[配置\nipv4]\n\n==== 4.3 具体配置\n\n选择方式，设置 ip、掩码、网关、dns，配置完成后，右下角 save\n\nimage::https://resources.echocow.cn/image/blog/hodoop/1.14.png[具体配置]\n\n==== 4.4 开启网络\n\n获取IP地址（图上多打了一个i），设置主机名，左上角保存\n\nimage::https://resources.echocow.cn/image/blog/hodoop/1.15.png[开启网络]\n\n=== 5. 开始安装\n\nimage::https://resources.echocow.cn/image/blog/hodoop/1.16.png[开始安装]\n\n=== 6. 添加密码\n\nimage::https://resources.echocow.cn/image/blog/hodoop/1.17.png[添加密码]\n\n== 检查网络\n\n如果你 *电脑通网的* ，尝试\n`ping www.baidu.com`，出现如下信息，网络配置成功\n\nimage:https://resources.echocow.cn/image/blog/hodoop/1.18.png[image]\n\n== 问题\n\n=== Q：忘记了第四步就安装了怎么办？\n\n==== 解决办法一：修改配置文件\n\n[arabic]\n. 切换到网卡文件目录 `cd /etc/sysconfig/network-scripts/`，查看目录文件\n`ls`\nimage:https://resources.echocow.cn/image/blog/hodoop/1.20.png[image]\n. 编辑文件 `vim ifcfg-ens33`，按下 `i`\n进入编辑模式，修改`BOOTPROTO=\"dhcp\"` 为 `BOOTPRTO=none`\nimage:https://resources.echocow.cn/image/blog/hodoop/1.21.png[image]\n. 下方添加如下内容，其中 IPADDR 可以自定义 128-255 区间\nimage:https://resources.echocow.cn/image/blog/hodoop/1.22.png[image]\n. 重启网络，尝试 `ping www.baidu.com`\nimage:https://resources.echocow.cn/image/blog/hodoop/1.23.png[image]\n\n==== 解决办法二：使用命令修改\n\n此方法只要一条命令即可，如下\n\n[source,shell]\n----\nnmcli con modify ens33 ipv4.method static ipv4.addr 192.168.112.159/24 ipv4.gateway 192.168.112.2 ipv4.dns 192.168.112.2 connection.autoconnect yes\n----\n\n然后重启网络，ping 一下即可\n\n....\nsystemctl restart network\nping www.baidu.com\n....\n\n=== Q：vi 如何保存退出？\n\n==== 解决办法\n\n当你编辑完成后，按下 `ESC` ，然后输入冒号 `:` ，再输入\n`wq`，即可保存退出。\n\n=== Q：主机名忘记修改如何修改？\n\n查看主机名\n\nimage:https://resources.echocow.cn/image/blog/hodoop/1.24.png[image]\n\n或者输入 `hostname`\n\nimage:https://resources.echocow.cn/image/blog/hodoop/1.25.png[image]\n\n==== 解决办法一：修改配置文件\n\n[arabic]\n. 修改配置文件 `vi /etc/hostname`,保存退出 `:wq`\n. 重启即可\n\n==== 解决办法二：使用命令修改\n\n[arabic]\n. 使用如下命令\n\n....\nhostnamectl set-hostname 主机名\n....\n\n[arabic, start=2]\n. 重启即可\n\n=== Q：ping 以后一直跳出 64 byte…？\n\n==== 解决办法\n\n你只要 按下 `ctrl + c` 即可结束 ping。\n\n","fields":{"slug":"/articles/2018/09/11/1546344587216.html","birthTime":"2018-09-10T20:58:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"vmware 安装 CentOS7 + 主机名 + 配置静态 ip"}},{"content":"= manjaro 笔记\n:page-description: manjaro 笔记\n:page-category: linux\n:page-image: https://img.hacpai.com/bing/20181118.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/09/16/1546344571882.html\n:page-created: 1537050660000\n:page-modified: 1546400963133\n:toc:\n\n____\n这些天有点心力憔悴，被manjaro完虐。\n____\n\n周二的时候不知道抽啥风，可能是忍不了那么乱的 windows\n吧，然后下定决心要直接装 linux，于是在众多的发行版中，选择力 arch 系的\nmanjaro。原本第一打算是 ubunto 系的 deepin\n的，但是朋友推荐了这款包管理方面排名第一并且还好用的\nmanjaro。不得不说我是一个懒人，在知道他强大的包后，就下定决心安装他了。\n\n来看一张包的对比图（2018-3）\n\nimage::https://resources.echocow.cn/image/blog/manjaro/1.1.png[对比]\n\n顺手报了一个计算机二级，本想在二级考完以后再重装，但是实在刷不下去二级的题目，然后在前天忍不住就提前安装了这个系统。然后就一直被虐到今天=-=\n\n先来看看这些天安装下来的成果吧。\n\n== 成果\n\n=== 桌面\n\n目前比较满意的一款，配合右侧工具可随时查看自己电脑的状态\n\nimage::https://resources.echocow.cn/image/blog/manjaro/1.4.png[桌面]\n\n=== 浏览器\n\n依旧 chrome ，更醒后这种简洁风简直美如画！\n\nimage::https://resources.echocow.cn/image/blog/manjaro/1.5.png[浏览器]\n\n=== ide\n\n自己的开发环境自然要打扮一番！\n\nimage::https://resources.echocow.cn/image/blog/manjaro/1.6.png[idea1]\n\nimage::https://resources.echocow.cn/image/blog/manjaro/1.8.png[idea2]\n\n=== 配置\n\n系统配置感觉还不错\n\nimage::https://resources.echocow.cn/image/blog/manjaro/1.7.png[配置]\n\n== 问题\n\n自己折腾这个系统感觉都花了很长时间，遇到了各种各样的问题，自己也慢慢一个一个解决，选了几个典型的将它记录下来。。。\n\n=== 显卡问题\n\n不得不说，大多数的硬件厂家对 linux 的系统并不是那么友好的，我的配置是 i7\n6700HQ + GTX960M\n的笔记本，在第一次安装的时候顺利得一塌糊涂，就是分区的时候纠结了会儿，这个后面说道，不过第一次真的很顺利的安装成功了。不过后面开机后总是卡死，键盘鼠标没动静。。。后来没办法只有重新安装，而后面的安装出现的第一个问题就是显卡问题，导致进不去安装页面。后来就是各种百度，也一一解决了问题，不过自己也找到了一种解决办法。（用的ubunto的方法）\n\n[arabic]\n. 安装时 在 `BOOT： Manjaro.x86_64 ....` 摁下 `E` ，然后 在`quiet`\n后面添加 `nouveau.modeset=0` ，然后 摁下 F10 即可进入安装界面了。\n. 修改 `/etc/default/grub` ，然后第四行 `quiet` 后面添加\n`nouveau.modeset=0` ，重启即可。\n\n当然我也找到了其他可行的方法，比如修改 driver 为 intel ，或者添加\nacpi_osi 都行，不过网上都有记载就不一一重复了。\n\n=== 双硬盘问题\n\n自己的配置是 `256G + 1T`，但是 manjaro\n提供的只是单硬盘分区，这很烦，系统安装在了 固态\n里面，另外一个机械硬盘当然不能不用，而且 256\n确实很小啊。网上没找到解决方案，就在自己苦恼的时候，突然想到一种方法：\n\n[arabic]\n. 使用 256G 的存放系统\n. 然后 1T 的将它挂载上去，划分逻辑卷\n. 将文档还有占用大的放在 1T 里面，256 就存放系统的所有东西即可。\n\n所以目前我的分区是这样的\n\nimage::https://resources.echocow.cn/image/blog/manjaro/1.10.png[分区]\n\n总结下来是这样的 - 500 G —> hdd_software 挂载到 /opt 目录 ——> pacman\n默认安装目录 - 500 G —> hdd_documents 挂载到/documents 目录 ——>\n用来存放大文件的\n\n这样就合理利用起来了 1T 的空间，现在如下\n\nimage::https://resources.echocow.cn/image/blog/manjaro/1.11.png[分区]\n\n","fields":{"slug":"/articles/2018/09/16/1546344571882.html","birthTime":"2018-09-15T22:31:00.000Z","modifiedTime":"2019-01-02","year":2018},"document":{"title":"manjaro 笔记"}},{"content":"= drcom 校园网教师帐号爆破工具\n:page-description: drcom 校园网教师帐号爆破工具\n:page-category: 归档\n:page-image: https://img.hacpai.com/bing/20180608.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/09/29/1546344583151.html\n:page-created: 1538222040000\n:page-modified: 1546347650084\n:toc:\n\n== DrcomTools\n\nDrcom\n校园网爆破工具，https://github.com/lizhongyue248/DrcomTools[GITHUB] 地址\n\n=== 简述\n\n首先感谢两位大佬 FGR，https://rainss.cn[RAINSS]\n带我，告诉我规律，然后自己抓包分析，解密密码，在得出这个程序，用于暴力破解校园网教师网。\n\n*不过值得注意的是，我删除了网址（每个学校情况不一样）,同时密码加密方式可能不一样，请自行抓包分析。。。*\n\n运行此程序之前，你必须要知道你们教师网的帐号和密码的规律，并知道那几个数字段较多。然后抓包分析加密方式，我们的是加了几个数字然后\nmd5 加密，你只需要抓包后反解密就大概能找到规律了。\n\n可以在运行一个 `web` 的时候，运行多个 `server` ，测试同时开五个\n`server`，一个 `web`，十分钟爆破十万个帐号（因电脑性能而异）\n\n____\n注意，最好不要跑太多，不然怕被查水表。\n____\n\n=== 技术选型\n\n* 核心框架：vertx-core\n* 依赖管理：maven\n* 开发工具：idea\n* *java：jdk 8（务必）*\n* web：vertx-web\n* 集群：vertx-hazelcast\n* 日志：JUL\n\n=== 如何运行\n\n[arabic]\n. 找到校园网登录网页，见下方的截图，复制网址至\n`cn.echocow.drcom.utils.Constant` ，替换 url 中的字符串\n. 先运行 `server`，再运行 `web`，可以直接在 `cn.echocow.drcom.web`\n运行，也可以运行多次 `cn.echocow.drcom.Application`。\n. 生成的日志文件存放于当前用户的家目录下\n\n* windows 见 `C：//user/用户名/Drcom.log`\n* linux 见 `/home/用户名/Drcom.log`\n\n运行多个会在 `log` 加.1，例如 Drcom.log.1、Drcom.log.2。\n\n=== 截图\n\n我们的 drcom 官网：\n\nimage::https://resources.echocow.cn/image/blog/zaxiang/1.1.png[加密方式]\n\n我校加密方式：\n\nimage::https://resources.echocow.cn/image/blog/zaxiang/1.2.png[drcom]\n\n运行结果：\n\nimage::https://resources.echocow.cn/image/blog/zaxiang/1.3.png[运行结果]\n\n=== 免责申明\n\n*本程序仅供技术交流，请勿用于商业及非法用途，如产生法律纠纷与本人无关！*\n\nCREATE BY https://echocow.cn[ECHOCOW]\n\n","fields":{"slug":"/articles/2018/09/29/1546344583151.html","birthTime":"2018-09-29T11:54:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"drcom 校园网教师帐号爆破工具"}},{"content":"= 基于 spring boot + thymeleaf + jpa 增删改查登录注册demo\n:page-description: 基于 spring boot + thymeleaf + jpa 增删改查登录注册demo\n:page-category: 归档\n:page-image: https://img.hacpai.com/bing/20171225.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/10/12/1546344581866.html\n:page-created: 1539299340000\n:page-modified: 1546347646164\n:toc:\n\n前段时间一直在看 spring\nboot，但是一直没有动手去实战。这段时间才有时间，正好趁着学校 需要交一个\njava 增删改查登录注册 的实例，原要求要使用 servlet + jsp 来做，但是因为\n自己以前写 servlet\n挺多了，如果不去看源码再写进步应该不大，所以想着使用以前一直想学的\nspring boot 做一套，所以才有了这个 demo。\n\n一开始打算使用前后段分离,前端用 nginx 反向代理静态页面，然后使用 redis\n存储 session， 后端就是 spring-boot 提供 RestFul 风格提供 API\n调用即可。但是最近事情真的多，所以做 了一个 ``阉割版''\n的，前后端半分离，为什么叫做半分离呢？因为我初始化页面还是使用了模板引擎\n但是请求的时候依旧使用 ajax 调用 api\n接口动态生成页面元素，不过前端依旧没有脱离后端独立 部署运行。\n\n== 技术选型\n\n* 开发工具： IntelliJ IDEA\n* 核心框架： spring-boot\n* 模板引擎： thymeleaf\n* 构建工具： maven 3.3.9\n* 构建插件： mvnw\n* 数据库： mysql\n* 持久层： spring-data-jpa\n* 验证码： kaptcha\n* 缓存： redis\n* 前端： jquery3 + bootstrap4 + bootbox4\n\n== 使用\n\n[arabic]\n. 在你的 IDE 中导入项目，然后使用 maven 导入依赖，如果 maven\n版本相差过大导致程序不能正常 运行，可以使用 mvnw 插件自动下载符合的\nmaven 版本，windows 请运行 `mvnw.cmd`，linux 或 mac 请运行 `mvnw`\n. 配置文件见\n`src/main/resources/application.yml`，修改自己的数据库链接和 redis\n链接， *如果链接信息填写正确，数据库会自动建表，无需导入 sql。*\n. 然后运行 `src/main/java/cn/echocow/web/WebApplication.java` 即可\n\n== 运行简述\n\n=== 登录注册\n\n[arabic]\n. 入口处进入 `/index` 即 `MainController` 的 `index` 方法,\n判断是否登录，没有登录就不 设置任何东西直接跳转到 `index.html`, 使用\nthymeleaf 判断有用户，没有就显示登录注册按钮。\n. 点击登录， `/login` 即 `MainController` 的 `login`\n方法，直接跳转到登录页面 `login.html`, 同时图形验证码请求 `/captcha` 即\n`UtilController` 获取验证码图片。填写完成后使用 form 表单直接 POST\n提交到 `/login` 即 `MainController` 的 `postLogin`\n方法，在里面进行验证登录。\n* 如果登录失败，携带 `msg` 返回页面，同时前端模板引擎判断 `msg`\n是否显示并提示。\n* 如果登录成功直接跳转\n. 登录成功后，又跳转 `1` 中的 `/index` 即 `MainController` 的 `index`\n方法，由于登录了， 所以请求后端数据，然后携带后端数据返回 `index.html`\n页面，前端模板引擎判断然后显示列表。登录流\n程即跑通了，注册、退出都是同理。\n\n=== 增删改查简述\n\n在增删改查中\n\n* 增、查使用的是 模板引擎\n* 删、改使用的是 ajax 提交，然后用 jq 控制元素的显示与删除\n\n为什么这么做？\n\n不管嘛。。。反正我喜欢。。。就像前面说的，一开始想前后端分离，但是又涉及到了认证、授权、跨域一堆问题，\n然后又没时间，所以决定用模板引擎，为啥后面又用 ajax\n了呢。。。因为要跳转页面实在不想让他有那么多跳转， 写多了 ajax\n后真的会有依赖，异步真的是个好东西，可能这就是我为啥会喜欢 vert.x\n的原因吧。\n\n=== 其他简述\n\n* config 配置类，其中配置了登录拦截器、验证码生成\n* controller 控制器，里面包含拦截器和 api\n* entity 实体类，包括了统一响应\n* repository jpa、crud 接口实现\n* service 服务提供\n\n== 总结\n\n感觉比起来还是比较喜欢 vert.x 前面写了个基于 vert.x 的易班应用\nhttps://github.com/GZMZ-YIBAN/YBSport-vertx[易运动]\n,感觉还是喜欢那种开发方式。不过真的，spring\n的生态链实在太强大，基本上我遇到的问题网上都能够找到完美的\n解决方案，虽然质量参差不齐，但是总归比 vert.x 一搜不到一页来得爽太多。\n\n无 xml 配置简直让我爱不释手，注解基本解决了大多问题，不论是 servlet 3.1\n还是 servlet 4.0 都感觉没 有 spring boot 来得爽，果然 java EE 后端被\nspring 系列占有大部分市场是有原因的。\n\n期末的时候打算使用 vue + spring boot\n做个后台管理系统，如果有时间会引入第三方登录，一直很想做的一个\n东西。这段时间太忙，只能匆匆做一个交给老师了，质量不是很高，很多东西没有做，比如全局异常捕获都没做。。。\n\nhttps://github.com/lizhongyue248/SpringBootPractice[Github]\n\n© 2017-2018 By: https://www.echocow.cn[EchoCow]\n\n","fields":{"slug":"/articles/2018/10/12/1546344581866.html","birthTime":"2018-10-11T23:09:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"基于 spring boot + thymeleaf + jpa 增删改查登录注册demo"}},{"content":"= 基于 vertx web 应用 YBSport-vertx\n:page-description: 基于 vertx web 应用 YBSport-vertx\n:page-category: 归档\n:page-image: https://img.hacpai.com/bing/20180213.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2018/10/18/1546344582189.html\n:page-created: 1539819360000\n:page-modified: 1546347641551\n:toc:\n\n== YBSport\n\n易运动，通过易班app所记录的每日步数可兑换相应的网薪。\n\n== 简介\n\n你还在为没有网薪发愁吗？民大易运动上线啦~现在，你只要在走路或跑步的时候开启易班app并给予权限，把它放在后台，将会自动记录你每日运动的步数哦~通过这个步数每天可以兑换一定数量的网薪！网薪可以去网薪商城兑换各种实物哦！还有其他更好玩儿的用途等你来发现！只要开启APP运动简单一步即可获得定量的网薪！快来行动吧，一起易运动！\n\n____\n应用地址:http://yiban.echocow.cn/YBSport[贵民大易运动]\n\n*测试帐号：15585291942*\n\n*测试密码：LZY574196898*\n____\n\n== 技术选型\n\n* 核心框架: vert.x web、vert.x web client\n* 配置管理: vert.x conf\n* 单元测试: junit4、vert.x unit\n* 反向代理: nginx\n* 数据库: postgreSQL 10\n* 日志：log4j2\n* 前端：mui\n\n== 使用\n\n本应用为我校 易班工作站\n开发，需要提供易班工作站的接口和用户信息方能使用。\n\n环境：nginx + idea + postgresql 10\n\n=== nginx 配置\n\nnginx\n用于反向代理静态页面，http://nginx.org/en/download.html[官网下载地址]\n\nwindows 可以直接 http://nginx.org/download/nginx-1.15.2.zip[下载]\n\nCentos7 可以借鉴此教程\nhttp://note.youdao.com/noteshare?id=c0e4bb495ad5ade62a546f4efc7773c2&sub=wcp1535266273108984[Centos7安装Nginx实战\n- 阿豪聊干货 - 博客园]\n\n其他 linux 发行版需要自行寻找教程。\n\nnginx 需要配置端口号和起始路径,请查看 conf/nginx.conf\n\n[source,text]\n----\n我的如下配置：\n\n    server {\n        listen       8001;\n        server_name  localhost;\n\n        location / {\n           root   E:\\work\\yiban\\YBWorkSpace\\YBSport\\YBSport-UI;\n           index  index.html index.htm;\n        }\n    }\n    \n其中 8001 为你 nginx 反向代理页面的端口号\n----\n\n=== idea 配置\n\nclone 下此项目后默认没有配置模块，请自行在 project structure 进行配置。\n\n依赖管理使用 maven，请在 idea 中自行引入 import 依赖\n\n请修改 YBSport-web / src / main / resources / conf / config-bak.json\n配置文件，并重命名为 config.json\n\n然后，修改 UI 模块的 index.html 中 ajax 请求的地址端口为 你配置\nconfig.json 中 http 下的 port 端口号，默认 8888\n\n如果你需要修改日志输出位置（默认当前系统用户家目录/logs/YbSport/），请修改\nlog4j2.xml 即可\n\n[source,xml]\n----\n<Properties>\n    <property name=\"log_charset\">UTF-8</property>\n    <property name=\"log_pattern\">\n        %d{yyyy-MM-dd HH:mm:ss} [%5p] [%t] (%F:%L) %m%n\n    </property>\n    <!--修改此处-->\n    <property name=\"logBaseFolder\">${sys:user.home}/logs/YbSport/</property>\n    <property name=\"every_file_size\">100MB</property>\n</Properties>\n----\n\n=== 数据库配置\n\n数据库我用惯了 mysql，想尝试下新的，所以选择了 postgresql。\n\n三张表：ybsport_buy、ybsport_time、ybsport_type\n\n* ybsport_buy 易运动兑换记录：用来记录哪些兑换了\n* ybsport_time\n易运动活动开始时间：用来记录什么时候开始什么时候结束，可以选择为长期活动\n* ybsport_type 易运动兑换的类型：记录了可以兑换哪些类型。\n\n数据库结构文件存放于 doc/sql 下，可能需要你手动绑定下 *ybsport_buy.type*\n和 *ybsport_type.id* 的外键信息\n\n____\n注意:在 sql 文件中,我将他的所有者给了 yiban\n这个用户，可能你需要手动修改下，例如修改 alter table ybsport_type owner\nto yiban 为你希望的用户\n____\n\n____\n注意:ybsport_time 里面每次数据库都只查询第一条启用的数据，如果此数据的\n*备注* 字段为 *长期* ，那么易运动\n这个活动就是长期新的，否则就是指定时间内的，如果没有启用的数据，那么默认活动未开启。\n____\n\n____\n注意:ybsport_buy 中的 yb_user 字段为 json 格式\n____\n\n=== 基于易班使用\n\n请登录 https://open.yiban.cn/[易班开放平台] ，然后完成以下操作 1.\n注册账户 -> 申请成为开发者 2. 上方导航 管理中心 -> 左侧 轻应用 ->\n创建轻应用 3. 填写资料时，维护地址可不填，应用地址为\nhttp://localhost:8001，8001 即为你配置的 nginx 的端口号。 4. 进入\n管理中心 -> 轻应用 -> 你创建的应用 -> 点击名字 进入到应用详情，获取到\n*AppID* , *AppSecret* 和 *站内地址* 5. 将获取到的 *AppID* , *AppSecret*\n, *站内地址* 填入 *cn.echocow.yiban.ybsport.utils.ConstEnum* 中 6. 修改\n易班防跨站伪造参数 为你指定的值 7. 运行 nginx 、postgresql 、idea 中运行\ncn.echocow.yiban.ybsport.Application\n\n____\n注意：如果要在电脑端查看，请 修改应用 -> 使用场景 ->\n兼容易班客户端、PC/手机浏览器\n____\n\n=== 脱离易班使用\n\n由于接口是由易班提供，所以暂无法脱离易班使用。\n\n== Home\n\n他们都说，易班都不给经费了，还帮他写啥。但是其实，我感觉我在帮我自己。每一次完整的写完一个应用，都会有不同的体验，才会真正的经历过一次项目完整的\n0\n到有，这个过程到最后一刻，都是很让人满足的。你看着自己的成品通过了审核，心理也是同样美滋滋的，并且每一个作品，都在见证你的成长。所以虽然没有钱，但是如果这个应用真的符合我的理念，那么我依旧还会去做的。\n\n=== 前言\n\n易运动是我非常想做的一个项目，从五月底开始就一直很想做，当时一时兴起做好了前端，不得不说我前端功底不怎么样，但是却意外的达到了我期望的效果，让我十分喜欢。所以从几个月前就想做的。当时的技术选型就是\nmui +\nvert.x，但是不得不说我的实力有限，还不能很好的理解其异步思想，虽然说现在也是有点模糊，但是勉强写的出来了。放假实习完毕后，回来家的第一件事就是完成自己想做的这个应用，以前了解过vert.x也自己看过相关的资料，\n但不得不说思想的转变是极其困难的，需要时间和努力去不断熏陶。直到今天都只是入门，然后磕磕碰碰的写出了第一个模块\n*YBSport-web* ，其对应的前端\n*YBSport-UI*。但是中间也出现很多很多问题，也算是解决了，能够写出成品来，还是很开心的。\n\n* https://github.com/GZMZ-YIBAN/YBSport/wiki/Api[Api]\n* https://github.com/GZMZ-YIBAN/YBSport/wiki/YBSport-UI[YBStore-UI]\n* https://github.com/GZMZ-YIBAN/YBSport/wiki/YBSport-web[YBSport-web]\n\n== Api\n\n本页主要说明了请求的 Api 接口,所有交互均是 json 格式\n\n=== 获取当前是否在活动时间内或者长期\n\n* 接口描述：用来判断用户是否可以兑换\n* 请求路径：/status\n* 请求方式：GET\n* 请求参数：无\n* 返回结果示例:\n\n[source,json]\n----\n{\n  \"code\": \"请求代码\",\n  \"msg\": \"请求结果\",\n  \"data\": {\n    \"body\": \"boolean 是否在活动时间内\",\n    \"start\": \"活动开始时间\",\n    \"end\": \"活动结束时间\",\n    \"long\": \"是否是长期活动\"\n    }\n  }\n}\n----\n\n* 补充：此接口首先判断 body 是否在时间内，然后再判断 long\n是否为长期活动，如果是，就不读取 start 和\nend。如果不是，就读取并显示出来。\n\n=== 获取可兑换的类型信息\n\n* 接口描述：获取兑换类型的数据，生成可兑换类型的按钮\n* 请求路径：/\n* 请求方式：GET\n* 请求参数：\n\n[source,json]\n----\n{\n    \"verify_request\" : \"加密授权参数\",\n    \"state\" : \"易班防跨站伪造参数\"\n} \n----\n\n* 返回结果示例:\n\n[source,json]\n----\n{\n  \"code\": \"请求代码\",\n  \"msg\": \"请求结果\",\n  \"data\": {\n    \"list\": [\n      {\n        \"id\": \"主键\",\n        \"needSteps\": \"需要的步数\",\n        \"getMoney\": \"花费的网薪\"\n      },\n      {\n        \"id\": \"主键\",\n        \"needSteps\": \"需要的步数\",\n        \"getMoney\": \"花费的网薪\"\n      }\n    ]\n  }\n}\n----\n\n=== 获取当前步数以及最近三十天的运动步数\n\n* 接口描述：获取易班运动数据，初始化图和运动数据。\n* 请求路径：/steps\n* 请求方式：GET\n* 请求参数：\n\n[source,json]\n----\n{\n    \"verify_request\" : \"加密授权参数\",\n    \"state\" : \"易班防跨站伪造参数\"\n}\n----\n\n* 返回结果示例:\n\n[source,json]\n----\n{\n  \"code\": \"请求代码\",\n  \"msg\": \"请求结果\",\n  \"data\": {\n    \"sport_steps\": \"今日运动步数\",\n    \"date_time\": \"今日时间\",\n    \"list\": [\n      {\n        \"sport_steps\": \"步数\",\n        \"date_time\": \"时间\"\n      },\n      {\n        \"sport_steps\": \"步数\",\n        \"date_time\": \"时间\"\n      }\n    ]\n  }\n}\n----\n\n=== 获取已经兑换的列表信息\n\n* 接口描述：获取已近数据，初始化兑换记录。\n* 请求路径：/buyList\n* 请求方式：GET\n* 请求参数：\n\n[source,json]\n----\n{\n    \"verify_request\" : \"加密授权参数\",\n    \"state\" : \"易班防跨站伪造参数\"\n}\n----\n\n* 返回结果示例:\n\n[source,json]\n----\n{\n  \"code\": \"请求代码\",\n  \"msg\": \"请求结果\",\n  \"data\": {\n    \"sport_steps\": \"今日运动步数\",\n    \"date_time\": \"今日时间\",\n    \"list\": [\n      {\n        \"date\": \"兑换时间\",\n        \"get_money\": \"获得网薪\",\n        \"is_enable\": \"是否已经发放\"\n      },\n      {\n        \"date\": \"兑换时间\",\n        \"get_money\": \"获得网薪\",\n        \"is_enable\": \"是否已经发放\"\n      }\n    ]\n  }\n}\n----\n\n=== 发起兑换\n\n* 接口描述：发起兑换请求\n* 请求路径：/buy\n* 请求方式：POST\n* 请求参数：\n\n[source,json]\n----\n{\n    \"verify_request\" : \"加密授权参数\",\n    \"state\" : \"易班防跨站伪造参数\",\n    \"parameter.typeId\": \"兑换类型\",\n    \"parameter.sportSteps\": \"兑换步数\"\n}\n----\n\n* 返回结果示例\n\n[source,json]\n----\n{\n  \"code\": \"请求代码\",\n  \"msg\": \"请求结果\",\n  \"data\": {\n    \"status\": \"success | failed 是否成功\",\n    \"message\": \"如果失败，回显信息\"\n    }\n  }\n}\n----\n\n== YBSport-UI\n\n本着前后端分离，模块化开发的思想，将前后端分离开发，提供接口 API\n，然后前端对接收到的数据进行处理即可。 事实上自己也是如此开发，以 nginx\n进行静态页面反向代理，ajax 请求数据。\n\n但是存在的一个问题就是就是跨域问题，一旦解决了跨域问题就能够很好的解决所有的问题。\n\n=== 遇到的坑\n\n==== 错误处理\n\n本不是前端开发人员，所以自然不了解前端对请求会遇到哪些错误。一开始选用时使用简化版的\najax 请求处理\n`javascript 1.5 mui.post('http://server-name/login.php',{         username:'username',         password:'password'     },function(data){         // 服务器返回响应，根据响应结果，分析是否登录成功；         // ...     },'json' );`\n但是后来发现，一旦网络出现问题，或者服务器响应时间过长，就不会有任何回显信息，会很尴尬的等待。所以我更换为有异常处理和超时等待的\najax 请求\n`javascript 1.5 mui.ajax('http://server-name/login.php',{     data:{         username:'username',         password:'password'     },     dataType:'json',// 服务器返回json格式数据     type:'post',// HTTP请求类型     timeout:10000,// 超时时间设置为10秒；     headers:{'Content-Type':'application/json'},                       success:function(data){         // 服务器返回响应，根据响应结果，分析是否登录成功；         // ...     },     error:function(xhr,type,errorThrown){         // 异常处理；         console.log(type);     } });`\n\n这样，当处理出现不可预期问题的时候，也可以对客户端进行友好的提示。\n\n==== 易班内置浏览器引入他库\n\n在我和国睿测试投票系统的时候，遇到的一个问题就是当我点击一个按钮的时候，出现多次触发时间的情况，卡了很久。最后国睿对其进行抓包分析，\n发现了易班app在启动内置浏览器的时候自动引入了 zepto 库，我对此发起过提问\n\n[source,text]\n----\nQ：您好，我们开发的时候遇到易班APP的问题，希望给予回复，谢谢。 \n\n1易班app内置浏览器加载了zepto库，但是其中的某些方法与应用冲突，请问有什么办法禁止易班内置浏览器加载这个库？\n\n2易班app内置浏览器在关闭时会删除cookie，请问有什么办法保存或者类似cookie可以保存对象方式？\n\n提问时间 : 2018-06-04 22:00:55\nA：您好。\n\n1、该问题的确与开放平台相关设计期望不符，已向易班app开发组传达问题意见，但经过沟通目前易班app内置浏览器容器业务耦合程度较大，需要一个长时间的优化或者重构的评估规划。请开发者暂时寻找其它方案避免（比如自定义JS编写）；\n\n2、关闭内置浏览器清除cookie是合理的安全机制，应用端可自行对cookie内容或功能标示存储。\n\n回答时间 : 2018-06-05 11:00:02\n----\n\n当初我负责的是前端页面处理，所以不得已我只能去适配客户端，目前发现的只有一个\n点击事件 发生冲突，重复绑定的情况。\n`javascript 1.5 // mui提供的绑定,为 tap 事件，同时 zepto 也是同样 tap 绑定，造成重复绑定 mui(document.body).on(\"tap\", \"#help\", function () {     // code })`\n所以我加入的识别易班浏览器的方法，以其自动适应用 tap 还是 click 绑定\n`javascript 1.7 let cli; navigator.userAgent.indexOf(\"yiban_android\") > (-1) ? cli = \"click\" : cli = \"tap\"; // 绑定 mui(document.body).on(cli, \"#help\", function () {     // code })`\n为什么不直接用 click 呢？就是任性~~~就想用 tap，然后用此方法防止冲突。\n\n==== JavaScript 兼容性问题\n\n这次开发应用就是遇到此问题，在我在电脑上，我的手机上（华为P9），测试均正常，然后测试云磊的手机，也是正常，但是却发现在某些手机上不能正常显示。\n比如红米note，还有夜神模拟器。排查了几个小时，发现了一个问题，一直报的的语法错误语法错误语法错误，我重复检查前端半天，也是没找到什么错了，\n最后尝试把 `let` 和 `const` 改回 `var` ，就正常了。\n\n我想了想，发现目前易班app使用的是用户手机操作系统自带的浏览器内核，如果目前用户手机系统自带的浏览器内核较低，是不支持\nes6 的，所以需要去做适配。\n\n当然如果不使用 es6 自然可以忽略此问题了。\n\n=== 感受\n\n前端基本就这些了，六月初的时候就写完一部分，现在由于需求的增加，比如侧边栏，历史计步，兑换记录这些的添加又自己去改页面，当然是很笨的处理方法。\n不过感觉前端所见即所得的方式比后端来的有趣多，各种语法糖还是很不错的。这是目前为止我写得最满意的一个前端了！虽然很简陋，但是我真心喜欢。\n\n== YBSport-web\n\n前面说过，很早前就接触了 vert.x ，但是当初只有 ssh\n的经验，并且也是照着教程做的，感觉自己提升还是不高。在接触到这个框架的时候，查阅资料是十分困难的，\n在国内的环境下感觉学起来很吃力，后来翻墙找了更多的资料学习，不过其实都没有视频学得容易。自己不断尝试，不断地改变思想，让自己去适应异步的氛围，每一步学习都是自己查的资料。\n不得不说这样学起来很累，但是真的，提升真的很大。不论是从问题查找，代码风格还是思维方面，都提升了很多。他的性能与支持也没有让我失望，但是自己还是初步入门，\n并没有真正领悟到他的核心，还需要不断地努力。\n\n=== 异步处理\n\n==== 多 Verticle 部署\n\n项目开始的时候，深受**横向切割**的思想影响，所以将他分为了两个 Verticle\n，一个作为路由发送 eventBus\n，一个接受并处理数据。但是实在自己思想局限，将所有的请求的处理都放在了一个\nVerticle 里面，所有的数据处理都放在了一个 Verticle\n里，所以造成的结果就是一个 class\n十分冗长，甚至一个方法十分冗长。按照**横向切割**的思想，应该包如下：\n\n[source,text]\n----\nloginService\n  |—— LaginVerticle\n  |—— LoginDbVerticle\ninfoService\n  |—— InfoVerticle\n  |—— InfoDbVerticle\n\n...\n----\n\n我觉得我的理解实在不够深刻，一直没有想通有多个Verticle时候如何一起部署。。。而且当时的自己过于急躁，如今看下来结构实在不忍直视。。。而异步中如何处理两个\nVerticle\n呢？我当初找到的办法是在确认一个部署成功后，再依次部署第二个，如下：\n\n....\nFuture<String> dbVerticleDeployment = Future.future();\n        vertx.deployVerticle(new ConvertDbVerticle(), dbVerticleDeployment.completer());\n        dbVerticleDeployment.compose(id -> {\n            Future<String> convertRestVerticleDeployment = Future.future();\n            vertx.deployVerticle(\n                    ConvertRestVerticle.class.getName(),\n                    new DeploymentOptions().setInstances(1),\n                    convertRestVerticleDeployment.completer());\n            return convertRestVerticleDeployment;\n        }).setHandler(ar -> {\n            if (ar.succeeded()) {\n                startFuture.complete();\n            } else {\n                startFuture.fail(ar.cause());\n            }\n        });\n....\n\n而在 Application 中直接部署 Application 即可。但是不够优雅，这是 vertx\n的一个官网示例，但是却还是不明白多个 Verticle\n如何处理。。。希望大神解答。\n\n==== 配置读取\n\n学习此框架的核心，无非就是 *事件驱动* 和\n*异步处理(非阻塞)*。我一开始写的时候遇到的一个问题就是思想的转变，使用\nvert.x conf 模块进行读取 json 配置文件，\n但是由于是异步的，本着学习的思想，不用 jdk\n自带的读取配置文件。所以遇到的一个问题就是异步处理不关心他的结果便向下执行，我因此在\nstackoverflow 上\nhttps://stackoverflow.com/questions/51999544/in-vert-x-why-do-static-methods-run-before-static-code-blocks[提问]，\n当然并没有很好地解决问题，遇到错误的概率还是很大，不过我还是采纳了他，因为的确给了我一定的思想。后来我依旧没有办法将他读取的方法独立为一个静态方法，所以只有将它放于代码中执行。\n\n[source,text]\n----\nConfigFactory.retriever.getConfig(res -> {\n    if (res.succeeded()) {\n        JsonObject httpConfig = res.result().getJsonObject(\"http\");\n        server.requestHandler(router::accept)\n                .listen(httpConfig.getInteger(\"port\"), httpConfig.getString(\"host\"),\n                        listenResult -> {\n                            if (listenResult.failed()) {\n                                LOGGER.error(\"Http Server failed!\" + listenResult.cause());\n                            } else {\n                                LOGGER.info(\"Http Server started on \" + httpConfig.getString(\"host\") + \":\" + httpConfig.getInteger(\"port\") + \"!\");\n                            }\n                        });\n    } else {\n        LOGGER.error(\"Config get error! Something went wring during getting the config!\" + res.cause());\n        throw new RuntimeException(\"Config get error! Something went wring during getting the config\");\n    }\n});\n----\n\n保证执行成功后才执行后面的代码，这是一开始处理异步的方式。\n\n==== 事务管理\n\n可以说这是我这个应用的败笔吧，我没有做事务处理。也就是说涉及到多个sql操作数据的时候，其中一个失败而另外一个成功，会造成数据不统一。不过在我的程序中，没有同时操作数据的sql存在，而是多个查询语句后只有一个数据操作，而我需要对查询出来的数据进行判断后再决定是否操作数据。而在不断的操作数据库的时候又面临回调地狱的问题所所以我选择使用\nFuture 来避免回调地狱\n\n....\nFuture<SQLConnection> connectionFuture = Future.future();\nFuture<ResultSet> dateFuture = Future.future();\nFuture<ResultSet> compareFuture = Future.future();\nFuture<ResultSet> queryFuture = Future.future();\nFuture<UpdateResult> updateFuture = Future.future();\n....\n\n异步查询数据，然后让每个 Future 接受处理结果，再单独拿出来 setHandler\n处理数据，这样就避免了回调地狱。\n\n==== 结果合并\n\n当我在 ConvertDbVerticle 接受 eventBus 接收到数据的时候，我希望返回的\nJsonObject 包含多个从数据库查询出来的结果，例如 getInfo 方法中我希望获得\n`ybsport_type` 和 `ybsport_buy` 表的数据然后合并至 JsonObject 的 reply\n之中，但是数据查询是异步的，如何处理呢？我选择使用了 CompositeFuture 的\nall 方法进行组合，只有当两个异步查询都成功的时候，才能够执行 all\n的回调函数，然后在 all 的回调函数里面为 reply 填充结果即可。\n\n....\nCompositeFuture.all(typeResult, userResult).setHandler(results -> {\n    if (results.succeeded()) {\n        LOGGER.info(\"Both results are ready for use!\");\n        JsonObject t = results.result().resultAt(0);\n        JsonObject u = results.result().resultAt(1);\n        reply.mergeIn(t);\n        reply.mergeIn(u);\n        message.reply(reply);\n    } else {\n        reportQueryError(message, results.cause(), \"Both or one result attempt failed!\");\n    }\n});\n....\n\n此时返回过去的 reply 即是一个合并力两个异步查询的结果集了。\n\n=== 日志处理\n\nvert.x 默认使用的日志处理的是 JDK 内置的 JUL\n，但是其输出方式我改了好久都不满意，而且资料太少，所以自己引入了他的日志框架，一开始打算引入\nslf4j，后来还是使用了 log4j ，不过需要修改他的默认配置，如下：\n\n....\n    System.setProperty(\"vertx.logger-delegate-factory-class-name\",\n            \"io.vertx.core.logging.Log4j2LogDelegateFactory\");\n....\n\n=== DNS 解析缓慢或错误\n\n由于易班使用的 oauth\n接口，我需要跳转到回调页面，但是发现解析他的域名的时候十分缓慢，查询后才发现他使用的\ngoogle 的 dns 解析，所以需要禁用他默认的 DNS，使用系统默认的 DNS 解析。\n\n....\n    System.getProperties().setProperty(DISABLE_DNS_RESOLVER_PROP_NAME, \"true\");\n....\n\n=== 字符串转 JSON 对象\n\n自己当初阅历有限，傻傻的一个属性一个属性的遍历存放，其实应该使用 jackson\n来进行更好的处理的，自己写了一个 StringToPojoJson 实在太笨。\n\n== Documentation\n\n请查看 https://github.com/GZMZ-YIBAN/YBSport/wiki[wiki] 以了解更多信息\n\n== 应用截图\n\n我在 UI 模块提供 `static.html`\n可以直接看到成功的前端效果演示。当然现在也已经上线 易班应用广场 可以直接\nhttp://yiban.echocow.cn/YBSport/[查看]\n\nimage::https://resources.echocow.cn/image/blog/%E9%A1%B9%E7%9B%AE/show.gif[avatar]\n\n","fields":{"slug":"/articles/2018/10/18/1546344582189.html","birthTime":"2018-10-17T23:36:00.000Z","modifiedTime":"2019-01-01","year":2018},"document":{"title":"基于 vertx web 应用 YBSport-vertx"}},{"content":"= 新年新气象，博客迁移，迎来 solo！\n:page-description: 新年新气象，博客迁移，迎来 solo！\n:page-category: 感想\n:page-image: https://img.hacpai.com/bing/20180703.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2019/01/01/1546349681570.html\n:page-created: 1546352388717\n:page-modified: 1548583135268\n:toc:\n\n好久没有更新博客啦！～一部分原因是期末了作业多事情多，还有一部分是\nhexo-admin\n真的让人头疼，访问速度感人。自己选了很多博客系统，选择的博客有那么点要求\n\n[arabic]\n. 好看！必须的。\n. 我能够自定义！\n. 能够方便管理的（自从用过hexo后觉得这很重要，毕竟我不是部署在 github\n上而是自己的服务器）\n. 能够支持自己的 七牛云 更好啦！\n. 必须支持 markdown\n. 上手简单\n\n自己找了好多博客，wordpress、typecho 这些动态博客，还有 hexo\n静态博客，都试过了，但是都没有满足上面几个条件的，特别是由于只会java和前端的缘故（逃，最后今年九月发现了一款基于\njava 的一款小而美的博客系统\nhttps://github.com/b3log/solo[solo]，都要动手换了，但是发现没有太喜欢的皮肤，所以在https://github.com/b3log/solo/issues/12449[皮肤推荐]中推荐了一款\nhttps://github.com/ahonn/hexo-theme-even[hexo-even]，当初就是因为这款主题用上了\nhexo，宁愿受点苦都要用这个主题(可见一款好的皮肤真的会吸引人的哈哈哈)，原本打算等\nV姐 出了后自己就立刻换的（自己前端真的渣），但是在这次 12 月发布的\nhttps://github.com/b3log/solo/releases/tag/v2.9.7[2.9.7]\n版本上，加了一个新的皮肤\nJane！简直太棒了，在放假作业完成后，立刻花时间把他安排到了我的服务器上，不论前台还是后台，速度都是很给力！不过中间也大大小小的遇到些问题，记录下～～\n\n____\n服务器配置：centos7.2 + jdk8 + nginx 使用端口：8765\n访问地址：https://echocow.cn\n____\n\n== 服务器部署\n\n[arabic]\n. 使用 scp 复制 war 包到服务器\n\n....\n scp solo-2.9.7.war  root@**.**.***.**:/root/\n....\n\n[arabic, start=2]\n. 输入密码复制，然后创建 solo 文件夹并解压 war 包\n\n....\nmkdir solo\nmv solo-2.9.7.war solo\ncd solo/\njar -xvf solo-2.9.7.war\n....\n\n[arabic, start=3]\n. 修改配置文件\n\n....\ncd WEB-INF/classes/\nvim latke.properties\n\n#### Server ####\n# Browser visit protocol\nserverScheme=https\n# Browser visit domain name 最终要访问的路径\nserverHost=echocow.cn\n# Browser visit port, 80 as usual, THIS IS NOT SERVER LISTEN PORT! 我使用 https ，所以指定 443\nserverPort=443\n\n\nvim local.properties\n# 添加自己数据库的密码，我使用mysql数据库\n....\n\n[arabic, start=4]\n. 登录数据库创建 solo 库\n\n....\n>>> create database solo;\n....\n\n[arabic, start=5]\n. 开启后台服务\n\n....\n# 通过 -lp 选项指定部署在 8765 端口\nnohup java -cp \"WEB-INF/lib/*:WEB-INF/classes\" org.b3log.solo.Starter -lp 8765 >/dev/null 2>&1 &\n....\n\nsolo 也就算部署完毕啦\n\n____\n为什么不用 tomcat？因为我自己的 tomcat\n已经部署多个应用并且还要去修改配置文件，十分麻烦，所以选择这种方式运行，8080端口被tomcat使用，由nginx\n转发，443、80 端口被 nginx 使用，所以随便选了一个 8765 端口进行部署。\n____\n\n== hexo 迁移\n\n____\n不得不说最棒的就是提供了 hexo 的迁移，让我省去好多功夫！\n____\n\n直接复制 hexo 下的 source 文件夹到 solo/markdown 即可\n\n....\n# 我直接移动过去了=-=\nmv source ../solo/\n# 然后终于可以停止掉慢出翔的 hexo-admin 啦\n[root@EchoLZY blog]# ps -ef | grep hexo\nroot       647 29099  0 22:34 pts/1    00:00:00 grep --color=auto hexo\nroot     15475 27799  0  2018 ?        00:50:17 node /root/blog/hexo_run.js\nroot     15481 15475  0  2018 ?        00:05:35 hexo\n[root@EchoLZY blog]# kill -9 15475\n[root@EchoLZY blog]# kill -9 15481\n....\n\n== nginx 配置\n\n____\n要求，支持 https 访问。同时访问 http://echocow.cn\n、http://www.echocow.cn 、https://www.echocow.cn 都直接转到\nhttps://echocow.cn 上面去\n____\n\n[arabic]\n. 由于以前配置 hexo 的时候已经配置好了 ssl 证书，所以需要改动的只有\nlocation 那里，对于 http://echocow.cn 、http://www.echocow.cn\n、https://www.echocow.cn 这三个都是用重定向即可，如下：\n\n....\nserver {\n        listen       80;\n        server_name  echocow.cn, www.echocow.cn;\n        access_log  logs/http_echocow.access.log  main;\n        location / {\n           return 301 https://echocow.cn$request_uri;\n        }\n}\n\nserver {\n        listen       443;\n        server_name  www.echocow.cn;\n        ssl_certificate   cert/www.echocow.cn.crt;\n        ssl_certificate_key  cert/www.echocow.cn.key;\n        access_log  logs/https_www_echocow.access.log  main;\n        location / {\n           return 301 https://echocow.cn$request_uri;\n        }\n}\n....\n\n[arabic, start=2]\n. 配置 https://echocow.cn\n\n....\nserver {\n    listen 443 ssl;\n    server_name echocow.cn;\n    ssl_certificate   cert/echocow.cn.crt;\n    ssl_certificate_key  cert/echocow.cn.key;\n    access_log  logs/https_echocow.access.log  main;\n    # 以前的 hexo 配置\n    #location / {\n    #    root   /usr/local/nginx/html/public;\n    #    index index.html index.htm;\n    #}\n    # 现在的 solo 配置\n    location / {\n        proxy_pass http://127.0.0.1:8765$request_uri;\n        proxy_set_header  Host $host:$server_port;\n        proxy_set_header  X-Real-IP  $remote_addr;\n        client_max_body_size  10m;\n    }\n}\n....\n\n[arabic, start=3]\n. 重启 nginx 即可\n\n....\ncd /usr/local/nginx/sbin\n./nginx -s reload\n....\n\n== 问题\n\n=== 从 hexo 迁移过来的数据时不时包 nginx 502 错误，\n\n[arabic]\n. 查看 access 日志没有发现什么，查看 nginx error 日志发现错误如下\n\n....\ntail /var/log/nginx/error.log\n2019/01/01 21:18:55 [error] 24232#0: *112566 upstream sent too big header while reading response header from upstream, client: 1.48.57.4, server: echocow.cn, request: \"GET /articles/2018/02/12/1546344575473.html?pjax=true HTTP/1.1\", upstream: \"http://127.0.0.1:8765/articles/2018/02/12/1546344575473.html?pjax=true\", host: \"echocow.cn\", referrer: \"https://echocow.cn/\"\n2019/01/01 21:18:55 [error] 24232#0: *112566 upstream sent too big header while reading response header from upstream, client: 1.48.57.4, server: echocow.cn, request: \"GET /articles/2018/02/12/1546344575473.html HTTP/1.1\", upstream: \"http://127.0.0.1:8765/articles/2018/02/12/1546344575473.html\", host: \"echocow.cn\", referrer: \"https://echocow.cn/\"\n....\n\n[arabic, start=2]\n. `sent too big header`说得很明确，发送太大的头了，所以配置下nginx.conf\n\n....\nvim conf/nginx.conf\n# 在http块内添加如下\nproxy_buffer_size  128k;\nproxy_buffers   32 32k;\nproxy_busy_buffers_size 128k;\n....\n\n=== 页面渲染问题\n\n使用默认的渲染引擎造成的结果就是，中间含有代码块有序列表全部都是1所以不得已要使用\nmarked 进行渲染。\n\n....\ncd solo\nnpm install marked --save\nnohup node js/marked/http.js >/dev/null 2>&1 &\n# 自定义的 solo 启动别名，直接启动\nsolo\n....\n\n效果就好多啦\n\n== 总结\n\n总的来说还算顺利，部署加搭建前后一个小时不到吧，感觉solo还是挺友好的，后台方面也好，分类也好，都挺不错，话说他的陪图功能简直大爱！唯一有个缺点就是搜索好丑啊哈哈哈。自己看看有没有能力改再说吧。2019\n来了，再见了 2018.\n\n____\n再见,2018,有得有失。 你好,2019,与君共勉。\n____\n\n","fields":{"slug":"/articles/2019/01/01/1546349681570.html","birthTime":"2019-01-01T14:19:48.717Z","modifiedTime":"2019-01-27","year":2019},"document":{"title":"新年新气象，博客迁移，迎来 solo！"}},{"content":"= spring security + gradle + spring mvc 模板化配置\n:page-description: spring security + gradle + spring mvc 模板化配置\n:page-category: spring\n:page-image: https://img.hacpai.com/bing/20190205.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2019/01/02/1546395090197.html\n:page-created: 1546395938298\n:page-modified: 1546412533326\n:toc:\n\n以前自己一直被安全的问题困扰，对这方面知识欠缺，最近学习了 spring\nsecurity，发现其实也别有一番洞天。写了一个简单\ndemo放在博客上，以便随用随取。\n\n目录结构如图\n\nimage::https://resources.echocow.cn//file/2019/01/74b6f15719c44d858fbd0aedc0d79751___20190102101236.png[__20190102101236png]\n\n附上对应的文件，已经写好了注释\n\n== SpringMvcInitializer\n\n[source,java]\n----\npackage cn.echocow.spring;\n\nimport cn.echocow.spring.config.RootConfig;\nimport cn.echocow.spring.config.WebConfig;\nimport org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;\n\n/**\n * 继承 AbstractAnnotationConfigDispatcherServletInitializer，在 servlet 3.0 环境中\n * 容器会在类路径中查找实现 ServletContainInitializer 接口的类，如果发现就使用他来配置 servlet\n * spring 提供了这个借口实现，名为 SpringServletContainerInitializer，这个类又会查找实现\n * WebApplicationInitializer 的类并将配置的任务交给他来完成，spring 3.2 引入一个基础实现，也就是\n * AbstractAnnotationConfigDispatcherServletInitializer，当继承后，一旦部署就会自动被发现\n * 简单地说相当于web.xml文件\n * @author Echo\n * @version 1.0\n * @date 2019-01-01 13:34\n */\npublic class SpringMvcInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n  /**\n   * 应用程序上下文配置文件，可以是多个，即相当于多个xml文件配置\n   * 返回的带有 @Configuration 的类一般定义 ContextLoaderListener 应用上下文中的 bean\n   * 此处一般配置应用中的其它 bean，通常是驱动应用后端的中间件或数据层组件\n   * @return 类\n   */\n   @Override\n   protected Class<?>[] getRootConfigClasses() {\n     return new Class<?>[]{RootConfig.class};\n   }\n\n  /**\n   * 获取应用程序上下文配置文件，即配置类\n   * 如果所有配置已经在 RootConfig 中配置，则可以设为null\n   * 返回的带有 @Configuration 的类一般定义 DispatcherServlet 应用上下文中的 bean\n   * 加载包含 web 组件的 bean，如控制器、视图解析器以及处理器映射等\n   * @return 类\n   */\n   @Override\n   protected Class<?>[] getServletConfigClasses() {\n     return new Class<?>[]{WebConfig.class};\n   }\n\n  /**\n   * 即将 DispatcherServlet 映射到 “/”，表示处理所有进入应用的请求。可以为多个。\n   * @return 类\n   */\n   @Override\n   protected String[] getServletMappings() {\n     return new String[]{\"/\"};\n   }\n}\n----\n\n== config/RootConfig\n\n[source,java]\n----\npackage cn.echocow.spring.config;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.FilterType;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\n\n/**\n * 相当于spring的xml配置文件,排除掉有 EnableWebMvc 注解的类，因为它会被自动发现\n *\n * @author Echo\n * @version 1.0\n * @date 2019-01-01 13:33\n *\n @Configuration\n @ComponentScan(basePackages = { \"cn.echocow.spring\" },\n       excludeFilters = {\n            @ComponentScan.Filter(type = FilterType.ANNOTATION, value = EnableWebMvc.class)\n       })\n public class RootConfig {\n\n }\n----\n\n== config/WebConfig\n\n[source,java]\n----\npackage cn.echocow.spring.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\nimport org.thymeleaf.spring5.SpringTemplateEngine;\nimport org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver;\nimport org.thymeleaf.spring5.view.ThymeleafViewResolver;\n\n/**\n * 配置 spring mvc\n *\n * @author Echo\n * @version 1.0\n * @date 2019-01-01 15:53\n */\n@EnableWebMvc\n@Configuration\n@ComponentScan({\"cn.echocow.spring.*\"})\npublic class WebConfig {\n  /**\n   * 配置模板解析\n   * @return 模板解析\n   */\n  @Bean\n  public SpringResourceTemplateResolver springResourceTemplateResolver() {\n    SpringResourceTemplateResolver springResourceTemplateResolver = new SpringResourceTemplateResolver();\n    springResourceTemplateResolver.setPrefix(\"/WEB-INF/pages/\");\n    springResourceTemplateResolver.setSuffix(\".html\");\n    springResourceTemplateResolver.setTemplateMode(\"HTML\");\n    springResourceTemplateResolver.setCacheable(false);\n    springResourceTemplateResolver.setCharacterEncoding(\"UTF-8\");\n    return springResourceTemplateResolver;\n  }\n\n  /**\n   * 配置模板引擎\n   * @return 模板引擎\n   */\n   @Bean\n   public SpringTemplateEngine springTemplateEngine() {\n     SpringTemplateEngine springTemplateEngine = new SpringTemplateEngine();\n     springTemplateEngine.setTemplateResolver(springResourceTemplateResolver());\n     return springTemplateEngine;\n   }\n\n  /**\n   * 模板配置\n   * @return 模板配置\n   */\n   @Bean\n   public ThymeleafViewResolver thymeleafViewResolver() {\n     ThymeleafViewResolver thymeleafViewResolver = new ThymeleafViewResolver();\n     thymeleafViewResolver.setTemplateEngine(springTemplateEngine());\n     thymeleafViewResolver.setCharacterEncoding(\"UTF-8\");\n     return thymeleafViewResolver;\n   }\n}\n----\n\n== config/SecurityConfig\n\n[source,java]\n----\npackage cn.echocow.spring.config;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\n\n/**\n * 安全配置类 @EnableWebSecurity 启动 web 安全，此类必须继承 WebSecurityConfigurerAdapter\n * 相当于spring-security.xml中的配置\n *\n * @author Echo\n * @version 1.0\n * @date 2019-01-01 13:33\n */\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n  /**\n   * 在内存中设置三个用户\n   * @param auth 授权\n   * @throws Exception 异常\n   */\n   @Autowired\n  public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {\n    auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()).\n                withUser(\"hongxf\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"USER\");\n    auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()).\n                withUser(\"admin\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"ADMIN\");\n    auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()).\n                withUser(\"dba\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"DBA\");\n  }\n\n  /**\n   * 配置权限要求\n   * @param http http\n   * @throws Exception 授权\n   */\n   @Override\n   protected void configure(HttpSecurity http) throws Exception {\n     http.authorizeRequests()\n         .antMatchers(\"/admin/**\").access(\"hasRole('ROLE_ADMIN')\")\n         .antMatchers(\"/dba/**\").access(\"hasRole('ROLE_ADMIN') or hasRole('ROLE_DBA')\")\n         .and().formLogin();\n  }\n}\n----\n\n== config/SpringSecurityInitializer\n\n[source,java]\n----\npackage cn.echocow.spring.config;\n\nimport org.springframework.security.web.context.AbstractSecurityWebApplicationInitializer;\n\n/**\n * 继承AbstractSecurityWebApplicationInitializer类编写类文件SpringSecurityInitializer\n * spring 会发现他，并用它在 web 容器中注册 DelegatingFilterProxy\n * 可以选择重载他的 appendFilters 或 insertFilters 方法来注册自己选择的 filter\n * 只注册 DelegatingFilterProxy，就不用重载。\n * DelegatingFilterProxy 会拦截发往应用中的所有的请求，并委托给 id 为 springSecurityFilterChain bean\n * 启动时，会自动创建这些 bean\n * 相当于在web.xml中配置spring security的filter\n *\n * @author Echo\n * @version 1.0\n * @date 2019-01-01 13:34\n */\n public class SpringSecurityInitializer extends AbstractSecurityWebApplicationInitializer {\n}\n----\n\n== web/HelloController\n\n[source,java]\n----\npackage cn.echocow.spring.web;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.servlet.ModelAndView;\n\n/**\n * @author Echo\n * @version 1.0\n * @date 2019-01-01 13:34\n */\n@Controller\npublic class HelloController {\n  @RequestMapping(value = { \"/\", \"/welcome\" }, method = RequestMethod.GET)\n  public ModelAndView welcomePage() {\n    ModelAndView model = new ModelAndView();\n    model.addObject(\"title\", \"Spring Security Hello World\");\n    model.addObject(\"message\", \"This is welcome page!\");\n    model.setViewName(\"hello\");\n    return model;\n  }\n  @RequestMapping(value = \"/admin\", method = RequestMethod.GET)\n  public ModelAndView adminPage() {\n    ModelAndView model = new ModelAndView();\n    model.addObject(\"title\", \"Spring Security Hello World\");\n    model.addObject(\"message\", \"This is protected page - Admin Page!\");\n    model.setViewName(\"admin\");\n    return model;\n  }\n  @RequestMapping(value = \"/dba\", method = RequestMethod.GET)\n  public ModelAndView dbaPage() {\n    ModelAndView model = new ModelAndView();\n    model.addObject(\"title\", \"Spring Security Hello World\");\n    model.addObject(\"message\", \"This is protected page - Database Page!\");\n    model.setViewName(\"admin\");\n    return model;\n  }\n}\n----\n\n== pages/admin.html\n\n[source,html]\n----\n<html>\n<html lang=\"zh\" xmlns=\"http://www.w3.org/1999/xhtml\"\n  xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n <meta charset=\"UTF-8\">\n <title>admin<title>\n<head>\n<body>\n<h1 th:text=\"|标题: ${title}|\">Title : XXX<h1>\n<h1 th:text=\"|信息: ${message}|\">Message : XXX<h1>\n<body>\n<html>\n----\n\n== pages/hello.html\n\n[source,html]\n----\n<html>\n<html lang=\"zh\" xmlns=\"http://www.w3.org/1999/xhtml\"\n  xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n <meta charset=\"UTF-8\">\n <title>hello<title>\n<head>\n<body>\n<h1 th:text=\"|标题: ${title}|\">Title : XXX<h1>\n<h1 th:text=\"|信息: ${message}|\">Message : XXX<h1>\n<body>\n<html>\n----\n\n","fields":{"slug":"/articles/2019/01/02/1546395090197.html","birthTime":"2019-01-02T02:25:38.298Z","modifiedTime":"2019-01-02","year":2019},"document":{"title":"spring security + gradle + spring mvc 模板化配置"}},{"content":"= 再见 manjaro，你好 deepin\n:page-description: 再见 manjaro，你好 deepin\n:page-category: linux\n:page-image: https://img.hacpai.com/bing/20180706.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2019/01/02/1546399233990.html\n:page-created: 1546400928640\n:page-modified: 1546432344079\n:toc:\n\n从换 manjaro\n到现在三个多月了吧。说实话，这个系统真的很棒，首先就是他的包管理系统真的天强，配合AUR基本都能搜到我想要的，而且装这个系统只要有点经验就挺顺利，或多或少的问题百度google也能帮上忙，不得不说果然是\narch\n系的佼佼者。可是也带来了一些坏处。就是因为他包更新太过激进，每次都会提醒我该更新了，强迫症患者看到更新两个字我绝对会点的，不点心里一万个难受，三个月的时间，因为滚动更新，滚挂了三次（泪奔）\n\n[arabic]\n. 第一次滚挂桌面，重装manjaro18\n. 第二次滚挂pycharm，anaconda无法正常使用\n. 第三次滚挂tim、wps，影响正常聊天和办公，回家后实在受不了了\n\n在犹豫了半天 https://elementary.io/[elementary OS] 和\nhttps://www.deepin.org/[deepin] 后，最终选择\ndeepin，原因很简单，他是国产有较为完善的中文社区，能够给自己提高很好的帮助。装系统是拿来用的，不是用来折腾的。不过\ndeepin 的界面真的好看，不用 mint 是因为不喜欢那个界面，也不知道为什么\nhttps://distrowatch.com/[distrowatch] 上面为啥 deepin\n排名那么低，一个能闯进distrowatch前10的发行版，要不就是老牌的（比如Debian、Fedora、Opensuse、Ubuntu），要不就是界面让人眼前一亮的（LinuxMint、Zorin、elementary、deepin、Solus），要不就是解决一个优秀发行版的大问题的（比如Manjaro，解决了\narchlinux 安装太麻烦的问题，不过像 mx linux\n这种都能够刷到前三去（他应该和 deepin 换个位置的哈哈哈），distrowatch\n的排名也不太可信了。\n\n折腾 deepin\n只要半天就完事，独显也用起来了，wps、网易云、tim等等都完美运行简直太棒，以前\nmanjaro 折腾了三天才完事，感觉自己有点进步了哈哈哈。\n\n== 成果\n\nimage::https://resources.echocow.cn//file/2019/01/706cb5bfd8a34df9a82a9cdf861e46c2__20190102113820.png[_20190102113820png]\n\nimage::https://resources.echocow.cn//file/2019/01/8193efb218a948dbad1b8098d284889a__20190102114251.png[_20190102114251png]\n\nimage::https://resources.echocow.cn//file/2019/01/2ac791f2e89446dbae4e8311986a47ce__20190102114312.png[_20190102114312png]\n\nimage::https://resources.echocow.cn//file/2019/01/65b6ef6707a04006a15418cee672a19d__20190102114625.png[_20190102114625png]\n\n== 其它\n\n[arabic]\n. deepin 其实也出现了一些问题，安装时卡住，和 manjaro\n一样修改启动项解决，进入系统后直接用显卡管理切换闭源的即可。\n. tim 有时会崩溃\n. 下方 dock 有时会突然消失\n. 应用商店的应用有些过老了，而且安装真的没有 manjaro 方便。。。\n. 桌面特效方面不及 manjaro kde 的\n\n","fields":{"slug":"/articles/2019/01/02/1546399233990.html","birthTime":"2019-01-02T03:48:48.640Z","modifiedTime":"2019-01-02","year":2019},"document":{"title":"再见 manjaro，你好 deepin"}},{"content":"= spring boot restful API 从零到一完整实践\n:page-description: spring boot restful API 从零到一完整实践\n:page-category: spring\n:page-image: https://img.hacpai.com/bing/20180804.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2019/01/05/1546684795983.html\n:page-created: 1546930785014\n:page-modified: 1546933624261\n:page-sort: -1\n:toc:\n\n自己第一次接触 restful 是在学习 vue\n的时候，第一次看见的时候，真的打心底里的喜欢。不仅是因为其一致的规范性，还有他的简单明了，都让我眼前一亮的感觉。现在对于一些程序，都是提倡的前后端分离，各干各的互不相干，事实上我也非常喜欢这种方式，虽然我希望的是成为一个全栈的工程师。但是前后端的分离却带来了一些质的飞跃，一方面业务上的逻辑不会太耦合，另一方面让更专业的人处理更专业的事，效率和质量上都会高上许多。Restful\nApi 是目前比较成熟的一套互联网应用程序的 API\n设计理论，就是作为其中一种统一的机制出现，方便不同的前端设备与后端进行通信。今天就利用\nspring boot 的多个组件，来实现以下 restful 风格的 api，从自己使用\ncontroller 到使用框架开始一步一步搭建。\n\n== RESTFul\n\nRESTFUl\n一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件（源自 https://baike.baidu.com/item/RESTful/4406165?fr=aladdin[百度百科]）。这是一篇如何使用\nspring boot 来进行构建一个 restful Api\n的记录，他的概念和核心我不再赘述，具体可查看文末的参考链接。在这之前，我们需要对我们\nApi 进行一个简单的设计。\n\n== 这篇文章能够带给你什么\n\n[arabic]\n. 如何设计一个 Restful 风格的 Api\n. 项目开发的数据初始化\n. 通过 spring boot 实现 Api，v1 版本\n. 通过 spring boot 进行统一异常处理\n. 通过 spring data rest 实现 Api，v2 版本\n. 通过 spring data rest 进行参数校验\n. 自定义 spring data rest 查询、删除等方法\n. 接口测试工具以及测试spring mvc\n\n____\n*所有代码均已上传到\nhttps://github.com/lizhongyue248/spring-boot-restful-api[github]*\n\n*博客地址： https://echocow.cn/articles/2019/01/05/1546684795983.html[spring\nboot restful API 从零到一完整实践]*\n____\n\n== 需要做好的规划\n\n=== Api 基本设计\n\n1、 我们 api 足够简单，我们为他准备一个基础路径，即\n\n[source,markup]\n....\nhttp://localhost:8080/api/\n....\n\n2、 我们 api 有多个版本，这里暂且定为一个v1版本，即\n\n[source,markup]\n....\nhttp://localhost:8080/api/v1\n....\n\n另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。 https://developer.github.com/v3/media/#request-specific-version[Github]采用这种做法。\n\n3、 我们选用五个常用的HTTP动词\n\n* GET（SELECT）：从服务器取出资源（一项或多项）。\n* POST（CREATE）：在服务器新建一个资源。\n* PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。\n* PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。\n* DELETE（DELETE）：从服务器删除资源。\n\n4、 服务器向用户返回的状态码和提示信息，我们用到的有以下一些\n\n* 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。\n* 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。\n* 204 NO CONTENT - [DELETE]：用户删除数据成功。\n* 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。\n* 404 NOT FOUND - 用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。\n* 500 INTERNAL SERVER ERROR - 服务器发生错误，用户将无法判断发出的请求是否成功。\n\n=== Api 数据准备\n\n我们需要为数据准备一个实体，我将使用一个书单（Book）对象作为实体，他的具体属性如下：\n\n* id\n* name 书名\n* author 作者\n* description 描述\n* status 状态\n\n=== Api Url 设计\n\n按照我们提供的五个动词，分别设计多个 api 如下：\n\n* GET /api/v1/books 所有书单\n* GET /api/v1/books/\\{id} 获取一条书单\n* POST /api/v1/books 新建一条书单\n* PUT /api/v1/books/\\{id} 更新一条书单，提供全部信息\n* PATCH /api/v1/books/\\{id} 更新一条书单，提供部分信息\n* DELETE /api/v1/books/\\{id} 删除一条书单\n* DELETE /api/v1/books 删除所有书单，危险操作\n\n=== 技术选型\n\n* 核心框架：spring boot\n* web： spring boot web\n* 数据库：mysql\n* 构建工具：gradle\n* 应用框架：spring boot data jpa\n* restful：spring data rest\n* 工具支持：spring boot devtools\n* 测试框架：junit5、spring boot test\n* 开发工具：idea\n\n== 环境搭建\n\n首先我们要先通过 idea 对项目进行初始化\n\n=== 初始化\n\n[arabic]\n. 新建项目\n\nimage:https://resources.echocow.cn//file/2019/01/1cf250f196d3424da1c2d7c4011a2659__sunawtX11XDialogPeer_20190105191714.png[新建项目]\n\n[arabic, start=2]\n. 填写基本属性\n\nimage:https://resources.echocow.cn//file/2019/01/ee1555cf87bc4cde9ac182408eab08c6__sunawtX11XDialogPeer_20190105191934.png[填写基本属性]\n\n[arabic, start=3]\n. 选择依赖\n\nimage:https://resources.echocow.cn//file/2019/01/99b95787f4d9486691946ad183c866ea__sunawtX11XDialogPeer_20190105192653.png[选择依赖]\n\n[arabic, start=4]\n. 设置 gradle\n\nimage:https://resources.echocow.cn//file/2019/01/af6c9b055e9043acbb5b6641be6d35c2__sunawtX11XDialogPeer_20190105192740.png[设置\ngradle]\n\n[arabic, start=5]\n. 等待构建依赖的同时，修改一下仓库地址，不然下载很慢，如果一直下不下载就修改好仓库地址后重新打开idea让他自动重下。这就是为啥不喜欢直接建spring\n的 gradle 项目的原因，他会自动导入，个人喜欢直接建 gradle\n项目然后手动导入依赖。但是对于 spring 来说他也确实方便。\n\nimage:https://resources.echocow.cn//file/2019/01/64a8fe853f3b4535a43880edbfca7f0c__sunawtX11XFramePeer_20190105212711.png[修改仓库地址]\n\n[arabic, start=5]\n. 配置 spring boot 项目\n\nimage:https://resources.echocow.cn//file/2019/01/c0e2a8e7136e480abd24412a1b46f020__sunawtX11XFramePeer_20190105213053.png[配置]\n\n[source,yaml]\n....\nspring:\n  application:\n    name: restful-api\n  datasource:\n    url: jdbc:mysql://localhost:3306/spring\n    username: root\n    password: 123456\n    platform: mysql\n  jpa:\n    show-sql: true\n hibernate:\n      ddl-auto: create\nserver:\n  servlet:\n    context-path: /api\n....\n\n这样我们就完成一个项目的初始化，接下来进行数据的准备\n\n=== 数据准备\n\n____\n为什么要这一步？因为我们期望每次启动项目。数据都是一致的，这样会方便我们很多。比如有时候测试删除的时候，把数据全部删除完了，又要手动添加数据，比如你执行过了很多更新操作，造成数据乱七八糟的，不方便以后的测试，所以最好的办法就是每次启东时重新建表，重新插入指定的数据。并且在写测试类的时候，可以直接对期望结果，这样也会方便测试。当然，只针对开发环境。\n____\n\n[arabic]\n1、 按照我们前面给出 Book 对象，建立实体类。\nimage:https://resources.echocow.cn//file/2019/01/fa4e69192fc149d598fb3e668328c4f2__sunawtX11XFramePeer_20190105213745.png[Book]\n\n[source,java]\n----\npackage cn.echocow.restfulapi.entity;\n\nimport lombok.Data;\nimport org.hibernate.annotations.ColumnDefault;\nimport javax.persistence.*;\nimport javax.validation.constraints.NotNull;\n\n/**\n * 书籍的实体类\n *\n * @author Echo\n * @version 1.0\n * @date 2019-01-05 21:36\n */\n@Entity\n@Data\npublic class Book {\n  @Id\n  @GeneratedValue(strategy = GenerationType.IDENTITY)\n  @Column(insertable = false, length = 20, nullable = false)\n  public Long id;\n  @NotNull\n  @Column(columnDefinition = \"varchar(50) comment '书名'\")\n  public String name;\n  @NotNull\n  @Column(columnDefinition = \"varchar(25) comment '作者'\")\n  public String author;\n  @Column(columnDefinition = \"varchar(255) comment '描述'\")\n  public String description;\n  @NotNull\n  @ColumnDefault(\"1\")\n  @Column(columnDefinition = \"tinyint(1) comment '是否存在'\")\n  public Boolean status;\n}\n----\n\n2、 建立生成数据的 sql 文件\nimage:https://resources.echocow.cn//file/2019/01/ad4fc674b062494f80f09caf0d644eb9__sunawtX11XFramePeer_20190105214010.png[_sunawtX11XFramePeer_20190105214010png]\n\n[source,sql]\n----\nINSERT INTO spring.book (id, author, description, name, status) VALUES (1, '孟宁', '本书从理解计算机硬件的核心工作机制（存储程序计算机和函数调用堆栈）和用户态程序如何通过系统调用陷入内核（中断异常）入手，通过上下两个方向双向夹击的策略，并利用实际可运行程序的反汇编代码从实践的角度理解操作系统内核，分析Linux内核源代码，从系统调用陷入内核、进程调度与进程切换开始，最后返回到用户态进程。', '庖丁解牛Linux内核分析', 1);\nINSERT INTO spring.book (id, author, description, name, status) VALUES (2, '孙亮', '大数据时代为机器学习的应用提供了广阔的空间，各行各业涉及数据分析的工作都需要使用机器学习算法。本书围绕实际数据分析的流程展开，着重介绍数据探索、数据预处理和常用的机器学习算法模型。本书从解决实际问题的角度出发，介绍回归算法、分类算法、推荐算法、排序算法和集成学习算法。在介绍每种机器学习算法模型时，书中不但阐述基本原理，而且讨论模型的评价与选择。为方便读者学习各种算法，本书介绍了R语言中相应的软件包并给出了示例程序。', '实用机器学习', 1);\nINSERT INTO spring.book (id, author, description, name, status) VALUES (3, '托马斯·哈斯尔万特', '本书以基础的统计学知识和假设检验为重点，简明扼要地讲述了Python在数据分析、可视化和统计建模中的应用。主要包括Python的简单介绍、研究设计、数据管理、概率分布、不同数据类型的假设检验、广义线性模型、生存分析和贝叶斯统计学等从入门到高级的内容。', 'Python统计分析', 1);\nINSERT INTO spring.book (id, author, description, name, status) VALUES (4, '甘迪文', '《Windows黑客编程技术详解》介绍的是黑客编程的基础技术，涉及用户层下的Windows编程和内核层下的Rootkit编程。本书分为用户篇和内核篇两部分，用户篇包括11章，配套49个示例程序源码；内核篇包括7章，配套28个示例程序源码。本书介绍的每个技术都有详细的实现原理，以及对应的示例代码（配套代码均支持32位和64位Windows 7、Windows 8.1及Windows 10系统），旨在帮助初学者建立起黑客编程技术的基础。', 'Windows黑客编程技术详解', 1);\nINSERT INTO spring.book (id, author, description, name, status) VALUES (5, '科里•奥尔索夫', '本书作者是一名自学成才的程序员，经过一年的自学，掌握了编程技能并在eBay找到了一份软件工程师的工作。本书是作者结合个人经验写作而成，旨在帮助读者从外行成长为一名专业的Python程序员。', 'Python编程无师自通——专业程序员的养成', 1);\nINSERT INTO spring.book (id, author, description, name, status) VALUES (6, '威廉·史密斯', '本书由浅入深地详细讲解了计算机存储使用的多种数据结构。本书首先讲解了初级的数据结构（如表、栈、队列和堆等），具体包括它们的工作原理、功能实现以及典型的应用程序等；然后讨论了数据结构，如泛型集合、排序、搜索和递归等；最后介绍了如何在日常应用中使用这些数据结构。', '程序员学数据结构', 1);\nINSERT INTO spring.book (id, author, description, name, status) VALUES (7, '张鑫旭', '本书从前端开发人员的需求出发，以“流”为线索，从结构、内容到美化装饰等方面，全面且深入地讲解前端开发人员必须了解和掌握的大量的CSS知识点。同时，作者结合多年的从业经验，通过大量的实战案例，详尽解析CSS的相关知识与常见问题。作者还为本书开发了专门的配套网站，进行实例展示、问题答疑。', 'CSS世界', 1);\nINSERT INTO spring.book (id, author, description, name, status) VALUES (8, '理查德·格里姆斯', '作为一门广为人知的编程语言，C++已经诞生30多年了，这期间也出现并流行过许多种编程语言，但是C++是经得起考验的。如此经典的编程语言，值得每一位编程领域的新人认真学习，也适合有经验的程序员细细品味。', 'C++编程自学宝典', 1);\nINSERT INTO spring.book (id, author, description, name, status) VALUES (9, '萨沙·戈德斯汀', '本书详细解释了影响应用程序性能的Windows、CLR和物理硬件的内部结构，并为读者提供了衡量代码如何独立于外部因素执行操作的知识和工具。书中提供了大量的C#代码示例和技巧，将帮助读者zui大限度地提高算法和应用程序的性能，提高个人竞争优势，使用更低的成本获取更多的用户。', '.NET性能优化', 1);\nINSERT INTO spring.book (id, author, description, name, status) VALUES (10, '李伟', '《C++模板元编程实战：一个深度学习框架的初步实现》以一个深度学习框架的初步实现为例，讨论如何在一个相对较大的项目中深入应用元编程，为系统性能优化提供更多的可能。', 'C++模板元编程实战：一个深度学习框架的初步实现', 1);\nINSERT INTO spring.book (id, author, description, name, status) VALUES (11, 'Ben Klemens 克莱蒙', '本书展现了传统C语言教科书所不具有相关技术。全书分', 'C程序设计新思维（第2版）', 1);\nINSERT INTO spring.book (id, author, description, name, status) VALUES (12, '王云', '本书遵循由浅入深、循序渐进的原则，讲解单片机开发经典案例。本书以YL51单片机开发板为平台，通过案例逐个讲解开发板上各个器件模块的使用及其编程方法，包括单片机最小系统、数码管显示原理、中断与定时器、数模\\\\模数转换工作原理、LCD液晶显示、串行口通信、步进电机驱动原理、PWM脉宽调制与直流电机等内容。', '51单片机C语言程序设计教程', 1);\nINSERT INTO spring.book (id, author, description, name, status) VALUES (13, '胡振波', '本书是一本介绍通用CPU设计的入门书，以通俗的语言系统介绍了CPU和RISC-V架构，力求为读者揭开CPU设计的神秘面纱，打开计算机体系结构的大门。', '手把手教你设计CPU——RISC-V处理器篇', 1);\nINSERT INTO spring.book (id, author, description, name, status) VALUES (14, '克劳斯·福勒', '本书旨在通过实际的Python 3.0代码示例展示Python与数学应用程序的紧密联系，介绍将Python中的各种概念用于科学计算的方法。', 'Python 3.0科学计算指南', 1);\nINSERT INTO spring.book (id, author, description, name, status) VALUES (15, '路彦雄', '《文本上的算法 深入浅出自然语言处理》结合-作者多年学习和从事自然语言处理相关工作的经验，力图用生动形象的方式深入浅出地介绍自然语言处理的理论、方法和技术。本书抛弃掉繁琐的证明，提取出算法的核心，帮助读者尽快地掌握自然语言处理所必需的知识和技能。', '文本上的算法——深入浅出自然语言处理', 1);\nINSERT INTO spring.book (id, author, description, name, status) VALUES (16, '胡世杰', '本书从云存储的需求出发讲述对象存储的原理，循序渐进地建立起一个分布式对象存储的架构，并且将软件实现出来。全书共8章，分别涉及对象存储简介、可扩展分布式系统、元数据服务、数据校验和去重、数据冗余处理、断点续传、数据压缩和数据维护等。本书选择用来实现分布式对象存储软件的编程语言是当前流行的Go语言。', '分布式对象存储——原理、架构及Go语言实现', 1);\nINSERT INTO spring.book (id, author, description, name, status) VALUES (17, '徐子珊', '《趣题学算法》适于作为程序员的参考书，高校各专业学生学习“数据结构”“算法设计分析”“程序设计”等课程的扩展读物，也可以作为上述课程的实验或课程设计的材料，还可以作为准备参加国内或国际程序设计赛事的读者的赛前训练材料。', '趣题学算法', 1);\nINSERT INTO spring.book (id, author, description, name, status) VALUES (18, '鲁什迪·夏姆斯', '现如今，数据科学已经成为一个热门的技术领域，它涵盖了人工智能的各个方面，例如数据处理、信息检索、机器学习、自然语言处理、数据可视化等。而Java作为一门经典的编程语言，在数据科学领域也有着杰出的表现。', 'Java数据科学指南', 1);\nINSERT INTO spring.book (id, author, description, name, status) VALUES (19, '罗炳森', '结构化查询语言（Structured Query Language，SQL）是一种功能强大的数据库语言。它基于关系代数运算，功能丰富、语言简洁、使用方便灵活，已成为关系数据库的标准语言。', 'SQL优化核心思想', 1);\nINSERT INTO spring.book (id, author, description, name, status) VALUES (20, '弗兰克·D.卢娜', 'Direct3D是微软公司DirectX SDK集成开发包中的重要组成部分，是编写高性能3D图形应用程序的渲染库，适用于多媒体、娱乐、即时3D动画等广泛和实用的3D图形计算领域。', 'DirectX 12 3D 游戏开发实战', 1);\nINSERT INTO spring.book (id, author, description, name, status) VALUES (21, '巴阿尔丁•阿扎米', 'Kibana是广泛地应用在数据检索和数据可视化领域的ELK中的一员。本书专门介绍Kibana，通过不同的用例场景，带领读者全面体验Kibana的可视化功能。', 'Kibana数据可视化', 1);\nINSERT INTO spring.book (id, author, description, name, status) VALUES (22, '郝佳', '《Spring源码深度解析（第2版）》从核心实现、企业应用和Spring Boot这3个方面，由浅入深、由易到难地对Spring源码展开了系统的讲解，包括Spring 整体架构和环境搭建、容器的基本实现、默认标签的解析、自定义标签的解析、bean的加载、容器的功能扩展、AOP、数据库连接JDBC、整合MyBatis、事务、SpringMVC、远程服务、Spring消息、Spring Boot体系原理等内容。', 'Spring源码深度解析（第2版）', 1);\nINSERT INTO spring.book (id, author, description, name, status) VALUES (23, 'Jon Bentley', '书的内容围绕程序设计人员面对的一系列实际问题展开。作者JonBentley以其独有的洞察力和创造力，引导读者理解这些问题并学会解决方法，而这些正是程序员实际编程生涯中到关重要的。', '编程珠玑（第2版•修订版）', 1);\nINSERT INTO spring.book (id, author, description, name, status) VALUES (24, 'Mickey W. Mantle', '这是一本系统阐述面对混乱而容易失控的技术开发团队时，如何管理、建设和强化团队，成功交付开发成果的大作。两位作者Mickey W. Mantle和Ron Lichty以合起来近70年的开发管理经验为基础，通过深刻的观察和分析，找到了软件开发管理的核心问题——人的管理，并围绕如何真正理解程序员、找到合适的程序员、与程序员沟通这几个核心话题，一步步展开，扩展到如何以人为本地进行团队建设、管理和项目管理。', '告别失控：软件开发团队管理必读', 1);\n----\n\n3、 利用 idea 的数据库管理工具直接管理数据库\nimage:https://resources.echocow.cn//file/2019/01/6d4916e39b8d4602bca9959cc21fb315__sunawtX11XFramePeer_20190105214128.png[数据库]\n\n4、 启动应用进行测试，查看一下是否创建对应的表和数据\nimage:https://resources.echocow.cn//file/2019/01/482a7e8a9ea7464a9dab6741ece8c37b__sunawtX11XFramePeer_20190105214506.png[启动测试]\n\n这样就完成我们需要的环境，下面进行一些必要的测试工具安装。\n\n=== 测试工具\n\n我们需要一些接口测试工具来进行辅助开发，以便更快的得到及时反馈,以下工具选择根据需要即可。\n1. https://www.getpostman.com/apps[postman\n一款功能全面且强大的接口测试工具] 2.\nhttps://plugins.jetbrains.com/plugin/10292-restfultoolkit[idea plugin\nRestfulToolkit 一套 RESTful 服务开发辅助工具集。] 3. 使用\nspring-boot-starter-test 进行 mockMvc 测试 4. 其它…\n\n== 初步实现\n\n在这一步，我们会通过 rest controller 的方式进行创建一个 Restful 风格的\napi。所以在这之前，我们要暂时不引入 spring boot 提供的 rest ，即\nbuild.gradle 中的 `spring-boot-starter-data-rest`\n依赖,为什么？后面就知道啦。\n\nimage::https://resources.echocow.cn//file/2019/01/2f4b96bdb97040fa87593b88da1605fe___20190105215444.png[后面就知道啦]\n\n=== 第一步：实现\n\n1、 建立 BookRepository，对数据库进访问\nimage:https://resources.echocow.cn//file/2019/01/451b676cde3a4bf7ac2f39b9e80cb7ca__sunawtX11XFramePeer_20190105215825.png[对数据库进访问]\n\n2、 建立 BookController\n\n____\n为什么不要 service？在开发过程中，我们都是\ncontroller、service、repository 三层的，在这里我将它省去了\nservice。一方面因为我没有太多的复杂的逻辑要处理，加了service反而让我多写几个类甚至几个接口，另一方面，在实际开发的过程中也完全没有必要按照这么个设计来，自己开发得爽，代码易读性高，质量棒就行了，没必要拿着一套死不放。小型应用中，没有复杂的逻辑，我基本不会去写\nservice 层的。\n____\n\nimage::https://resources.echocow.cn//file/2019/01/681265dce3714d94ba99296fce66eb37__sunawtX11XFramePeer_20190105220057.png[建立controller]\n\n3、 书写具体逻辑\nimage:https://resources.echocow.cn//file/2019/01/14abc1e30c774e829cddda7f2a2efb81__sunawtX11XFramePeer_20190105220547.png[1]\n\nimage::https://resources.echocow.cn//file/2019/01/da149cd90e4a43ebbabfc3f52f163297__sunawtX11XFramePeer_20190105220733.png[2]\n\nimage::https://resources.echocow.cn//file/2019/01/78e7945cbcbf4b6eb21d0f200723161b__sunawtX11XFramePeer_20190105220741.png[3]\n\n[source,java]\n----\npackage cn.echocow.restfulapi.controller;\n\nimport cn.echocow.restfulapi.entity.Book;\nimport cn.echocow.restfulapi.repository.BookRepository;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.BeanWrapper;\nimport org.springframework.beans.BeanWrapperImpl;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpEntity;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.validation.BindingResult;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.validation.Valid;\nimport java.beans.PropertyDescriptor;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * rest 风格 api\n *\n * GET     /api/v1/books        所有书单\n * GET     /api/v1/books/{id}   获取一条书单\n * POST    /api/v1/books        新建一条书单\n * PUT     /api/v1/books/{id}   更新一条书单，提供全部信息\n * PATCH   /api/v1/books/{id}   更新一条书单，提供部分信息\n * DELETE  /api/v1/books/{id}   删除一条书单\n * DELETE  /API/v1/books        删除所有书单\n *\n * @author Echo\n * @version 1.0\n * @date 2019-01-05 21:59\n */\n@RestController\n@RequestMapping(\"/v1\")\npublic class BookController {\n  private final BookRepository bookRepository;\n  @Autowired\n  public BookController(BookRepository bookRepository) {\n    this.bookRepository = bookRepository;\n  }\n\n  /**\n   * 获取所有书单\n   * GET     /api/v1/books        所有书单\n   *\n   * @return http 响应\n   */\n  @GetMapping(\"/books\")\n  public HttpEntity<?> books() {\n    return new ResponseEntity<>(bookRepository.findAll(), HttpStatus.OK);\n  }\n\n  /**\n   * 获取一个书单 * GET     /api/v1/books/{id}   获取一条书单 * * @param id id\n   * @return http 响应\n   */  @GetMapping(\"/books/{id}\")\n  public HttpEntity<?> booksOne(@PathVariable Long id) {\n    return new ResponseEntity<>(bookRepository.findById(id).get(), HttpStatus.OK);\n  }\n\n  /**\n   * 添加一个书单\n   * POST    /api/v1/books        新建一条书单\n   *\n   * @param book 书单\n   * @return http 响应\n   */\n  @PostMapping(\"/books\")\n  public HttpEntity<?> booksAdd(@Valid @RequestBody Book book, BindingResult bindingResult) {\n    book.setId(null);\n    return new ResponseEntity<>(bookRepository.save(book), HttpStatus.CREATED);\n  }\n\n  /**\n   * 更新一个书单,提供一个书单的全部信息\n   * PUT     /api/v1/books/{id}   更新一条书单，提供全部信息\n   *\n   * @param id 更新的id\n   * @param book 更新后的书单\n   * @return http 响应\n   */\n  @PutMapping(\"/books/{id}\")\n  public HttpEntity<?> booksPut(@Valid @PathVariable Long id, @RequestBody Book book, BindingResult bindingResult) {\n    Book exist = bookRepository.findById(id).get();\n    book.setId(exist.getId());\n    return new ResponseEntity<>(bookRepository.save(book), HttpStatus.OK);\n  }\n\n  /**\n   * 更新一个书单,提供一个书单的部分信息\n   * PATCH   /api/v1/books/{id}   更新一条书单，提供部分信息\n   *\n   * @param id 更新的id\n   * @param book 更新后的书单\n   * @return http 响应\n   */\n  @PatchMapping(\"/books/{id}\")\n  public HttpEntity<?> booksPatch(@PathVariable Long id, @RequestBody Book book) {\n    Book exist = bookRepository.findById(id).get();\n    BeanWrapper beanWrapper = new BeanWrapperImpl(book);\n    PropertyDescriptor[] propertyDescriptors = beanWrapper.getPropertyDescriptors();\n    List<String> nullPropertyNames = new ArrayList<>();\n    for (PropertyDescriptor pd : propertyDescriptors) {\n      if (beanWrapper.getPropertyValue(pd.getName()) == null) {\n         nullPropertyNames.add(pd.getName());\n      }\n    }\n    BeanUtils.copyProperties(book, exist, nullPropertyNames.toArray(new String[nullPropertyNames.size()]));\n    return new ResponseEntity<>(bookRepository.save(exist), HttpStatus.OK);\n  }\n\n  /**\n   * 删除一个书单\n   * DELETE  /api/v1/books/{id}   删除一条书单\n   *\n   * @param id id\n   * @return http 响应\n   */\n  @DeleteMapping(\"/books/{id}\")\n  public HttpEntity<?> booksDeleteOne(@PathVariable Long id) {\n    Book exist = bookRepository.findById(id).get();\n    bookRepository.deleteById(exist.getId());\n    return new ResponseEntity<>(HttpStatus.NO_CONTENT);\n  }\n\n  /**\n   * 删除所有书单\n   * DELETE  /API/v1/books        删除所有书单\n   *\n   * @return http 响应\n   */\n  @DeleteMapping(\"/books\")\n  public HttpEntity<?> booksDeleteAll() {\n    List<Book> books = bookRepository.findAll();\n    bookRepository.deleteAll();\n    return new ResponseEntity<>(HttpStatus.NO_CONTENT);\n  }\n}\n----\n\n4、 进行测试\nimage:https://resources.echocow.cn//file/2019/01/d43c2995597d45c3b3b32b828f647d75__sunawtX11XFramePeer_20190105221416.png[http://localhost:8080/api/v1/books\n测试]\n\n其余的测试都是成功的,但是都是理想的情况,如果发生其他的情况呢?比如,我查询不存在书籍呢?\n\n5、 进行错误测试:找不到资源\n\n这个时候这个工具就不够用了,因为我们需要获取到他的状态码,所以我们需要使用\npostman 了.\nimage:https://resources.echocow.cn//file/2019/01/8d1da695d9fc491995f0c597804d03b7__crx_fhbjgbiflinjbdggehcddcbncdddomop_20190105221953.png[找不到资源]\n\n6、 进行错误测试:字段不符合、\n\n我们在 Book 的实体中的 name 字段加入了 `@NotNull`\n注解,也就是非空验证。那么当客户端给的是错误的时候，会给出什么呢？\nimage:https://resources.echocow.cn//file/2019/01/7e55b7e1ec144abb9c48ca1a9c0d0900__crx_fhbjgbiflinjbdggehcddcbncdddomop_20190105222450.png[字段不符合]\n\n所以这就涉及到统一异常处理了。\n\n=== 第二步，统一异常处理\n\n==== 指定统一异常处理规范\n\n现在我们遇到了两个问题，一个是 not found，应该给出 404，一个是 INVALID\nREQUEST，应该给出 400.所以他们应该相应返回如下\n\n* 404\n\n[source,json]\n----\nstatus:404\n\ndata(可选):\n{\n  \"msg\" : \"Not found books!\"\n}\n----\n\n* 400\n\n[source,json]\n----\nstatus:400\n\ndata(可选):\n{\n  \"msg\" : \"invalid parameter\",\n  \"errors\": [\n    {\n      \"resource\":\"传过来的实体名称\",\n      \"field\":\"字段\",\n      \"code\":\"代码\",\n      \"message\",\"信息\"\n    },{\n      \"resource\":\"传过来的实体名称\",\n      \"field\":\"字段\",\n      \"code\":\"代码\",\n      \"message\",\"信息\"\n    }\n  ]\n}\n----\n\n==== 异常处理\n\n1、 如果大家细心应该可以注意到在 controller 之中，idea\n给我们报了很多警告，对于我来说是绝对不允许这些警告出现的，而这些警告也是提醒了我们的可能会出现的错误所在。\n\nimage::https://resources.echocow.cn//file/2019/01/7bb71108a4774046be61bb4305da6af9__sunawtX11XFramePeer_20190105222747.png[controller]\n\n_Optional_ 类 是 Java 8\n新特性，是一个可以为null的容器对象。这里的提示的意思就是我们没有对获取到的\nOptional\n进行非空校验，校验他里面是否为空，这就是我们需要改进的地方。**解决办法很简单，就是判断，当他为空的时候，抛出一个异常即可。**所以我们需要自定义自己的异常信息。\n\n2、 自定义异常\n\nimage::https://resources.echocow.cn//file/2019/01/07cca1aa09c94b73ad1c262415aff085__sunawtX11XFramePeer_20190105223726.png[ResourceNoFoundException]\n\nimage::https://resources.echocow.cn//file/2019/01/3bd738cdd2db494ea4d885bfca86578c__sunawtX11XFramePeer_20190105223732.png[InvalidRequestException]\n\n3、 抛出异常\n\n在可能出现异常的地方，抛出异常。\n\nimage::https://resources.echocow.cn//file/2019/01/afa09c54e24e484a9661a465377fc640__sunawtX11XFramePeer_20190105224308.png[抛出异常]\n\n同时可以看到，右侧的警告全都没了，太爽！消除警告原则！\n\n4、 重启，进行测试\n\nimage::https://resources.echocow.cn//file/2019/01/6aca0ffcb1a94cc5a37693e693e18eb0__crx_fhbjgbiflinjbdggehcddcbncdddomop_20190105221953.png[进行测试]\n\n发现还是有点差距，这个就需要我们对响应进行封装了。我们查看控制台可以发现，抛出的使我们自定义的异常了。\n\n==== 封装错误信息\n\n1、 我们需要添加几个信息封装的类，作为响应返回的实体\n\nimage::https://resources.echocow.cn//file/2019/01/5015e3b2d75d42edb0d8dce653e5d861__sunawtX11XFramePeer_20190105225300.png[ErrorResource]\n\nimage::https://resources.echocow.cn//file/2019/01/725a1d8e38864a4b918387c52db61db9__sunawtX11XFramePeer_20190105225306.png[FieldResource]\n\nimage::https://resources.echocow.cn//file/2019/01/bf7c83e3e64d4b51bcadbabf5b3cc74a__sunawtX11XFramePeer_20190105225314.png[InvalidErrorResource]\n\n2、 添加一个全局异常处理，用来拦截所有的异常信息并进行封装。\n\nimage::https://resources.echocow.cn//file/2019/01/a9eb908088c942cca1633c2780422430__sunawtX11XFramePeer_20190105225717.png[拦截所有的异常信息并进行封装]\n\n[source,java]\n----\npackage cn.echocow.restfulapi.handle;\n\nimport cn.echocow.restfulapi.exception.InvalidRequestException;\nimport cn.echocow.restfulapi.exception.ResourceNoFoundException;\nimport cn.echocow.restfulapi.resource.ErrorResource;\nimport cn.echocow.restfulapi.resource.FieldResource;\nimport cn.echocow.restfulapi.resource.InvalidErrorResource;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpEntity;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.validation.Errors;\nimport org.springframework.validation.FieldError;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.RestControllerAdvice;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * 对异常进行拦截然后封装到响应体\n *\n * @author Echo\n * @version 1.0\n * @date 2019-01-05 22:59\n */\n@RestControllerAdvice\npublic class ApiExceptionHandler {\n\n  private final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n  @ExceptionHandler(ResourceNoFoundException.class)\n  public HttpEntity<?> handleNotFound(ResourceNoFoundException e) {\n    ErrorResource errorResource = new ErrorResource(e.getMessage());\n    logger.error(errorResource.toString());\n    return new ResponseEntity<>(errorResource, HttpStatus.NOT_FOUND);\n  }\n\n  @ExceptionHandler(InvalidRequestException.class)\n  public HttpEntity<?> handleInvalidRequest(InvalidRequestException e) {\n    Errors errors = e.getErrors();\n    List<FieldResource> fieldResources = new ArrayList<>();\n    List<FieldError> fieldErrors = errors.getFieldErrors();\n    for (FieldError fieldError : fieldErrors) {\n      fieldResources.add(\n          new FieldResource(fieldError.getObjectName(),\n          fieldError.getField(),\n          fieldError.getCode(),\n          fieldError.getDefaultMessage())\n      );\n  }\n    InvalidErrorResource invalidErrorResource = new InvalidErrorResource(e.getMessage(), fieldResources);\n    logger.error(invalidErrorResource.toString());\n    return new ResponseEntity<>(invalidErrorResource, HttpStatus.BAD_REQUEST);\n  }\n\n  @ExceptionHandler(Exception.class)\n  public HttpEntity<?> handleException(Exception e){\n    logger.error(e.getMessage());\n    return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);\n  }\n}\n----\n\n3、 进行测试\n\nimage::https://resources.echocow.cn//file/2019/01/25d2b143226c4ab8aac761b85e881432__crx_fhbjgbiflinjbdggehcddcbncdddomop_20190105221953.png[出现错误]\n\nimage::https://resources.echocow.cn//file/2019/01/62ffcebf2c8642678321e148402dbca4___20190105231339.png[解决]\n\n4、 再次测试\n\nimage::https://resources.echocow.cn//file/2019/01/a142a8c51c14451a95dfd59b49251dea__crx_fhbjgbiflinjbdggehcddcbncdddomop_20190105231459.png[再次测试]\n\n这样就完成我们统一异常的处理。 第一版的 restful api\n也就开发完毕～！当然，这只是一个简单的 restful\napi，为什么说他简单？那就是他缺少了一个 Hypermedia\nAPI！这是什么？可以访问 https://api.github.com/[github 的 restful api]\n就可以看到这么一个效果了。想要自己手动实现这个，自己能力还有些不足，不过欢迎大家交流学习。\n\n== 使用 spring data rest\n\n上面我们自己使用 spring boot 实现了一个 restful 的\napi。我们从三层，变为了两层。不过前面提到了我们没有使用的的一个依赖，spring-boot-starter-data-rest，现在，我们就基于它，来开发一个\nrestful api，相信我，你会很惊讶的。\n\n=== 引入依赖\n\nimage::https://resources.echocow.cn//file/2019/01/025e4ac4161046de9560066b7c28977a__sunawtX11XFramePeer_20190105232540.png[_sunawtX11XFramePeer_20190105232540png]\n\n=== 初体验\n\n1、 然后你不需要修改任何代码，请直接访问 http://localhost:8080/api/\n\n你会看到这么一个页面\n\nimage::https://resources.echocow.cn//file/2019/01/4c57e6b2abd2402a92078388a507dd39___20190105232804.png[你会看到这么一个页面]\n\n2、 然后你试着访问他给你的两个链接看看\n\nimage::https://resources.echocow.cn//file/2019/01/f283fe5780934066845334c3c1c6c157___20190105233750.png[然后你试着访问他给你的两个链接看看]\n\n完美+2！同时还给出了我们需要的 Hypermedia API！\n\n*不过值得注意，他的路径没有 v1 了*\n\n3、 测试一下 api\n\nimage::https://resources.echocow.cn//file/2019/01/db537f6b37a84cef9bef90c4fdb578a6__crx_fhbjgbiflinjbdggehcddcbncdddomop_20190105235043.png[get]\n\nimage::https://resources.echocow.cn//file/2019/01/e742dcb8cd444b5b8eb3b7a173ff1f84__crx_fhbjgbiflinjbdggehcddcbncdddomop_20190105235058.png[get]\n\nimage::https://resources.echocow.cn//file/2019/01/1e2850ef657a4f1ba173992ce22d82da__crx_fhbjgbiflinjbdggehcddcbncdddomop_20190105235115.png[put]\n\nimage::https://resources.echocow.cn//file/2019/01/40990ce9fc904c1ebdec9994c71add4b__crx_fhbjgbiflinjbdggehcddcbncdddomop_20190105235127.png[delete]\n\n4、 测试一下异常情况\n\nimage::https://resources.echocow.cn//file/2019/01/f0f8d81b5b8744a2920087b2e6077e6c__crx_fhbjgbiflinjbdggehcddcbncdddomop_20190105235259.png[404]\n\nimage::https://resources.echocow.cn//file/2019/01/58afe28634924c7080c052f97bd59534__crx_fhbjgbiflinjbdggehcddcbncdddomop_20190105235337.png[400]\n\n出现了意外状况，400 的期望，来了\n500。。如何处理呢？在这之前，我们了解下吧。\n\n=== 发生了什么\n\n我，，，我也不知道啊=-=我就加了一个依赖，然后只要带有 `@Repository`\n注解且继承了 `Repository`\n及其他的子接口的接口的方法都暴露出去了。至于为什么我也不清楚，因为应该是使用了\n`@RepositoryRestResource`\n注解的才应该会被暴露出去，我到现在还不能明白。这就是为啥前面要大家暂时不用那个依赖的原因。不过不碍事，我们继续。\n\n=== 添加一个 v2 版本的 restful\n\n1、 添加 BookRestRepository\n\nimage::https://resources.echocow.cn//file/2019/01/c779af7e12e74a28869b9aea2c1e1a59__sunawtX11XFramePeer_20190106012444.png[BookRestRepository]\n\n2、 设置基础路径\n\nimage::https://resources.echocow.cn//file/2019/01/4610cd26fe99456c8d39b390055e8c92__sunawtX11XFramePeer_20190106012738.png[设置基础路径]\n\n3、 测试访问\n\nimage::https://resources.echocow.cn//file/2019/01/653c4c84167247d79adb7d78cecbc300__crx_fhbjgbiflinjbdggehcddcbncdddomop_20190106013118.png[测试访问]\n\n=== 关于 spring data rest\n\n神奇的在于他的注解，关于 rest 的注解主要有四个\n\n[arabic]\n. @RestController 完全自定义控制器，完全交由自己处理\n. @RepositoryRestResource 完全使用已设置的Spring Data\nREST配置，不需要自定义控制\n. @RepositoryRestController 希望使用已设置的Spring Data\nREST配置，但是部分需要自定义\n. @BasePathAwareController\n如果您对特定于实体的操作不感兴趣但仍希望在basePath下构建自定义操作，例如Spring\nMVC视图，资源等，请使用@BasePathAwareController（资料太少完全没人用的感觉）\n\n如果完全使用 spring data rest\n进行处理就会暴露出我们继承的接口的方法。对于 Repository\n接口主要有三个子接口，分别是 CrudRepository、\nJpaRepository、PagingAndSortingRepository,他们的关系如下\n\nimage::https://resources.echocow.cn//file/2019/01/df8271d33a7b48a191bbce456d70e015___20190108095946.png[__20190108095946png]\n\n可以看到， CrudRepository 提供基础的\n增删改查，PagingAndSortingRepository 又提供了分页和排序，JpaRepository\n多继承了一个 QueryByExampleExecutor，用来对 QBE 的支持，对于 restful api\n来说，只需继承 PagingAndSortingRepository 即可。\n\n==== 处理参数校验\n\n前面我们测试了一下，如果我们的参数不合法，比如名称为null，他直接返回 500\n的错误，我们期望的是 400 bad\nrequest，那么我们如何修改呢？传统的controller-service-dao模式中，处理业务数据时，可以在service或者controller中处理，但是使用Spring\ndata\nrest时，由于框架自己生成相关接口，处理相关业务就要实现监听才行。有多种方式实现监听操作，我选择其中一种进行演示：通过实现\nRepositoryRestConfigurer 进行参数校验\n\n1、 创建 BookValidator ，实现 Validator 接口\n\nimage::https://resources.echocow.cn//file/2019/01/7343feb284ed45b38a0b4472a94e71fc__sunawtX11XFramePeer_20190108111013.png[BookValidator]\n\n2、 创建 RepositoryRestConfig，实现 RepositoryRestConfigurer 接口，覆盖\nconfigureValidatingRepositoryEventListener 方法\n\nimage::https://resources.echocow.cn//file/2019/01/9cf30d72db5f4047917956de98355eb9__sunawtX11XFramePeer_20190108111115.png[RepositoryRestConfig]\n\n3、 让 BookRestRepository 继承 PagingAndSortingRepository\n\nimage::https://resources.echocow.cn//file/2019/01/5a156227af6a4c469831d92f4fe2bf9d__sunawtX11XFramePeer_20190108111216.png[BookRestRepository]\n\n4、 运行测试\n\nimage::https://resources.echocow.cn//file/2019/01/3fe843e3490a45c5937958b0f7a4870c__sunawtX11XFramePeer_20190108111359.png[运行测试]\n\n5、 对比异常\n\nimage::https://resources.echocow.cn//file/2019/01/391e8d141c7948fc882776b478ddbb6d__sunawtX11XFramePeer_20190108111754.png[对比异常]\n\n6、 那么接下来就好办了，我们处理的异常的方式就和我们处理\nInvalidRequestException 异常的方式一样的了。为什么一开始不直接用它的\nRepositoryConstraintViolationException 呢？因为他是属于 spring data rest\n下的，前面我们并没有引入这个包，所以不能使用，现在引入了，自然可以使用了，并且可以删除我们以前的那个\nInvalidRequestException（我暂时不删除）\n\nimage::https://resources.echocow.cn//file/2019/01/5afdff176e4e42278ea8f5124fa29f79__sunawtX11XFramePeer_20190108112257.png[处理异常]\n\n7、 再次测试\n\nimage::https://resources.echocow.cn//file/2019/01/9bf9be7e0c2a4553895183e518a76768__sunawtX11XFramePeer_20190108112543.png[再次测试]\n\n8、 查错\n\nimage::https://resources.echocow.cn//file/2019/01/dd99a3d9cd9a4505ad4cb204a0f6e78f__sunawtX11XFramePeer_20190108112842.png[查错]\n\n9、 再次测试\n\nimage::https://resources.echocow.cn//file/2019/01/67587e8fbd004abeac1563917d6d0259__sunawtX11XFramePeer_20190108112936.png[再次测试]\n\n10、 这样就完成了，那么测试一下更新的时候呢？\n\nimage::https://resources.echocow.cn//file/2019/01/e01fb9efe8294a67a51f2aa3955c0902__sunawtX11XFramePeer_20190108113149.png[测试一下更新]\n\n这样一个参数的校验和异常处理就完成了！\n\n==== 方法自定义\n\n我们在实际时候，有很多他的方法我们是不希望暴露出来的，比如删除方法，如果我们不希望暴露出来，怎么办呢？\n\n===== 隐藏方法\n\n很简单，一个注解搞定！\nimage:https://resources.echocow.cn//file/2019/01/0a07ae1ca6d9464fa21f6496c38f0f5f__sunawtX11XFramePeer_20190108113858.png[隐藏方法]\n\n*为什么这里会报 500\n错误，这里其实并不需要我们再次进行处理，其原因在于我们配置的全局异常处理导致的*\n\nimage::https://resources.echocow.cn//file/2019/01/f40896d2e65749fd9ec4d8ff89c05431__sunawtX11XFramePeer_20190108114706.png[统一异常处理]\n\n所以处理方式很简单，指定一下他要拦截的 controller 即可\n\nimage::https://resources.echocow.cn//file/2019/01/46e268e8939f41cda577ea7b77be9e38__sunawtX11XFramePeer_20190108115504.png[controller]\n\nimage::https://resources.echocow.cn//file/2019/01/107c475d2e3c4565b07d73f62e7f1395__sunawtX11XFramePeer_20190108115558.png[测试]\n\nimage::https://resources.echocow.cn//file/2019/01/2db1f9635871403eac953e1d815db874__sunawtX11XFramePeer_20190108115810.png[测试]\n\n===== 修改方法\n\n但是在实际开发中，删除是要的有的，但是我们一般并不是真正的删除数据，而是通过修改他的\nisEnabled 或者 status 达到删除的目的，这个时候就要我们自定义删除方法了。\n\nimage::https://resources.echocow.cn//file/2019/01/75dc5e3d85df4de9b90344a4988defde__sunawtX11XFramePeer_20190108123753.png[修改方法]\n\n===== 隐藏字段\n\n查询的数据中，把实体的所有属性查出来了，那么我们要怎么隐藏其中的属性呢？很简单，一个注解即可\n\nimage::https://resources.echocow.cn//file/2019/01/42576f7dcb054844ab05b84cdde36e97__sunawtX11XFramePeer_20190108124021.png[_sunawtX11XFramePeer_20190108124021png]\n\n===== 自定义查询方法\n\n一种简单的实现就是直接利用 jpa，然后暴露出去即可，如下：\nimage:https://resources.echocow.cn//file/2019/01/3b9994f7f7c74f7e8aba058f7b6f2cce__sunawtX11XFramePeer_20190108142720.png[然后暴露出去即可]\n\nimage::https://resources.echocow.cn//file/2019/01/24345e49bf3f4eb8ae3bc6f8ee016744__sunawtX11XFramePeer_20190108142947.png[然后暴露出去即可]\n\n当然，这样你会发现他的url就是带有参数的了，这样也可以的。但是如果不想这样呢？比如根据作者来查询我希望的\nurl 是 `/api/v2/books/authors/{name}`，那么就要用到扩充了。也就是\n`@RepositoryRestController` 注解，当然你也可以直接使用 `@RestController`\n注解的。然后在里面添加方法即可，我就不再赘述啦！\n\n== 关于测试\n\n我们前面使用到了 2 种测试，使用 idea\n的插件，功能有限，还有就是使用强大的 postman，那么如何使用 spring boot\n的 test 测试呢？\n\n在这之前确保你已经安装了如下依赖\n\n[source,markup]\n....\ntestImplementation('org.springframework.boot:spring-boot-starter-test')\n....\n\n他自带的是 junit4，你也可以使用 junit5，也是非常方便的。现在我们先使用\njunit4 进行测试。\n\nimage::https://resources.echocow.cn//file/2019/01/99648fea469047efae037dab43971bae__sunawtX11XFramePeer_20190108144243.png[_sunawtX11XFramePeer_20190108144243png]\n\n这样我们便完成了一个接口的测试，你可以通过 `andExpect`\n详细的测试关于获取到的json对象的信息，你也可以接受一个返回值后进行打印查看。\n\n如果使用 junit5 呢？大体相同的\n\nimage::https://resources.echocow.cn//file/2019/01/8424aa58232e42a98d93f3c77f35063f__sunawtX11XFramePeer_20190108144503.png[_sunawtX11XFramePeer_20190108144503png]\n\n不过要注意的是，因为在应用内进行测试，所以我们不需要添加 `/api` 了。\n\n____\n为什么要这样？直接用 postman 不好吗？开发的时候，我们可以使用 postman\n一个一个测试，但是如果你想一整套的演示测试，这样一个一个的请求一个个测试是不是很麻烦？所以你可以将他直接书写到一个类中，比如书写一个\nBookV1Test 类，然后开发完 V1\n版本的，直接运行整个类，他会依次运行所有的方法，并且由于我们前面配置了测试时数据固定，不可变了，所以你可以对所有的获取到的数据进行预测，每次测试时运行的数据都是一致的，那么你就可以观察是否得到期望的值。一次性可以测试完所有的接口，是非常方便的（好像postman也有）。好就好在别人拿代码过去可以直接运行测试类查看结果了。但是我比较懒所以只写一个，大家知道就行了。\n____\n\n== 感触\n\n自己写文章总是拖拖拉拉，2019年的第一篇技术性文章（哪里有技术含量了？学渣的自我安慰。）上周六开始写的，到了周二才完工，中间无数事情打断，自己也找各种借口。而且写出来还不是很满意。不过收获颇多，在学习的时候就发现，对于spring\ndata\nrest百度的资料都是重复性的，价值不大的一堆东西，迫不得已要科学上网使用Google，但大多时候答案都不是自己想要的。对于国内的环境，一些新的技术流入真的会有一定阻碍，需要自己不断去摸索，这个过程无疑有时候是难熬的特别是英文水平有限的时候。在这个过程中遇到的无数问题大多都是从官网上的文档中得到的答案而不是百度或者google。相比起来学习一门技术最好的文档莫过于官网了，一篇小小的博客自己也遇到很多问题，或许还有很多地方没有说清楚，自己也会努力改正的。代码中也有很多瑕疵也有很多值得优化的地方。后面也会慢慢努力，提高自己书写能力，同时也欢迎大家和我交流学习。\n\n== 参考链接\n\n* http://www.ruanyifeng.com/blog/2011/09/restful.html[理解 RESTFul 架构\n阮一峰]\n* http://www.ruanyifeng.com/blog/2014/05/restful_api.html[RESTful API\n设计指南 阮一峰]\n* http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html[RESTful\nAPI 最佳实践 阮一峰]\n* https://docs.spring.io/spring-data/rest/docs/current/reference/html/[spring\ndata rest]\n\n","fields":{"slug":"/articles/2019/01/05/1546684795983.html","birthTime":"2019-01-08T06:59:45.014Z","modifiedTime":"2019-01-08","year":2019},"document":{"title":"spring boot restful API 从零到一完整实践"}},{"content":"= vue cli 3 项目与 electron 记录\n:page-description: vue cli 3 项目与 electron 记录\n:page-category: 归档\n:page-image: https://img.hacpai.com/bing/20181231.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2019/01/15/1547551133170.html\n:page-created: 1547556975715\n:page-modified: 1547557457352\n:toc:\n\n最近在重构我们上学期参加比赛做的一个小软件，https://github.com/GeneralAndKing/help-teacher[help\nteacher] 主要是作业收取的一款小工具，局域网内进行作业传输，简单用 vert.x\n做了一个登录注册以及数据备份与同步。为了参加比赛写的小软件，时间紧迫代码质量普遍不高，并且使用\nhttps://github.com/SimulatedGREG/electron-vue[electron-vue]\n进行搭建，也发现了不少问题，而那时候第一次接触\nvue，也不理解其组件化思想，也不会组件抽离什么的，然后这次放假了，有老师对我们项目感兴趣，我们开始重构我们的软件，不再使用\nelectron-vue ，一方面因为 vue cli 3\n生成的项目结构十分让我喜欢，约定大于配置也类似于 spring boot\n的思想，所以我不需要太多的配置文件，一个就够，这是我非常喜欢的，但是目前\nelectron-vue 还不支持，而且 vue cli 3\n拥有自己的图形化界面，可以更加方便的管理项目依赖以及插件；另一方面，我们以前的项目使用的\nvue + element ui 进行开发，也发现很多 element 的组件在 electron-vue\n中有着 bug 的存在，比如很简单的一个 MessageBox\n弹框，使用的时候都会报错，然后造成整个软件其它部分的瘫痪，所以后面我们急冲冲的引入了其他的弹框组件。这次重构是对上次的一个功能上的完善，也是一个性能的优化。不过自己虽然是一个后端，自己来做前端的时候也发现一些异曲同工之处，而且因为以前使用\nvert.x ，在接触 node\n以后发现了很多地方的相似之处。今天这篇文章，主要是记录一下这个项目开始的重构过程，所以不会是一种教程似的画风，大多都是一些问题上的处理方法进行记录。*不得不说的是，作为一个非专业的前端人员，在没有学过\nwebpack 、es6语法、babel\n等等一些前端方面的知识就直接上手开发，还是遇到很多问题的。*\n\n\n[source, bash]\n____\n项目地址：https://github.com/GeneralAndKing/teacher-tools[teacher-tools]\n____\n\n== 一些说明\n\n* 为了统一代码风格，使用 eslint，并且统一使用 vscode 进行开发\n* element 换为 iview， 同时为了方便修改 iview 主题，使用 less 替换原来的\nstylus\n* 从 npm 改为使用 yarn\n* 前端数据库依旧使用 nedb（暂定）\n* 为了实时聊天，学习 socketio（暂定）\n\n== 问题一： 项目整合\n\n我们在使用 vue cli 3 初始化项目后，他是一个纯正的 web\n项目，我们需要对他进行 electron\n进行整合，我们寻找了很久方案，最后终于找到一款插件进行整合 ——\nhttps://github.com/nklayman/vue-cli-plugin-electron-builder[vue-cli-plugin-electron-builder]\n, 安装很方便，直接图形化界面搜索安装即可\n\nimage::https://resources.echocow.cn//file/2019/01/cf3427538b7d40b2a7ebd832cc082c1f_image.png[搜索安装]\n\n或者命令行模式安装\n\n....\nvue add electron-builder\n....\n\n然后通过\n\n....\nyarn electron:serve\n\nyarn electron:build\n....\n\n进行使用。不过使用新的东西随之而来的问题就是，遇到什么问题或者其它需求的时候，只能自己摸索，而且没啥基础很难受。\n\n=== 1. 默认入口\n\n我们移动了插件生成的文件路径以及修改了文件名，那么如何保证他能够正确的使用并进入呢？我们卡在这问题很久，最后在\ngithub 的\nhttps://github.com/nklayman/vue-cli-plugin-electron-builder/issues/44[issue]\n上面找到答案，于是修改 vue.config.js 如下：\n\n[source,kotlin]\n....\npluginOptions: {\n  electronBuilder: {\n    builderOptions: {\n      files: [\n        {\n          'filter': ['**/*']\n        }\n      ],\n      extraFiles: ['./extensions/'],\n      asar:  false\n    },\n    mainProcessFile:  'src/main/main.js',\n    mainProcessWatch: ['src/main'],\n    // [1.0.0-rc.4+] Provide a list of arguments that Electron will be launched with during \"electron:serve\",\n    // which can be accessed from the main process (src/background.js).\n    // Note that it is ignored when --debug flag is used with \"electron:serve\", as you must launch Electron yourself\n    mainProcessArgs: []\n  }\n},\n....\n\n=== 2. 打包目录\n\n与以往不同的是，我们有多个页面，除了 electron 的，也有 web\n的，需要更具不同的进行打包，所以我们查找资料，修改 pages 参数如下：\n\n....\n...\npages:  getPages(),\n...\n/**\n* 根据 MODE 选择对应的 pages 进行打包\n*/\nfunction  getPages () {\n  return  process.env.MODE  ===  'web'\n  ? {\n    client: {\n      // entry for the page\n      entry:  'src/client/main.js',\n      // the source template\n      template:  'public/index.html',\n      // output as dist/index.html\n      filename:  'index.html'\n    }\n  }\n  : {\n    app: {\n      entry:  'src/app/main.js',\n      template:  'public/index.html',\n      filename:  'app.html'\n    },\n    communication: {\n      entry:  'src/communication/main.js',\n      template:  'public/index.html',\n      filename:  'communication.html'\n    },\n    forms: {\n      entry:  'src/forms/main.js',\n      template:  'public/index.html',\n      filename:  'forms.html'\n    }\n  }\n}\n....\n\n=== 3. 全局引入\n\n参照了官网的例子\n\n....\n...\nchainWebpack:  config  => {\n  config.resolve.alias\n  .set('app@', resolve('src/app'))\n  .set('_n', resolve('node_modules'))\n  .set('common@', resolve('src/common/'))\n  .set('communication@', resolve('src/communication/'))\n  .set('form@', resolve('src/form/'))\n  .set('client@', resolve('src/client/'))\n  const  types  = ['vue-modules', 'vue', 'normal-modules', 'normal']\n  types.forEach(type  =>  addStyleResource(config.module.rule('less').oneOf(type)))\n}\n...\n\n/**\n* 全局 less 引入\n* @param  {*}  rule 传递规则\n*/\nfunction  addStyleResource (rule) {\n  rule.use('style-resource')\n    .loader('style-resources-loader')\n    .options({\n      patterns: [\n        path.resolve(__dirname, './src/common/theme/iview-variables.less')\n      ]\n    })\n}\n....\n\n不过对于 stylus 还有另外一种方式，不知道为啥 less 不行\n\n....\ncss: {\n  loaderOptions: {\n    stylus: {\n      import: path.resolve(__dirname, './src/styles/global.styl')\n    }\n  }\n}\n....\n\n== 问题二：vue\n\n=== 1. 滚动条问题\n\n由于我们自定义了标题，没有使用默认的标题栏，然后就会有一种情况，他的滚动条会在标题右侧了\n\nimage::https://resources.echocow.cn//file/2019/01/dd4e900c3f174729917af0077e547818_1.jpg[滚动条]\n\n通过 css 修改如下：\n\n....\n@gak-no-visible: rgba(0, 0, 0, 0);\nhtml, body {\n  overflow: hidden;\n  height: 100%;\n}\n.gak-bg-no-visible {\n  background-color: @gak-no-visible;\n}\n.gak-scroll {\n  height: 100%;\n  -webkit-overflow-scrolling: touch;\n  overflow-y: auto;\n  /*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/\n  &::-webkit-scrollbar {\n    width: 8px;\n    height: 4px;\n    cursor: pointer;\n    .gak-bg-no-visible;\n  }\n  /*定义滚动条轨道 内阴影+圆角*/\n  &::-webkit-scrollbar-track {\n    border: none;\n    .gak-bg-no-visible;\n  }\n  /*定义滑块 内阴影+圆角*/\n  &::-webkit-scrollbar-thumb{\n    border-radius: 10px;\n    background-color: rgba(110, 110, 110, 0.2);\n  }\n}\n....\n\n修改后如图\n\nimage::https://resources.echocow.cn//file/2019/01/7d17cd6d68644ab6954d9c0d44237935_TIM20190115202528.jpg[滚动条]\n\n=== 2. soketio\n\n找了很多组件，原本一开始使用的是\nhttps://github.com/MetinSeylan/Vue-Socket.io[Vue-Socket.io]，但是发现对于\nvuex 他似乎已经不再支持，所以找了半天，改成使用了\nhttps://github.com/probil/vue-socket.io-extended[vue-socket.io-extended]，目前用起来十分方便。\n\n使用方式采用https://github.com/probil/vue-socket.io-extended/issues/91#issuecomment-397232621[外部文件扩展的方式]，能够在\naction 里面调用是及其方便的。\n\n=== 3. 打包问题\n\n因为我们包含的 vue 页面比较多，并且有一个不是 electron 项目而是 web\n项目，需要指定不同的打包路径，最后查阅资料，使用https://cli.vuejs.org/zh/guide/build-targets.html#%E5%BA%94%E7%94%A8[官方文档中]的方法如下：\n\n....\n\"scripts\": {\n  \"lint\": \"vue-cli-service lint\",\n  \"electron:build\": \"vue-cli-service electron:build\",\n  \"electron:serve\": \"vue-cli-service electron:serve\",\n  \"postinstall\": \"electron-builder install-app-deps\",\n  \"test:unit\": \"vue-cli-service test:unit\",\n  \"web:serve\": \"cross-env MODE=web vue-cli-service serve\",\n  \"web:build\": \"cross-env MODE=web vue-cli-service build --dest ./extensions/dist\"\n},\n....\n\n____\n为什么不用 -mode\nhttps://cli.vuejs.org/zh/guide/mode-and-env.html#%E6%A8%A1%E5%BC%8F[模式]\n而是使用 cross-env MODE=web ？因为我们这里 -mode\n读取不到，可能使用方式不对，所以采用以前的老办法了。\n____\n\n== 待解决的问题\n\n* ☐ `作业收取` 和 `屏幕分享`，如果单用 node\n的话是完成不了的（或者我们不会），希望用c++来完成，由我队友负责\n* ☐\n内存问题，上一次项目出现了一个典型情况就是内存占用比预期中的高，并且出现卡顿情况\n* ☐ 多页面情况 vuex 状态不共享\n* ☐ 开发时加载出现 首屏白屏情况，打包后不明显\n* ☐ vue devtools\n不管用，多次尝试各种组件都上了还是不行（要不就是临时的），最后使用本地的，但是只有第一次运行有效，后面都是无效\n* ☐ …很多杂七杂八的小问题\n\nimage::https://resources.echocow.cn//file/2019/01/70abbb3b474341849b67c77fba3cb906_image.png[imagepng]\n\nC++ 很强\n\n== 小总结\n\n其实是非常喜欢 electron 这种的，因为他的跨平台真的太棒，我队友操作系统是\n`主 windows + mint(移动硬盘)`，我的是\n`主 deepin + windows(移动硬盘)`，正是这种跨平台性能够让我们在不同平台下进行协作开发、然后重构的时候也对目录进行修改，也更好的进行组织以及抽取多页面的公共部分，不过自己其实还是喜欢后端哈哈哈哈，自己来做前端也是因为我们学校这一届实在找不到人一起来做了，只有我们两个人，做起来时间上很是费力，然后又要学车，大多是队友一直在弄，做了很多东西，自己就晚上弄弄页面，希望开学能够看得到成果吧。\n\n","fields":{"slug":"/articles/2019/01/15/1547551133170.html","birthTime":"2019-01-15T12:56:15.715Z","modifiedTime":"2019-01-15","year":2019},"document":{"title":"vue cli 3 项目与 electron 记录"}},{"content":"= spring boot security oauth2  构建简单安全的 restful api\n:page-description: spring boot security oauth2  构建简单安全的 restful api\n:page-category: spring\n:page-image: https://img.hacpai.com/bing/20181202.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2019/01/22/1548148450889.html\n:page-created: 1548148515069\n:page-modified: 1548153495225\n:toc:\n\n前段时间写了一篇博客，https://echocow.cn/articles/2019/01/05/1546684795983.html[spring\nboot restful API 从零到一完整实践] ，通过上篇文章构建了两个版本的\nrestful api，这篇博客，则是要在这基础上面，添加一个安全措施，我选择的是\noauth2 和 jwt 进行保护我们的 API，通过 spring security oauth2\n进行一步一步的配置我们的安全 API 接口服务。\n\n____\n博客地址：https://echocow.cn\n\n项目地址：https://github.com/lizhongyue248/spring-boot-restful-api/tree/security-one[github-security-one\n分支]\n____\n\n== Oauth2\n\nOAuth\n2.0关注客户端开发者的简易性。要么通过组织在资源拥有者和HTTP服务商之间的被批准的交互动作代表用户，要么允许第三方应用代表用户获得访问的权限。同时为Web应用，桌面应用和手机，和起居室设备提供专门的认证流程。https://baike.baidu.com/item/OAuth2.0/6788617?fr=aladdin[百度百科]。这篇文章同上一篇一样，将会详细记录如何使用\nspring security oauth2 进行构建一个安全 restful api ，当然，oauth2\n的概念和核心我不再赘述，具体可查看文末的参考链接。在这之前，我们需要先做一番准备。\n\n== 这篇文章能够带给你什么\n\n使用 spring security oauth2 autoconfigure 自动配置一个简单的 oauth2 认证\n\n== 在这之前\n\n你需要拥有一个已经能够成功构建起来的 spring boot\n的项目，它能够正常启动与访问访问，在这里我们使用上一篇\nhttps://echocow.cn/articles/2019/01/05/1546684795983.html[spring boot\nrestful API 从零到一完整实践] 构建的 restful API\n作为基础。如果你需要快速体验，你只需要建立一个拥有 Helloworld api\n接口的新项目即可。然后你需要加入以下依赖（gradle）\n\n....\n// 提供 spring security 支持\nimplementation('org.springframework.boot:spring-boot-starter-security')\n// 提供 oauth2 自动化配置\nimplementation(\"org.springframework.security.oauth.boot:spring-security-oauth2-autoconfigure:${springBootVersion}\")\n....\n\nimage::https://resources.echocow.cn//file/2019/01/49c932992ee34adebd7b3c3e624d92a2_image.png[在这之前]\n\n*同时你必须具备如下知识：*\n\n[arabic]\n. oauth2 中什么是 授权服务器\n. oauth2 中什么是 资源服务器\n. oauth2 中的四种授权模式（我们会使用到 授权码 模式和 密码 模式）\n. spring security 的部分知识\n. jpa 的使用\n\n以上概念本文不再提起，如有疑惑可选择去文末的参考链接自行选择性学习。\n\n=== 请求 url\n\n虽然上面说明了需要知道的东西，但是我在这里还是需要对我们需要使用到的 url\n进行一个简单说明，但是参数我不再详说。\n\n* /oauth/authorize GET 授权码模式获取授权码\n* /oauth/token POST 获取token、刷新token\n* /oauth/check_token POST 检测 token\n\n== 自动配置\n\nspring boot\n之所以能够如此受欢迎，最大的原因莫过于他提供的模板配置以及自动配置，我们甚至不需要写什么代码，只需要见得修改一下配置文件即可构建一个基于内存的简单的安全服务，所以最重要的，需要先配置一个\n*授权服务器*，通过它下发令牌\n\n=== 使用默认配置\n\n1、 添加注解：你需要为我们启动类添加一个启动的注解\n\nimage::https://resources.echocow.cn//file/2019/01/eec9a5a1d76b4645b6d4517d61a0233f_image.png[授权服务器]\n\n2、 我们通过一个注解就已经完成一个安全的授权的创建，运行查看输出日志。\n\nimage::https://resources.echocow.cn//file/2019/01/ef02659d7bc74ce48528c9a6484195d2_image.png[使用默认配置]\n\n3、 携带生成的 client id 进行访问，这里 /api\n是我自己添加项目路径，如果没有添加亲直接访问 /oauth/authorize\n\n....\nhttp://localhost:8080/api/oauth/authorize?response_type=code&client_id=d7003bdc-981c-4745-9eb4-673028b4c4e0&redirect_uri=http://example.com&scope=all\n....\n\nimage::https://resources.echocow.cn//file/2019/01/5821ad7971024e67a7aa0c478f9d6980_image.png[imagepng]\n\n4、 访问报错，这是因为我们没有配置 spring security\n造成的，所以需要回去配置一下，使用默认配置即可\n\nimage::https://resources.echocow.cn//file/2019/01/46bac0e60a024af89ec55896509e6743_image.png[spring\nsecurity]\n\n5、 再次运行，跳转登录界面\n\nimage::https://resources.echocow.cn//file/2019/01/1d480c70ade941749ad2df5ee2e15358_image.png[访问]\n\n6、 用户名 `user`，密码为刚才生成的 随机密码,登录\n\nimage::https://resources.echocow.cn//file/2019/01/9d9aede6f73b4521995753bc74583dbe_image.png[登录]\n\n7、 修改配置文件。注册一下回调地址\n\nimage::https://resources.echocow.cn//file/2019/01/6a206b4ad888453cb3d53d0cf5d33495_image.png[修改配置文件]\n\n8、 重启，使用新生成的 client id ，重新访问以及登录\n\nimage::https://resources.echocow.cn//file/2019/01/15d8ea79040349fc8b69ee18d5aa91d8_image.png[登录成功]\n\n9、 选择 Approve 同意授权，获取到授权码\n\nimage::https://resources.echocow.cn//file/2019/01/7e68ec23752b47c18e4b20468be9bffe_image.png[Approve]\n\n10、 使用授权码请求token\n\nimage::https://resources.echocow.cn//file/2019/01/9b9bbf0762e042a0aec1ac1c3f9d18ec_image.png[使用授权码请求token]\n\nimage::https://resources.echocow.cn//file/2019/01/45f06da95b294d75a4a1105bb783c3ac_image.png[使用授权码请求token]\n\nimage::https://resources.echocow.cn//file/2019/01/eaa2b00de92643f289e61d850c341312_image.png[获取成功]\n\n这就是使用他的自动配置的认证过程，接下来我们通过配置文件进行控制他的自动配置\n\n=== 自定义配置\n\n1、 修改 spring boot 的一些默认配置\n\nimage::https://resources.echocow.cn//file/2019/01/b4e0be84b5864f5a8837535f35365d13_image.png[imagepng]\n\n2、 配置两个用户\n\nimage::https://resources.echocow.cn//file/2019/01/32d02da8d3124b43be9a308a2b1e539e_image.png[imagepng]\n\n3、 现在我们拥有两个用户了，就可以去使用密码模式获取 token 了。\n\nimage::https://resources.echocow.cn//file/2019/01/ca3031eec3484516be64a136d7e853b2_image.png[imagepng]\n\nimage::https://resources.echocow.cn//file/2019/01/07cfd4841e884e0fa62c8a4b98be990e_image.png[imagepng]\n\nimage::https://resources.echocow.cn//file/2019/01/356671ef064c41249b3bdc36b9c58780_image.png[imagepng]\n\n=== 测试访问\n\n1、 直接访问我们已有的资源\n\nimage::https://resources.echocow.cn//file/2019/01/ce2affc8848b4ad0ba4944f77b501970_image.png[直接访问我们已有的资源]\n\n2、 携带上一步获取的 token 访问\n\nimage::https://resources.echocow.cn//file/2019/01/32fae0a7f55044618a338d33b40a56ac_image.png[携带上一步获取的\ntoken 访问]\n\n发现还是失败，为什么呢？因为我么并没有开启 资源服务器\n他没办法进行验证，所以我们接下来就是开启一个资源服务器\n\n=== 开启 资源服务器\n\n同样，一个注解即可\n\nimage::https://resources.echocow.cn//file/2019/01/ed740b7613af4bf5bfe73bd4c8ec5e24_image.png[资源服务器]\n\n重新获取token后，携带 token 访问\n\nimage::https://resources.echocow.cn//file/2019/01/73f58d0b76564206bf42712234f606ef_image.png[携带\ntoken 访问]\n\n=== 解析 token\n\n1、 尝试解析 token\n\nimage::https://resources.echocow.cn//file/2019/01/05163891823d4a768e0ba1c3e6a942e4_image.png[尝试解析\ntoken]\n\n2、 403，我们需要配置以支持 token 解析。\n\nimage::https://resources.echocow.cn//file/2019/01/96a634bddeea42f495fbf13120c3f4a1_image.png[支持\ntoken 解析]\n\n3、 重启后获取token再次解析\n\nimage::https://resources.echocow.cn//file/2019/01/9dc42141faa1418a87f902c141b16398_image.png[重启后获取token再次解析]\n\n=== 刷新 token\n\n____\n遗憾的是，如果只是用配置文件，是不能够 刷新 token 的，至少我没有成功。\n____\n\nimage::https://resources.echocow.cn//file/2019/01/79d18b46df3c41c2b65d31e2fad9d97f_image.png[imagepng]\n\nimage::https://resources.echocow.cn//file/2019/01/b8eff0fb4910412fa1f0618f6c4883cb_image.png[imagepng]\n\n发现不行，查看原因\n\nimage::https://resources.echocow.cn//file/2019/01/44b4875d231e44a4b4466bced77d801c_image.png[imagepng]\n\n可惜通过尝试各种办法都不行（在不增加类的情况下）解决办法参见\n\n* https://stackoverflow.com/questions/30454480/spring-security-oauth2-2-0-7-refresh-token-userdetailsservice-configuration-us[stackoverflow：spring-security-oauth2\n2.0.7 refresh token UserDetailsService Configuration -\nUserDetailsService is required]\n* https://segmentfault.com/a/1190000012338044[segmentfault: spring\nsecurity oauth2之refresh token]\n\n使用他的配置文件，我们不需要写任何代码，就完成了一个简单的内存认证，甚至我们可以直接通过修改\nuserDetailsService\n完成用户的认证，不过也发现了，他使用配置文件的方式功能很有限，局限性很强，不能够刷新\ntoken 是一个痛点啊，所以我们更期望于手动配置。\n\n== 参考链接\n\n[arabic]\n. http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html[理解OAuth 2.0\n阮一峰]\n. https://www.jianshu.com/p/9d0264d27c3b[Oauth2 授权]\n. https://docs.spring.io/spring-security-oauth2-boot/docs/current/reference/htmlsingle/[spring\noauth2 auto config]\n\n","fields":{"slug":"/articles/2019/01/22/1548148450889.html","birthTime":"2019-01-22T09:15:15.069Z","modifiedTime":"2019-01-22","year":2019},"document":{"title":"spring boot security oauth2  构建简单安全的 restful api"}},{"content":"= vue 加 Material Design 等于 vuetify\n:page-description: vue 加 Material Design 等于 vuetify\n:page-category: vue\n:page-image: https://img.hacpai.com/bing/20180704.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2019/01/27/1548583400911.html\n:page-created: 1548588886402\n:page-modified: 1548591313205\n:toc:\n\n最近一段时间，莫名从一个后端码农走了前端，越来越多的时间接触前端，从一个只会\nhtml + css 布局的小菜鸟到一些易上手的库，再到现在接触最多的\nvue，逐渐发现前端的世界广阔无比，比起后端有过之而无不及。自己定义自己希望成为一个全栈，但是后来渐渐发现自己理解的全栈似乎并不是前后端贯通，而似乎是一种渴求新知识的精神，或许自己也需要仔细思考一下这个问题。\n\n== 絮絮叨叨\n\n我本身不是一个安分的人，所以在使用 vue\n中一直寻找着一个易用组件库，能够满足我需求的同时，有着良好的交互，注意这里说的是交互，而不是简单的样式等等。自己以前封装过一点，但是代码可读性实在太差，自己写起来也费时费力，并且有基础不扎实等诸多原因，最后自己没有完成。然而寻找的路程却一直没有放弃，这段时间我用过效果好的两套组件库分别是\nhttp://element-cn.eleme.io/#/zh-CN[element ui] 和\nhttps://www.iviewui.com/[iview]，相比起来我更加喜欢 iview，在他发布 3.0\n以后也一直关注，相比起 element\n他拥有更多的灵活性，`render 函数`也让他的可定制性提高了很多。不过前段时间找组件的时候无意中发现一款国外的组件库\n——\nhttps://vuetifyjs.com/zh-Hans/[vuetify]，简直大爱，特别是他的交互，真的让我身心舒畅。在视觉上的设计的确出类拔萃，而且组件的多样化也让我十分激动，很多东西我需要在前面两个框架中使用都是需要自己自定义组件一部分的，可是\nvuetify 为我们准备好了很多，举几个例子：\n\n* 表格的可编辑\n* 输入框组交互/动画\n* 时间轴\n* 大量的数据嵌套/目录树\n* ……\n\n这些在前两个框架中都需要耗费时间去自定义的，然而在 vuetify\n却轻松无比。组件库的存在不正就是解决开发时间和效率的问题吗？在这前提下有着更好的交互和视觉，为什么不选择呢？有个不算缺点的缺点就是中文文档实在太少，然而这何尝不是一种挑战。而且\nvuetify 诞生至今不过一年却在\nhttps://github.com/vuetifyjs/vuetify[github] 上面拥有了 16K\nstar，社区也十分活跃，更新也很积极，可以看看他的版本记录\n\nimage::https://resources.echocow.cn//file/2019/01/d1e997304f1c497faaa2b332f3ea6b52_image.png[imagepng]\n\n== Material Design\n\n而且更为重要的一点，就是 `vuetify` 完全根据\nhttps://material.io/[原质化设计 Material Design]\n规范开发。每个组件都是手工制作的。Material Design 其实 14\n年就已经提出，我也是上个月才知晓，后悔当初不好好学习=-=\n\n他**强调了物理定律的扁平化设计**，将设计的重心从仅仅关注表面转移到了人与设计之间的交互。而这种风格正中我下怀，真的让我爱不释手，国外高使用频率的\napp 大多都采用了这种规范进设计，比起国内的 ios 风格个人更加愿意花时间在\nMD 上面，而且 MD\n是官方的设计规范，大方向上并不会错的。说实话真正让我喜欢 md 的来源于\nhttp://v.youku.com/v_show/id_XNzMxNzUyNzQ0[谷歌安卓Material主题 Google\nMaterial design], 看了后真心喜欢。虽然自己还不能够实际完全符合 Material\nDesign 的 ui 界面，但是自己也在不断努力与尝试。\n\n而 `vue + Material Design` 诞生了 `vuetify`，同时预计今年二月会迎来 1.5\nrelease，现在已经发布了 1.5 测试的第三个版本,2.0\n也在积极开发中。今天他就是我们的主角。\n\n== 搭建一个 vuetify 环境\n\n我们将要使用 vue-cli 3 进行搭建，并且最重要的，使用他的 ui\n界面进行管理我们的 vuetify 应用\n\n=== 在这之前\n\n你需要安装 `npm` 或者 `yarn` ，通过这两个工具安装 `vue cli 3`\n\n....\n~$ yarn global add @vue/cli\n// 或者\n~$ npm install @vue/cli -g\n....\n\n=== 开始\n\n开启 `vue cli 3` 的 `web` 管理界面\n\n....\n~$ vue ui\n....\n\n然后他会自动打开浏览器并跳转到 `http://localhost:8000/project/select`\n\nimage::https://resources.echocow.cn//file/2019/01/4614573e36d041bd993d4c7b8c9bd910_image.png[imagepng]\n\n=== 创建\n\n我们创建一个 `vue cli 3` 项目\n\nimage::https://resources.echocow.cn//file/2019/01/9897b78b9e6e4527a6c3da0fe7ebf383_image.png[imagepng]\n\nimage::https://resources.echocow.cn//file/2019/01/71097e29c15b410e80d5d8bd38b0087b_image.png[imagepng]\n\nimage::https://resources.echocow.cn//file/2019/01/c28678c5a7c44475a19a4da747b474f5_image.png[imagepng]\n\nimage::https://resources.echocow.cn//file/2019/01/100948748d67499a95b9fa7f9280ad2e_image.png[imagepng]\n\nimage::https://resources.echocow.cn//file/2019/01/533ff1da1bb94b7cbcad8bb349713cbb_image.png[imagepng]\n\n耐心等待\n\nimage::https://resources.echocow.cn//file/2019/01/d419d3f3e724462a8fcb126a87e485c3_image.png[imagepng]\n\n=== 引入\n\n初始化完成项目后\n\nimage::https://resources.echocow.cn//file/2019/01/a2e0e9965c824b858da9cd125907b740_image.png[imagepng]\n\n添加插件\n\nimage::https://resources.echocow.cn//file/2019/01/73047d23ebd8406e9690ce9bba7f9b1b_image.png[imagepng]\n\nimage::https://resources.echocow.cn//file/2019/01/35eaf42145ae477ca096811b7db13de4_image.png[imagepng]\n\nimage::https://resources.echocow.cn//file/2019/01/0f627f779c9245fe94e12ff125b2a75c_image.png[imagepng]\n\nimage::https://resources.echocow.cn//file/2019/01/78e9cf5ba3c04c339b28123570aabdeb_image.png[imagepng]\n\nimage::https://resources.echocow.cn//file/2019/01/38b9aa7c92ab4a54b146afaa1d451986_image.png[imagepng]\n\n=== 运行\n\nimage::https://resources.echocow.cn//file/2019/01/eb9b78ad7eec4b1c965422392a047d24_image.png[imagepng]\n\n运行查看下，在创建项目的时候，他自动帮我们用选择的构建工具下载好了依赖，直接运行借口\n\n....\nnpm run dev\n// 或者\nyarn serve\n....\n\n不过如果你使用了\neslint，那么运行会直接报错的，因为插件修改后的文件格式不符合默认的 elint\n规范的\n\nimage::https://resources.echocow.cn//file/2019/01/19bea1ef09f04874b954fe2d62126c52_image.png[imagepng]\n\n修改后运行\n\nimage::https://resources.echocow.cn//file/2019/01/dcd7afa96c7c4b21965b8163c5b65220_image.png[imagepng]\n\n访问测试\n\nimage::https://resources.echocow.cn//file/2019/01/c3ae74f70aa641a2b1922056fa0c8b1b_image.png[imagepng]\n\n=== 其它\n\n[arabic]\n. 全局 stylus 引入\n\n发现使用 `loaderOptions` 方式可以引入\n\n....\n// vue.config.js\ncss: {\n  loaderOptions: {\n  stylus: {\n    import:  path.resolve(__dirname, './src/styles/index.styl')\n  }\n}\n....\n\n但是查看网页代码会发现引入了很多次，所以我换了一种方式。在 `App.vue`\n中引入\n\nimage::https://resources.echocow.cn//file/2019/01/f0c95c10ee1846faaa4cfb10cba9486c_image.png[imagepng]\n\n[arabic, start=2]\n. vuetify 默认给页面加了滚动条\n\nVuetify默认开启了html滚动条，页面即使没有超出屏幕高度，他都是拥有滚动条的\n\nimage::https://resources.echocow.cn//file/2019/01/2b5868f1d9234bc094030e4b8ca9b722_image.png[imagepng]\n\n`App.vue` 中覆盖样式即可\n\nimage::https://resources.echocow.cn//file/2019/01/e656015eb62646a79c197e89bb1c899a_image.png[imagepng]\n\n== 回看\n\n总的来说搭建非常简单，使用也是及其简单，可能因为英语原因造成一点困难不过不碍事。上个月就想用了，不过项目已经上了\nelement UI 且时间紧，所以没办法，后面是用了一段时间的\niview，在这次的另外一个项目中果断换了\nvuetify，希望谈能够带给我惊喜。也希望通过它提高一下自己网页设计。\n\n","fields":{"slug":"/articles/2019/01/27/1548583400911.html","birthTime":"2019-01-27T11:34:46.402Z","modifiedTime":"2019-01-27","year":2019},"document":{"title":"vue 加 Material Design 等于 vuetify"}},{"content":"= 记录一下即将重构的项目 spring boot + restful\n:page-description: 记录一下即将重构的项目 spring boot + restful\n:page-category: 归档\n:page-image: https://img.hacpai.com/bing/20181206.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2019/02/18/1550500427954.html\n:page-created: 1550503106200\n:page-modified: 1550747893592\n:toc:\n\n真的很心累，说实话自己真的不想重构，因为自己真的很喜欢 spring data\njpa，他的简洁方便再加上 jdk 1.8\n的特性，真的不忍心将他从我项目中剥离，但是他的多对多问题真的给我带来了太多的烦恼，自己能力不足以解决这些问题，一路下来，磕磕碰碰，最终却还是不得不放弃它，又爱又恨。这篇博客，记录一下到目前为止自己不太满意的的一个项目吧，他在刚才已经被mybatis完全替换，为他保留一个分支。\n\n____\n项目地址：https://github.com/lizhongyue248/xiaoming[XIAOMING]\n\n分支地址：https://github.com/lizhongyue248/xiaoming/tree/master[XIAOMING-JPA]\n____\n\n== 能带给你什么\n\n[arabic]\n. spring data jpa 无限查询的一些解决办法\n. spring data redis 新的配置方式\n. spring boot restful 公共部分抽取\n\n== 技术选型\n\n* 核心框架：spring boot\n* 持久层：spring data jpa\n* 数据库：mysql\n* 安全：spring security oauth2\n* 加密：jwt\n* 缓存：redis\n\n== 带来的烦恼\n\n[arabic]\n. mysql 多对多的无限查询问题\n. redis 序列化问题\n\n== mysql 多对多的无限查询问题\n\n就像所描述那样，`sys_user` 表里面有 `roles` 字段存放所有权限，\n`sys_role` 里面有 `users` 字段。如下\n\n....\npublic class SysUser extends BaseEntity implements UserDetails {\n\n    // ...\n\n    /**\n     * 当前用户的权限\n     */\n    @ManyToMany(fetch = FetchType.EAGER)\n    @JsonIgnoreProperties(value = \"users\")\n    @JoinTable(name = \"sys_user_role\",\n            joinColumns = {@JoinColumn(name = \"user_id\", nullable = false)},\n            inverseJoinColumns = {@JoinColumn(name = \"role_id\", nullable = false)})\n    private List<SysRole> roles;\n\n    // ...\n}\n....\n\n....\npublic class SysRole extends BaseEntity {\n\n    // ...\n\n    /**\n     * 当前角色的菜单\n     */\n    @JsonIgnoreProperties(value = \"roles\")\n    @ManyToMany(cascade = CascadeType.MERGE, fetch = FetchType.EAGER)\n    @JoinTable(name = \"sys_permission_role\", joinColumns = @JoinColumn(name = \"role_id\"),\n            inverseJoinColumns = @JoinColumn(name = \"permission_id\"))\n    private List<SysPermission> permissions = new ArrayList<>();\n\n    /**\n     * 当前角色对应的用户\n     * 双向映射造成数据重复查询死循环问题\n     */\n    @ManyToMany(mappedBy = \"roles\")\n    private List<SysUser> users = new ArrayList<>();\n\n}\n....\n\n....\npublic class SysPermission extends BaseEntity {\n    // ...\n\n    /**\n     * 菜单角色\n     * 双向映射造成数据重复查询死循环问题\n     */\n    @ManyToMany(mappedBy = \"permissions\")\n    private List<SysRole> roles = new ArrayList<>();\n}\n....\n\n存放拥有当前角色的所有用户，然后带来的结果是，他们两一直互相无限查询，打印无数\nsql 语句最后**堆栈溢出**。尝试过很多解决办法，大概有如下几种： -\n`@JsonIgnore`\n注解，但是在数据库查询出来的时候会忽略掉此字段，所以不可行。 -\n`@JsonIgnoreProperties` 注解，奇怪的是时而有效时而无效。 -\n`@Proxy(lazy = false)` 注解，无效 - `fetch = FetchType.EAGER`\n属性，需要在配置文件中添加如下配置才有小，不然要产生一个 什么 bag 异常\n\n....\njpa:\n  properties:\n    hibernate:\n      enable_lazy_load_no_trans: true\n....\n\n但是会带来`N+1` 问题，查询效率有所降低，不过小项目无所谓=0= -\n`@ToString(exclude = {\"users\", \"permissions\"})` 同时需要生成的 tostring\n方法忽略掉这些字段，不然在使用时会报\n`LazyInitializationException ... no session` 错误。\n\n== redis 序列化问题\n\n我缓存选择的是 redis 缓存，而在将他存入的时候遇到了一个 spring data jpa\n分页查询无法序列化的问题，因为他没有默认的无参构造，因而我的分页查询无法使用\nredis 缓存。为啥不自己写一个？懒=-=\n\nredis 的 `CacheManager` 网上搜到的方式大多不管用，我的方式如下：\n\n....\n    @Bean\n    @Override\n    public CacheManager cacheManager() {\n        // 配置在这里配置\n        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig()\n                .entryTtl(Duration.ofHours(12)) // 过期时间\n                .prefixKeysWith(applicationProperties.getName()) // 缓存前缀\n                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(keySerializer())) // 序列化键\n                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(valueSerializer())) // 序列化值\n                .disableCachingNullValues();\n        // 创建缓存管理器\n        return RedisCacheManager\n                .builder(RedisCacheWriter.nonLockingRedisCacheWriter(connectionFactory))\n                .cacheDefaults(redisCacheConfiguration)\n                .transactionAware()\n                .build();\n    }\n....\n\n自己也写了 `gson` 和 `FastJson` 的序列化，有兴趣的可以看看 github 项目的\n`RedisConfig`\n\n*然而真正让我放弃 spring data jpa\n的原因，其实是因为在我前几天修改后，尝试查询，第一次查询成功并存入redis，然后再次查询他就报序列化错误，我尝试解决了三天，实在找不到解决的办法了，也在\nhttps://stackoverflow.com/questions/54722546/sprng-boot-jpa-redis-lazyinitializationexception[stackoverflow]\n发起提问但是依旧没有办法解决，所以只有完全放弃 spring data jpa 换成\nmybatis试试了。*\n\n== 公共部分抽取\n\n对于一个 restful 风格的项目，他的 controller、service、repository\n层都是有公共的部分的，如果不抽取，需要写很多重复的代码，作为一个合(zhuang)格(bi)的\nJAVA\n程序员，肯定是不容许他的存在，更何况还会带来一处修改处处修改的尴尬，所以对他进行了公共部分抽取。\n\n=== BaseEntity\n\n提取实体类的公共字段\n\n....\npackage cn.echocow.xiaoming.base;\n\nimport com.fasterxml.jackson.databind.annotation.JsonDeserialize;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;\nimport com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.springframework.data.annotation.CreatedBy;\nimport org.springframework.data.annotation.CreatedDate;\nimport org.springframework.data.annotation.LastModifiedBy;\nimport org.springframework.data.annotation.LastModifiedDate;\nimport org.springframework.data.jpa.domain.support.AuditingEntityListener;\n\nimport javax.persistence.*;\nimport java.io.Serializable;\nimport java.time.LocalDateTime;\n\n/**\n * 实体类基类\n *\n * @author Echo\n * @version 1.0\n * @date 2019-02-02 22:03\n */\n@Getter\n@Setter\n@MappedSuperclass // 重点\n@EntityListeners(AuditingEntityListener.class) // 自动填充创建、修改时间和创建、修改用户\npublic abstract class BaseEntity implements Serializable {\n\n    /**\n     * id 主键\n     */\n    @Id\n    @Column(name = \"id\", nullable = false)\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    /**\n     * 排序\n     */\n    @OrderColumn(name = \"sort\")\n    private Integer sort;\n\n    /**\n     * 创建时间\n     */\n    @JsonDeserialize(using = LocalDateTimeDeserializer.class)\n    @JsonSerialize(using = LocalDateTimeSerializer.class)\n    @CreatedDate\n    @Column(name = \"create_time\", nullable = false, columnDefinition = \"datetime not null default now() comment '创建时间'\")\n    private LocalDateTime createTime;\n\n    /**\n     * 创建用户\n     */\n    @CreatedBy\n    @Column(name = \"create_user\")\n    private String createUser;\n\n    /**\n     * 修改时间\n     */\n    @JsonDeserialize(using = LocalDateTimeDeserializer.class)\n    @JsonSerialize(using = LocalDateTimeSerializer.class)\n    @LastModifiedDate\n    @Column(name = \"modify_time\", nullable = false, columnDefinition = \"datetime not null default now() comment '修改时间'\")\n    private LocalDateTime modifyTime;\n\n    /**\n     * 修改用户\n     */\n    @LastModifiedBy\n    @Column(name = \"modify_user\")\n    private String modifyUser;\n\n    /**\n     * 备注\n     */\n    @Column(name = \"remark\")\n    private String remark;\n\n}\n....\n\n=== BaseRepository\n\n公共的仓库基类，一般适用于对公共字段的条件查询等。\n\n....\npackage cn.echocow.xiaoming.base;\n\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.JpaSpecificationExecutor;\nimport org.springframework.data.jpa.repository.Modifying;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.NoRepositoryBean;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.io.Serializable;\nimport java.util.List;\n\n/**\n * 资源仓库基类\n *\n * @author Echo\n * @version 1.0\n * @date 2019-02-02 20:25\n */\n@NoRepositoryBean\npublic interface BaseRepository<T, ID> extends JpaRepository<T, ID>, JpaSpecificationExecutor<T> {\n\n    /**\n     * 批量删除\n     *\n     * @param ids ids\n     */\n    @Modifying\n    @Transactional(rollbackFor = Exception.class)\n    @Query(\"delete from #{#entityName} e where e.id in (:ids)\")\n    void deleteBatch(@Param(\"ids\")List<Long> ids);\n}\n....\n\n=== BaseService\n\nservice 公共接口\n\n....\npackage cn.echocow.xiaoming.base;\n\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.Pageable;\nimport java.io.Serializable;\nimport java.util.List;\n\n/**\n * 服务接口基类\n *\n * @author Echo\n * @version 1.0\n * @date 2019-02-02 20:25\n */\npublic interface BaseService<T extends BaseEntity, ID extends Serializable, R extends BaseRepository<T, ID>> {\n\n    /**\n     * 通过 id 更新实体\n     *\n     * @param id     id\n     * @param entity 实体\n     * @return 更新后的实体\n     */\n    T update(ID id, T entity);\n\n    /**\n     * 保存实体\n     *\n     * @param entity 实体对象\n     * @return 保存后的实体\n     */\n    T save(T entity);\n\n    /**\n     * 通过 id 查询\n     *\n     * @param id id\n     * @return 实体\n     */\n    T findById(ID id);\n\n    /**\n     * 通过 id 删除\n     *\n     * @param id id\n     */\n    void deleteById(ID id);\n\n    /**\n     * 判断是否存在指定 id 对象\n     *\n     * @param id id\n     * @return 结果\n     */\n    boolean exists(ID id);\n\n    /**\n     * 查询所有\n     *\n     * @return 集合\n     */\n    List<T> findAll();\n\n    /**\n     * 分页查询\n     *\n     * @param pageable 分页\n     * @return 结果\n     */\n    Page<T> findAll(Pageable pageable);\n\n    /**\n     * 批量删除\n     *\n     * @param ids id 集合\n     */\n    void deleteBatch(List<Long> ids);\n}\n....\n\n=== BaseServiceImpl\n\n....\npackage cn.echocow.xiaoming.base.impl;\n\nimport cn.echocow.xiaoming.utils.CustomBeanUtils;\nimport cn.echocow.xiaoming.base.BaseEntity;\nimport cn.echocow.xiaoming.base.BaseRepository;\nimport cn.echocow.xiaoming.base.BaseService;\nimport cn.echocow.xiaoming.exception.ResourceNoFoundException;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cache.annotation.CacheConfig;\nimport org.springframework.cache.annotation.CacheEvict;\nimport org.springframework.cache.annotation.CachePut;\nimport org.springframework.cache.annotation.Cacheable;\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.util.Assert;\n\nimport java.io.Serializable;\nimport java.util.List;\n\n/**\n * 服务实现基类\n *\n * @author Echo\n * @version 1.0\n * @date 2019-02-02 20:26\n */\n@CacheConfig(cacheNames = {\"baseService\"}, keyGenerator = \"cacheKeyGenerator\")\npublic abstract class BaseServiceImpl<T extends BaseEntity, ID extends Serializable, R extends BaseRepository<T, ID>> implements BaseService<T, ID, R> {\n\n    @Autowired\n    protected R baseRepository;\n\n    @Override\n    @CachePut\n    public T update(ID id, T entity) {\n        T exist = baseRepository.findById(id).orElseThrow(() ->\n                new ResourceNoFoundException(String.format(\"the resource by id %s not found!\", id)));\n        BeanUtils.copyProperties(entity, exist, CustomBeanUtils.getNullPropertyNames(entity));\n        return exist;\n    }\n\n    @Override\n    @CacheEvict\n    public T save(T entity) {\n        return baseRepository.save(entity);\n    }\n\n    @Override\n    @Cacheable\n    public T findById(ID id) {\n        return baseRepository.findById(id).orElseThrow(() ->\n                new ResourceNoFoundException(String.format(\"the resource by id %s not found!\", id))\n        );\n    }\n\n    @Override\n    @CacheEvict(allEntries = true)\n    public void deleteById(ID id) {\n        if (!baseRepository.existsById(id)) {\n            throw new ResourceNoFoundException(String.format(\"the resource by id %s not found!\", id));\n        }\n        baseRepository.deleteById(id);\n    }\n\n    @Override\n    @Cacheable\n    public boolean exists(ID id) {\n        return baseRepository.existsById(id);\n    }\n\n    @Override\n    @Cacheable\n    public List<T> findAll() {\n        return baseRepository.findAll();\n    }\n\n    @Override\n    public Page<T> findAll(Pageable pageable) {\n        return baseRepository.findAll(pageable);\n    }\n\n    @Override\n    @CacheEvict(allEntries = true)\n    public void deleteBatch(List<Long> ids) {\n        Assert.notNull(ids, \"ids can not is null!\");\n        baseRepository.deleteBatch(ids);\n    }\n}\n....\n\n=== BaseController\n\n最重要的，restful 风格基类 controller\n\nRestResource 是对单个资源的封装，使用 spring boot hateoas 生成对应的\nhateoas\n\nRestResources 是对多个资源集合的封装，使用 spring boot hateoas\n生成对应的 hateoas\n\n....\npackage cn.echocow.xiaoming.base;\n\nimport cn.echocow.xiaoming.exception.InvalidRequestException;\nimport cn.echocow.xiaoming.resource.ApplicationResource;\nimport cn.echocow.xiaoming.resource.PageSimple;\nimport cn.echocow.xiaoming.resource.RestResource;\nimport cn.echocow.xiaoming.resource.RestResources;\nimport cn.echocow.xiaoming.resource.annotation.PageResult;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.PageRequest;\nimport org.springframework.hateoas.Resources;\nimport org.springframework.http.HttpEntity;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.validation.BindingResult;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.validation.Valid;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * @author Echo\n * @version 1.0\n * @date 2019-02-03 21:43\n */\npublic abstract class BaseController<T extends BaseEntity, S extends BaseService> {\n\n    @Autowired\n    private S baseService;\n\n    /**\n     * 获取控制器，通过反射添加 rest hateoas\n     *\n     * @return 控制器\n     */\n    public abstract Class getControllerClass();\n\n    /**\n     * 保存一个资源\n     * POST    /{entity}\n     *\n     * @param entity        实体\n     * @param bindingResult 检验结果\n     * @return http 响应\n     */\n    @PostMapping\n    public HttpEntity<?> saveResource(@Valid @RequestBody T entity, BindingResult bindingResult) {\n        if (bindingResult.hasErrors()) {\n            throw new InvalidRequestException(\"Invalid parameter\", bindingResult);\n        }\n        entity.setId(null);\n        return new ResponseEntity<>(new RestResource<>(baseService.save(entity), getControllerClass()), HttpStatus.CREATED);\n    }\n\n    /**\n     * 删除指定 id 的资源\n     * DELETE   /sysUsers/{id}\n     *\n     * @param id 资源 id\n     * @return http 响应\n     */\n    @DeleteMapping(\"/{id}\")\n    public HttpEntity<?> deleteResource(@PathVariable Long id) {\n        baseService.deleteById(id);\n        return new ResponseEntity<>(new ApplicationResource(), HttpStatus.NO_CONTENT);\n    }\n\n    /**\n     * 更新一个资源，提供当前资源的所有信息\n     * PUT    /{entity}/{id}\n     *\n     * @param id            资源 id\n     * @param entity        更新后的资源\n     * @param bindingResult 参数校验\n     * @return http 响应\n     */\n    @PutMapping(\"/{id}\")\n    public HttpEntity<?> putResource(@PathVariable Long id, @Valid @RequestBody T entity, BindingResult bindingResult) {\n        if (bindingResult.hasErrors()) {\n            throw new InvalidRequestException(\"Invalid parameter\", bindingResult);\n        }\n        return patchResource(id, entity);\n    }\n\n    /**\n     * 更新一个资源，提供当前资源的部分信息\n     * PATCH    /{entity}/{id}\n     *\n     * @param id     资源 id\n     * @param entity 更新后的资源\n     * @return http 响应\n     */\n    @PatchMapping(\"/{id}\")\n    public HttpEntity<?> patchResource(@PathVariable Long id, @RequestBody T entity) {\n        return ResponseEntity.ok(new RestResource<>(baseService.update(id, entity), getControllerClass()));\n    }\n\n    /**\n     * 获取指定 id 的资源\n     * Get    /{entity}/{id}\n     *\n     * @param id 资源 id\n     * @return http 响应\n     */\n    @GetMapping(\"/{id}\")\n    public HttpEntity<?> getResource(@PathVariable Long id) {\n        return ResponseEntity.ok(new RestResource<>(baseService.findById(id), getControllerClass()));\n    }\n\n    /**\n     * 获取所有资源/分页，可以直接使用 Pageable 来接受，忘记改了=-=\n     *\n     * @param page 页码\n     * @param size 大小\n     * @return http 响应\n     */\n    @GetMapping\n    @PageResult\n    public HttpEntity<?> getAllOrPagesResources(\n            @RequestParam(required = false) Integer page,\n            @RequestParam(required = false) Integer size) {\n        if (page == null || size == null || page <= 0 || size <= 0) {\n            List<T> all = baseService.findAll();\n            return ResponseEntity.ok(new Resources<>(all.stream()\n                    .map(entity -> new RestResource<>(entity, getControllerClass()))\n                    .collect(Collectors.toList())));\n        }\n        Page<T> result = baseService.findAll(PageRequest.of(--page, size));\n        RestResources<RestResource> resources = new RestResources<>(result.stream()\n                .map(entity -> new RestResource<>(entity, getControllerClass()))\n                .collect(Collectors.toList()));\n        resources.setPage(new PageSimple(result.getSize(), result.getNumber() + 1, result.getTotalElements(),\n                result.getTotalPages(), result.hasPrevious(), result.hasNext()));\n        return ResponseEntity.ok(resources);\n    }\n\n}\n....\n\n然后基础的 rest 风格就完成了。\n\n=== 为什么不用 spring data rest\n\n他不能用缓存！！！他不能用缓存！！！他不能用缓存！！！我找了一段时间的资料，都没找到，难受。\n\n为了加 hateoas 真的累死我了，到后面还不满意，分页的 hateoas 我用 aop\n进行的单独封装，通过添加注解进行拦截再次封装，不过尝试了很多很多办法，最后只能使用字符串拼接。\n\n....\npackage cn.echocow.xiaoming.aop;\n\nimport cn.echocow.xiaoming.resource.RestResources;\nimport cn.echocow.xiaoming.resource.annotation.PageResult;\nimport cn.echocow.xiaoming.resource.PageSimple;\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.*;\nimport org.aspectj.lang.reflect.MethodSignature;\nimport org.springframework.hateoas.Link;\nimport org.springframework.hateoas.mvc.ControllerLinkBuilder;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.stereotype.Component;\n\n/**\n * 对于分页的集合，进行添加分页信息\n *\n * @author Echo\n * @version 1.0\n * @date 2019-02-02 15:55\n */\n@Component\n@Aspect\npublic class RestResultAop {\n\n    @Pointcut(\"@annotation(cn.echocow.xiaoming.resource.annotation.PageResult)\")\n    public void pageResult() { }\n\n    @AfterReturning(value = \"pageResult()\", returning = \"result\")\n    public void doAfterReturningAdvice1(JoinPoint joinPoint, Object result) {\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n        PageResult annotation = signature.getMethod().getAnnotation(PageResult.class);\n        if (annotation == null) {\n            return;\n        }\n        try {\n            ResponseEntity res = (ResponseEntity) result;\n            if (!res.hasBody()) {\n                return;\n            }\n            if (!(res.getBody() instanceof RestResources)) {\n                return;\n            }\n            RestResources resources = (RestResources) res.getBody();\n            if (resources == null) {\n                return;\n            }\n            PageSimple pageInfo = resources.getPage();\n            if (pageInfo == null) {\n                return;\n            }\n            Integer size = pageInfo.getSize();\n            Integer page = pageInfo.getNumber();\n            // 尝试多次，只能手动封装\n            String uri = ControllerLinkBuilder.linkTo(joinPoint.getTarget().getClass()).toString();\n            resources.add(new Link(uri + \"?page=\" + page + \"&size=\" + size).withSelfRel());\n            if (pageInfo.hasPrevioud()) {\n                resources.add(new Link(uri + \"?page=\" + (page - 1) + \"&size=\" + size).withRel(Link.REL_PREVIOUS));\n            }\n            if (pageInfo.hasNext()) {\n                resources.add(new Link(uri + \"?page=\" + (page + 1) + \"&size=\" + size).withRel(Link.REL_NEXT));\n            }\n            resources.add(new Link(uri + \"?page=\" + 1 + \"&size=\" + size).withRel(Link.REL_FIRST));\n            resources.add(new Link(uri + \"?page=\" + pageInfo.getTotalPages() + \"&size=\" + size).withRel(Link.REL_LAST));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n....\n\n== 感受\n\n因为前面说的一个https://stackoverflow.com/questions/54722546/sprng-boot-jpa-redis-lazyinitializationexception[redis\n的问题]不得不放弃，自己还是太菜了。这是最后一个项目，完成了他，自己就要开始考研道路，估计基本不会再去写项目了。不想留下遗憾，他的结构也是我比较满意的，不过是实话，不太喜欢分层架构，跟喜欢一捅到底的架构，不过也希望这个项目不会让自己失望，加油！\n\n","fields":{"slug":"/articles/2019/02/18/1550500427954.html","birthTime":"2019-02-18T15:18:26.200Z","modifiedTime":"2019-02-21","year":2019},"document":{"title":"记录一下即将重构的项目 spring boot + restful"}},{"content":"= submail 短信接口以及 spring boot 集成\n:page-description: submail 短信接口以及 spring boot 集成\n:page-category: spring\n:page-image: https://img.hacpai.com/bing/20171205.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2019/02/22/1550766482735.html\n:page-created: 1550772309829\n:page-modified: 1550772342307\n:toc:\n\n短信接口这种东西，在现在的环境下基本 web\n应用都会去准备的，毕竟移动端还是占据不少市场的，方便快捷与可控都是比起用户名密码方便很多。在对比多个短信提供商后，我最终选择了\nhttps://www.mysubmail.com/[submail]，主要是有以下几点原因：\n\n[arabic]\n. 接口的灵活性，提供多种类型接口\n，包括单/多条内容自定义短信，单/多条模板变量短信，模板控制接口，短信日志接口，余额接口。这些接口包含了所有场景，而对比阿里大鱼、腾讯云，每次都要申请还要上传一堆东西（什么域名证书啊，还必须一致），时间两小时内，然而\nsubmail\n不需要上传任何东西，写好后直接发起审核，并且白天几分钟就通过，刚才是晚上十二点，我发起审核，半小时不到就通过了，速度太赞。\n. 后台真的好看，比起阿里大鱼、腾讯云、106这些，真的好看了不是一点，提供了可视化图表，余额提醒这些，最赞提供了非常详细的错误日志，方便排错，\n. 价格优惠，短信分为事务类和运营类，一般应用事务类就足够了。第一次体验\n35 元就有 1K 条，后面购买 400 元 1W 条，比阿里大鱼，腾讯云便宜 50 元。\n. 操作十分简单，请求接口就完事儿（好像都是这样，，逃～）\n\n== 这篇文章能够带给你什么\n\n[arabic]\n. submail 的使用\n. 使用 `httpclient` + `fastjson` 工具发送一条信息\n. 使用 `httpclient` + `fastjson` 工具发送多条信息\n. 在 spring-boot 中集成 submail\n\n== submail 的使用\n\n一个网站的使用是非常简单的，无非就是官网\nhttps://www.mysubmail.com/[submail]\n注册登录控制台，所以我直接从控制台这里开始，我姑且假设你已经购买了优惠包已经拥有了\n1K 条的短信量。\n\n=== 接口说明\n\n在开始之前，我们需要了解一下\nhttps://www.mysubmail.com/chs/documents/developer/YPWD84[submail\n的短信接口]\n\n[arabic]\n. message/send\n接口，优点：方便、快速对接使用，*免模板，可直接提交任意内容（需要符合短信发送规范，短信签名前置）*，缺点：并发效率不高，适用于并发小，内容变动或模板变动较多的场景（并发效率低指高于每秒1000的并发，低于这个并发需求请无视）\n. message/xsend\n接口，优点：高稳定性，*低延迟，高并发*，适用验证码类要求低延迟，高请求效率的场景，缺点：接入时需要提前创建模板，并指定模板ID\n. message/multisend\n接口，优点：接入方便，*免模板，可直接提交任意内容（需要符合短信发送规范，短信签名前置），支持大批量群发*，缺点：效率低于multixsend，如果每小时的发送量低于百万级，请无视此缺点\n. message/multixsend\n接口，优点：高效，*高稳定性，低延迟，超高并发*，适用大批量群发场景（50个号码/API,100线程并发，每分钟可处理15万左右的群发需求）缺点：接入时需要提前创建模板，并指定模板ID\n. message/template 接口，可以获取、创建、编辑或删除您的短信模板。\n. log/message 接口，\n可以方便的查询详细的短信发送日志和状态记录，也还可以按短信模板、手机号码、发送状态、开始/结束日期等条件筛选日志的返回结果。\n. balance/sms 接口，可以实时获取账户的短信余额。\n\n=== 创建模板\n\n我们选择使用 `2` 和 `4`\n的接口，因为它具有高稳定性和高并发的特点。使用这两个接口的前提是我们需要创建短信模板\n\nimage::https://resources.echocow.cn/file/2019/2/22/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190222005719.png[创建模板]\n\nimage::https://resources.echocow.cn/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190222005948.png[创建]\n\n创建完成耐心等待审核即可\n\n=== 创建 APPID\n\n在有了模板后，我们需要创建一个\nAPPID，简单的说就是密钥，用来进行认证短信发送的。\n\nimage::https://resources.echocow.cn/file/2019/2/22/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190222010204.png[创建\nAPPID]\n\n=== 测试短信\n\n完成上面两步就可以测试短信了\n\nimage::https://resources.echocow.cn/file/2019/2/22/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190222010429.png[测试短信]\n\n然后点击最下面的发送即可，这就是 submail\n的使用方式，所测的更多功能需要大家自己多多探索，非常简单。\n\n== 发送一条信息\n\n使用 maven 或者 gradle 引入依赖 `fastjson` 和 `httpclient`\n\n....\n 'fastjson' : 'com.alibaba:fastjson:1.2.56',\n`'httpClient' : 'org.apache.httpcomponents:httpclient:4.5.7'\n....\n\n我们采用 *明文的密匙验证模式*，因为他简单，具体参见\nhttps://www.mysubmail.com/chs/documents/developer/gbibb3\n\n创建测试用例，具体请看注释\n\n[source,java]\n----\n    @Test\n    public void messageOneTest() throws Exception {\n        CloseableHttpClient httpclient = HttpClients.createDefault();\n        // api 地址\n        String url = \"https://api.mysubmail.com/message/xsend\";\n        // 需要使用 POST 请求\n        HttpPost httpPost = new HttpPost(url);\n        JSONObject jsonParam = new JSONObject();\n        // 创建的 APPID\n        jsonParam.put(\"appid\", \"\");\n        // 创建的 APPID 的 APPKEY\n        jsonParam.put(\"signature\", \"ae54fe1399bafd5728e88ca29a7e22f8\");\n        // 你的模板编号，见 https://www.mysubmail.com/chs/documents/developer/MmSw12\n        jsonParam.put(\"project\", \"\");\n        // 接收人手机号\n        jsonParam.put(\"to\", \"\");\n        JSONObject vars = new JSONObject();\n        // 模板变量\n        vars.put(\"code\", \"1234\");\n        vars.put(\"time\", \"30\");\n        jsonParam.put(\"vars\", vars.toJSONString());\n        StringEntity entity = new StringEntity(jsonParam.toJSONString(), \"UTF-8\");\n        entity.setContentEncoding(\"UTF-8\");\n        entity.setContentType(\"application/json\");\n        httpPost.setEntity(entity);\n        // 响应体\n        HttpResponse resp = httpclient.execute(httpPost);\n        String respContent = null;\n        if (resp.getStatusLine().getStatusCode() == 200) {\n            HttpEntity he = resp.getEntity();\n            respContent = EntityUtils.toString(he, \"UTF-8\");\n        }\n        System.out.println(respContent);\n    }\n----\n\n== 发送多条信息\n\n使用 maven 或者 gradle 引入依赖 `fastjson` 和 `httpclient`\n\n....\n 'fastjson' : 'com.alibaba:fastjson:1.2.56',\n`'httpClient' : 'org.apache.httpcomponents:httpclient:4.5.7'\n....\n\n创建测试用例，重复地方不再加注释啦\n\n....\n    @Test\n    public void messageManyTest() throws Exception {\n        CloseableHttpClient httpclient = HttpClients.createDefault();\n        String url = \"https://api.mysubmail.com/message/multixsend\";\n        HttpPost httpPost = new HttpPost(url);\n        JSONObject jsonParam = new JSONObject();\n        jsonParam.put(\"appid\", \"\");\n        jsonParam.put(\"signature\", \"\");\n        jsonParam.put(\"project\", \"\");\n\n        // 模板变量\n        JSONObject vars = new JSONObject();\n        vars.put(\"code\", \"\");\n        vars.put(\"time\", \"\");\n\n        // 第一个接受者\n        JSONObject person1 = new JSONObject();\n        person1.put(\"to\", \"\");\n        // 此人的模板变量，因为我做测试，所以所有的人都用同一个变量即可\n        person1.put(\"vars\", vars);\n\n        // 第二个接受者\n        JSONObject person2 = new JSONObject();\n        person2.put(\"to\", \"\");\n        // 此人的模板变量，因为我做测试，所以所有的人都用同一个变量即可\n        person2.put(\"vars\", vars);\n\n        // 接受者数组\n        JSONArray multi = new JSONArray();\n        multi.add(person1);\n        multi.add(person2);\n\n        jsonParam.put(\"multi\", multi.toJSONString());\n\n        // 答应出来瞅瞅\n        System.out.println(jsonParam.toString());\n\n        StringEntity entity = new StringEntity(jsonParam.toJSONString(), \"UTF-8\");\n        entity.setContentEncoding(\"UTF-8\");\n        entity.setContentType(\"application/json\");\n        httpPost.setEntity(entity);\n        HttpResponse resp = httpclient.execute(httpPost);\n        String respContent = null;\n        if (resp.getStatusLine().getStatusCode() == 200) {\n            HttpEntity he = resp.getEntity();\n            respContent = EntityUtils.toString(he, \"UTF-8\");\n        }\n        System.out.println(respContent);\n    }\n....\n\n____\n如果响应报错，请参照\nhttps://www.mysubmail.com/chs/documents/developer/c8ujr 文档拍错\n____\n\n== 在 spring-boot 中集成 submail\n\n对于在 spring boot 中，我们有几个要求 1. 把他作为一个组件来使用 2.\n批量发送时，需要异步不阻塞 2. 使用配置文件进行配置 APPID 等信息\n\n=== 添加配置文件读取类\n\n[source,java]\n----\n/**\n * @author Echo\n * @version 1.0\n * @date 2019-02-22 01:26\n */\n@Data\n@Component\n@ConfigurationProperties(prefix = \"application.message\")\npublic class MessageConfig {\n    /**\n     * appid\n     */\n    private String appId;\n    /**\n     * appkey\n     */\n    private String appKey;\n    /**\n     * 注册模板\n     */\n    private String registerTemplate;\n    /**\n     * 作业提醒模板\n     */\n    private String homeworkTipTemplate;\n}\n----\n\napplication.yml\n\n....\napplication:\n  message:\n    app-id: 1111\n    app-key: 111\n    register-template: 111\n    homework-tip-template:111\n....\n\n=== 创建组件\n\n添加一个 httpclient 的 bean\n\n....\n    @Bean\n    public HttpClient httpClient(){\n        return HttpClients.createDefault();\n    }\n....\n\n组件创建\n\n....\n/**\n * @author Echo\n * @version 1.0\n * @date 2019-02-22 01:17\n */\n@Component\n@Slf4j\npublic class SubMailUtils {\n\n    private final HttpClient httpClient;\n    private final MessageConfig messageConfig;\n    private static final String X_SEND = \"https://api.mysubmail.com/message/xsend\";\n\n    @Autowired\n    public SubMailUtils(HttpClient httpClient, MessageConfig messageConfig) {\n        this.httpClient = httpClient;\n        this.messageConfig = messageConfig;\n    }\n\n    /**\n     * 发送一条信息\n     *\n     * @param to   接收人\n     * @param vars 模板变量\n     */\n    public boolean sendOneMessage(String to, String project, JSONObject vars) {\n        HttpPost httpPost = new HttpPost(X_SEND);\n        JSONObject jsonParam = new JSONObject();\n        jsonParam.put(\"appid\", messageConfig.getAppId());\n        jsonParam.put(\"signature\", messageConfig.getAppKey());\n        jsonParam.put(\"project\", project);\n        jsonParam.put(\"to\", to);\n        jsonParam.put(\"vars\", vars);\n        StringEntity entity = new StringEntity(jsonParam.toJSONString(), \"UTF-8\");\n        entity.setContentEncoding(\"UTF-8\");\n        entity.setContentType(\"application/json\");\n        httpPost.setEntity(entity);\n        HttpResponse resp;\n        try {\n            resp = httpClient.execute(httpPost);\n            HttpEntity he = resp.getEntity();\n            log.info(EntityUtils.toString(he, \"UTF-8\"));\n            return resp.getStatusLine().getStatusCode() == 200;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n\n    }\n}\n....\n\n=== 使用组件\n\n我注册的时候需要发送一条短信，那么我应该在 controller 里面这样写\n\n....\n    @GetMapping(\"/mobile/{phone}\")\n    public HttpEntity<?> mobileCode(@PathVariable String phone) {\n        // 当前手机号是否已被注册\n        SysUser sysUser = new SysUser();\n        sysUser.setPhone(phone);\n        String result = sysUserService.existUser(sysUser);\n        if (result != null) {\n            throw new ResourceExistException(result);\n        }\n        // 生成 key 和 code\n        String key = MOBILE + phone;\n        String code = RandomStringUtils.randomNumeric(\n                applicationProperties.getValidate().getMobileCodeMinLength(),\n                applicationProperties.getValidate().getMobileCodeMaxLength());\n        // 存放\n        oauth2Service.saveValidateCode(key, code,\n                applicationProperties.getValidate().getMobileCodeValidityPeriod(),\n                TimeUnit.MINUTES);\n        // 创建模板变量\n        JSONObject vars = new JSONObject();\n        vars.put(\"code\", code);\n        vars.put(\"time\", applicationProperties.getValidate().getMobileCodeValidityPeriod());\n        // 发送短信\n        if (!subMailUtils.sendOneMessage(phone, messageConfig.getRegisterTemplate(), vars)) {\n            throw new RuntimeException(\"message send failed!\");\n        }\n        log.info(\"{} 短信验证码已经发送：{}\", phone, code);\n        return ResponseEntity.ok().build();\n    }\n....\n\n=== 测试\n\n请求验证码\n\nimage::https://resources.echocow.cn/file/2019/2/22/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190222015734.png[验证码]\n\nimage::https://resources.echocow.cn/file/2019/2/22/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190222005019.png[接受验证码]\n\nimage::https://resources.echocow.cn/file/2019/2/22/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_crx_fhbjgbiflinjbdggehcddcbncdddomop_20190222020030.png[验证]\n\n=== 发送多条短信\n\n发送多条短信封装类似，不过多加一个异步`@Async`注解，再配置下异步线程池即可，就不再详述了，太困了。。。。\n\n== 总结\n\n到这里就算结束了，难度不大，但是很好玩儿，其实难点在于如何手动生成\noauth2 的 jwt\n加密那里。。。其余地方都不是很难，后面写这个应用总结的时候再详述吧～短信接口感觉还是很贵的，学生党，玩玩儿就够啦哈哈。晚安啦\n\n","fields":{"slug":"/articles/2019/02/22/1550766482735.html","birthTime":"2019-02-21T18:05:09.829Z","modifiedTime":"2019-02-21","year":2019},"document":{"title":"submail 短信接口以及 spring boot 集成"}},{"content":"= Vaadin —— Java 从后端到前端 （路由与导航）\n:page-description: Vaadin —— Java 从后端到前端 （路由与导航）\n:page-category: 归档\n:page-image: https://img.hacpai.com/bing/20171124.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2019/02/25/1551107245928.html\n:page-created: 1551107999337\n:page-modified: 1551108133615\n:toc:\n\n前段时间无聊逛 maven 仓库的时候，无意中看到一个名为 spring boot\n的框架，但是却发布到了 12 的版本，我很奇怪，spring boot\n最近在用，没那么高啊，然后点进去才发现是 Vaadin 12 集成 spring boot\n的库。于是一时好奇去查看了一下 Vaadin，感觉还不错，Vaadin早期叫IT Mill\nToolkit，前端用一种专有的Javascript实现的，开发非常复杂。2007年底，这种专有的Javascript实现就被放弃了，转而拥抱GWT。2009年改名字叫Vaadin\nFramework。然而现在的 Vaadin 其实在也是有一席之地的，\n\n相比来说不用写 js 还是不错的，不过 css 还是要写的，可以理解是 GWT\n的一个超集吧。虽然说google工程已经使用 dart 和 angular dart 来取代GWT\n写的应用了，但我还是比较想试试使用 Vaadin\n如何，不过可惜的是文章实在少，只有从官网上看了，英语听力差的一批，不得已只能看文章慢慢学习啦。不过先体验一番，可以的话在考虑深入学习。\n\n== 定义路由\n\n@route 注释允许您将任意组件定义为给定 URL 片段的路由目标。例如：\n\n[source,java]\n----\n@Route(\"\")\npublic class HelloWorld extends Div {\n  public HelloWorld() {\n    setText(\"Hello world\");\n  }\n}\n----\n\n这里，我们将 Helloworld\n组件定义为应用程序的默认路由目标（空路由）。您可以为不同的路由定义单独的组件，如下所示：\n\n[source,java]\n----\n@Route(\"some/path\")\npublic class SomePathComponent extends Div {\n  public SomePathComponent() {\n    setText(\"Hello @Route!\");\n  }\n}\n----\n\n每当用户访问 http://yourdomain.com/some/path\n时（假设应用程序是从根上下文运行的）通过单击应用程序内的链接或直接在地址栏上键入地址，SomePathComponent\n组件将显示在页面上。\n\n____\n如果省略了 @Route 的值，则路由的路径默认将从类名派生。例如，MyEditor\n将变为 ``myeditor''，personView 将变为 ``person''，mainView 将变为“”。\n____\n\n____\nPS: 很简单的一个路由注解就完成路由设置，类似于 spring boot 的\n@RequestMapping\n____\n\n== 导航的生命周期\n\n在将导航从一种状态应用到另一种状态时，将触发许多生命周期事件。事件触发将会调用到\n`UI` 实例的侦听器和实现特殊观察者接口的附加组件\n\n=== BeforeLeaveEvent\n\n在导航期间激发的第一个事件是BeforeLeaveEvent。该事件允许延迟或取消导航，或者将导航更改为转到其他目的地。此事件将传递到实现\nBeforeLeaveObserver 并在导航开始前附加到 `UI`\n的任何组件实例。也可以使用UI中的\naddBeforeLeaveListener（beforeLeaveListener）方法为此事件注册独立的侦听器。\n\n此事件的一个典型用例是，在导航到应用程序的其他部分之前，询问用户是否要保存任何未保存的更改。\n\n==== Postpone 推迟导航\n\nBeforeLeaveEvent有一个 Postpone\n方法，可用于推迟当前导航转换，直到满足特定条件。\n\nE.g. 在离开页面前请求用户确认：\n\n[source,java]\n----\npublic class SignupForm extends Div implements BeforeLeaveObserver {\n    @Override\n    public void beforeLeave(BeforeLeaveEvent event) {\n        if (this.hasChanges()) {\n            ContinueNavigationAction action = event.postpone();\n            ConfirmDialog.build(\"Are you sure you want to leave this page?\")\n                    .ifAccept(action::proceed).show();\n        }\n    }\n\n    private boolean hasChanges() {\n        // no-op implementation\n        return true;\n    }\n}\n----\n\n使用 `postpone`\n方法将会暂时中断观察者和监听者，当他恢复以后，将会启用推迟的观察者之后的观察者。\n\n例如，我们假设当前页面有 `A` `B` `C` 三个观察者（即实现了 Observer\n结尾接口），按照这些顺序通知这些观察者，如果 `B` 调用推迟，对 `C`\n的调用以及转换过程的其余部分将被推迟。如果 `B` 推迟的转换没有恢复，`C`\n将不会收到有关此事件的通知，并且转换永远不会结束。但是，如果 `B` 执行其\n`ContinueNavigationAction` 以恢复转换，则从中断的位置继续。因此，`A` 和\n`B` 不再被调用，但 `C` 被通知。\n\n____\n任何时候最多可以推迟一个导航事件；当前一个导航事件处于推迟状态时启动新的导航转换将取消推迟状态。之后，执行之前保存的\n`ContinueNavigationAction` 将没有任何效果\n____\n\n____\nPS: 其实类似于 axios 的 路由前置守卫\n____\n\n=== BeforeEnterEvent\n\n在导航期间触发的第二个事件是\n`BeforeEnterEvent`。它允许将导航更改为转到其他目的地。此事件通常用于响应特殊情况，例如，如果没有要显示的数据或用户没有适当的权限。\n\n只有在通过 `BeforeLeaveEvent` 的任何 `postpone`\n都已继续之后，才会激发该事件。\n\n此事件将传递到任何实现 `BeforeEnterObserver`\n的组件实例，该实例将在导航完成后附加到\n`UI`。请注意，在分离并到达组件或使`UI`\n导航到的位置匹配之前，将激发该事件。也可以使用 `UI` 中的\n`addBeforeEnterListener（beforeEnterListener）`\n方法为此事件注册独立的侦听器。\n\n=== Reroute\n\n如果需要在某些状态下显示完全不同的信息，可以使用 BeforeEnterEvent 或\nBeforeLeaveEvent\n动态重新路由。重新路由后，不会再激发任何其他侦听器或观察器。相反，将根据新的导航目标触发新的导航阶段，而事件将根据该导航触发。\n\nE.g. 下面的例子发生在进入 `BlogList` 没有任何结果的时候\n\n[source,java]\n----\n@Route(\"no-items\")\npublic class NoItemsView extends Div {\n    public NoItemsView() {\n        setText(\"No items found.\");\n    }\n}\n\n@Route(\"blog\")\npublic class BlogList extends Div implements BeforeEnterObserver {\n    @Override\n    public void beforeEnter(BeforeEnterEvent event) {\n        // implementation omitted\n        Object record = getItem();\n\n        if (record == null) {\n            event.rerouteTo(NoItemsView.class);\n        }\n    }\n\n    private Object getItem() {\n        // no-op implementation\n        return null;\n    }\n}\n----\n\n____\n`rerouteto` 有几个重载来服务不同的用例。\n____\n\n=== AfterNavigationEvent\n\n导航过程中的第三个也是最后一个触发事件是\n`AfterNavigationEvent`。此事件通常用于在实际导航完成后更新 `UI`\n的各个部分。例如，调整 `breadcrumb`\n组件的内容，并在菜单中直观地将活动条目标记为 active。\n\n事件在 `beforeenterEvent` 和更新附加的 `UI`\n组件后激发。此时，可以预期当前的导航状态将实际显示给用户，也就是说，不会有任何进一步的重新路由或类似的情况。\n\n此事件将传递到完成导航后附加的实现 `AfterNavigationOnBServer`\n的任何组件实例。也可以使用 `UI` 中的\n`AddAfterNavigationListener（AfterNavigationListener）`\n方法为此事件注册独立的侦听器。\n\n[source,java]\n----\npublic class SideMenu extends Div implements AfterNavigationObserver {\n    Anchor blog = new Anchor(\"blog\", \"Blog\");\n\n    @Override\n    public void afterNavigation(AfterNavigationEvent event) {\n        boolean active = event.getLocation().getFirstSegment()\n                .equals(blog.getHref());\n        blog.getElement().getClassList().set(\"active\", active);\n    }\n}\n----\n\n____\nPS:其实就是路由后置守卫\n____\n\n== 路由器布局和嵌套路由器目标\n\n=== RouterLayout\n\n使用 `@route（“path”）` 定义路由时，默认情况下，组件将呈现在页面上的\n`<body>` 标记内（`hasElement.getElement()` 返回的元素附加到 `<body>`）。\n\n可以使用 `route.layout()` 方法定义父布局。例如，在名为 `Mainlayout`\n的布局中呈现 `CompanyComponent`，代码如下：\n\n[source,java]\n----\n@Tag(\"div\")\n@Route(value=\"company\", layout=MainLayout.class)\npublic class CompanyComponent extends Component {\n}\n----\n\n*所有用作父布局的布局都必须实现 `RouterLayout` 接口。*\n\n如果有多个路由器目标组件使用相同的父布局，那么当用户在子组件之间导航时，父布局实例将保持不变。\n\n____\nPS:类似于 HTML 的元素嵌套\n____\n\n=== 具有@parentlayout的多个父布局\n\n在某些情况下，可能需要在应用程序中为父布局提供父布局。一个例子是，我们有一个用于所有内容的主布局和一个可重用为视图的菜单栏。\n\n为此，我们可以进行以下设置：\n\n[source,java]\n----\npublic class MainLayout extends Div implements RouterLayout {\n}\n\n@ParentLayout(MainLayout.class)\npublic class MenuBar extends Div implements RouterLayout {\n    public MenuBar() {\n        addMenuElement(TutorialView.class, \"Tutorial\");\n        addMenuElement(IconsView.class, \"Icons\");\n    }\n    private void addMenuElement(Class<? extends Component> navigationTarget,\n            String name) {\n        // implementation omitted\n    }\n}\n\n@Route(value = \"tutorial\", layout = MenuBar.class)\npublic class TutorialView extends Div {\n}\n\n@Route(value=\"icons\", layout = MenuBar.class)\npublic class IconsView extends Div {\n}\n----\n\n在这种情况下，我们将拥有一个始终封装 `MenuBar` 的 `MainLayout`，而\n`MenuBar` 又封装 `TutorialView` 或\n`IconsView`，具体取决于我们导航到的位置。\n\n在这个示例中，我们有两个父层，但是嵌套布局的数量没有限制。\n\n=== 使用 `@routeprefix` 的 parentlayout 路由控制\n\n在某些情况下，父布局应该通过添加到路由位置来补充导航路由。\n\n这可以通过用 `@RoutePrefix(\"prefix_to_add\")` 注解父布局来完成。\n\n[source,java]\n----\n@Route(value = \"path\", layout = SomeParent.class)\npublic class PathComponent extends Div {\n    // Implementation omitted\n}\n\n@RoutePrefix(\"some\")\npublic class SomeParent extends Div implements RouterLayout {\n    // Implementation omitted\n}\n----\n\n在本例中，`PathComponent` 将接收的路由是 `some/path`，就像前面提到的\n`somePathComponent` 一样。\n\n=== 绝对路由\n\n有时，我们可能有一个设置，我们希望在许多部分中使用相同的父组件，但在某些情况下，不使用父链中的任何\n`@RoutePrefix`，或仅将它们用于定义的部分。\n\n在这些情况下，我们可以将 `absolute=true` 添加到 `@Route` 或\n`@RoutePrefix` 注释中。\n\n因此，如果我们想在 `SomeParent`\n布局的许多地方使用某些内容，但不想将路由前缀添加到导航路径中，我们可以用以下方式构建一个类\n`MyContent`：\n\n[source,java]\n----\n@Route(value = \"content\", layout = SomeParent.class, absolute = true)\npublic class MyContent extends Div {\n    // Implementation omitted\n}\n----\n\n在这种情况下，即使完整的链路径应该是\n`some/content`，我们实际上得到路径是 `content`\n正如我们所定义的，这应该是绝对的。\n\n当在链的中间有绝对定义时，也可以这样做，例如：\n\n[source,java]\n----\n@RoutePrefix(value = \"framework\", absolute = true)\n@ParentLayout(SomeParent.class)\npublic class FrameworkSite extends Div implements RouterLayout {\n    // Implementation omitted\n}\n\n@Route(value = \"tutorial\", layout = FrameworkSite.class)\npublic class Tutorials extends Div {\n    // Implementation omitted\n}\n----\n\n在这种情况下，绑定的路由将是 `framework/tutorial` 即使整个链接是\n`some/framework/tutorial`\n\n== 路由和 URL 参数\n\n=== 导航目标的 URL 参数\n\n支持通过URL传递参数的导航目标应实现 `HasUrlParameter`\n接口，并使用泛型定义参数类型。通过这种方式，路由器 API\n可以提供一种类型安全的方式来构造指向特定目标的 URL。\n\n`HasUrlParameter` 定义路由器根据从 URL 提取的值调用的 `setParameter`\n方法。该方法将始终在激活导航目标之前被调用。\n\n在下面的代码段中，我们定义了一个导航目标，它接受一个字符串参数并从中生成一个\nhello 字符串，然后目标将其设置为自己的导航文本内容。\n\n[source,java]\n----\n@Route(value = \"greet\")\npublic class GreetingComponent extends Div\n        implements HasUrlParameter<String> {\n\n    @Override\n    public void setParameter(BeforeEvent event, String parameter) {\n        setText(String.format(\"Hello, %s!\", parameter));\n    }\n}\n----\n\n启动时，此导航目标将自动配置为格式 `greet/<anything>`\n的每个路径，除非已将具有精确 `@Route` 的单独导航目标配置为匹配\n`greet/<some specific path>` ,因为在解析URL时，精确导航目标优先。\n\n=== 导航目标的可选 URL 参数\n\n可以使用 `@OptionalParameter` 对 URL 参数进行注释，使路由同时匹配\n`greet` 和 `greet/<anything>`。\n\n[source,java]\n----\n@Route(\"greet\")\npublic class OptionalGreeting extends Div\n        implements HasUrlParameter<String> {\n\n    @Override\n    public void setParameter(BeforeEvent event,\n            @OptionalParameter String parameter) {\n        if (parameter == null) {\n            setText(\"Welcome anonymous.\");\n        } else {\n            setText(String.format(\"Welcome %s.\", parameter));\n        }\n    }\n}\n----\n\n____\n另外，对于可选参数，特定路由将优先于参数化路由。\n____\n\n=== 导航目标的通配符 URL 参数\n\n在需要更多参数的情况下，还可以使用 `@WildcardParameter` 对 URL\n参数进行注释，以使路由匹配问候语以及之后的任何内容，例如问候语\n`/one/five/three`。\n\n[source,java]\n----\n@Route(\"greet\")\npublic class WildcardGreeting extends Div\n        implements HasUrlParameter<String> {\n\n    @Override\n    public void setParameter(BeforeEvent event,\n            @WildcardParameter String parameter) {\n        if (parameter.isEmpty()) {\n            setText(\"Welcome anonymous.\");\n        } else {\n            setText(String.format(\"Handling parameter %s.\", parameter));\n        }\n    }\n}\n----\n\n____\n通配符参数的参数永远不会为空。\n____\n\n____\n更具体的路径将优先于通配符目标。\n____\n\n=== 查询参数\n\n也可以获取包含在 URL 中的查询参数。e.g. `?name1=value1&name2=value2`.\n\n可以通过 `Location` 类的 `getQueryParameters()`\n方法访问这些查询参数。位置类可以通过 `setParameter` 方法的 `BeforeEvent`\n参数获得。\n\n____\n`Location` 对象表示由路径段和查询参数组成的相对\nURL，但不用主机名，e.g. `new Location(\"foo/bar/baz?name1=value1\")`.\n____\n\n....\n@Override\npublic void setParameter(BeforeEvent event,\n        @OptionalParameter String parameter) {\n\n    Location location = event.getLocation();\n    QueryParameters queryParameters = location.getQueryParameters();\n\n    Map<String, List<String>> parametersMap = queryParameters.getParameters();\n}\n....\n\n____\n`getQueryParameters()` 支持与同一个键关联的多个值。 Example:\n`https://example.com/?one=1&two=2&one=3` 3将生成对应的映射\n`{\"one\" : [1, 3], \"two\": [2]}}`.\n____\n\n== URL 生成\n\n路由器公开了获取已注册导航目标的导航 URL 的方法。\n\n对于一个普通的导航目标，请求是一个简单的调用\n`Router.getUrl(Class target)`。\n\n[source,java]\n----\n@Route(\"path\")\npublic class PathComponent extends Div {\n  public PathComponent() {\n    setText(\"Hello @Route!\");\n  }\n}\n\npublic class Menu extends Div {\n    public Menu() {\n        String route = UI.getCurrent().getRouter()\n                .getUrl(PathComponent.class);\n        Anchor link = new Anchor(route, \"Path\");\n        add(link);\n    }\n}\n----\n\n在这种情况下，返回的 URL 将简单地解析为\n*路径*，但在我们在父布局有添加部分路径情况下，手工生成路径可能不那么简单。\n\n=== 带参数导航目标的 URL 生成\n\n对于具有所需参数的导航目标，参数被赋予解析器，返回的字符串将包含参数，e.g. `Router.getUrl(Class target, T parameter)`\n\n[source,java]\n----\n@Route(value = \"greet\")\npublic class GreetingComponent extends Div\n        implements HasUrlParameter<String> {\n\n    @Override\n    public void setParameter(BeforeEvent event,\n            String parameter) {\n        setText(String.format(\"Hello, %s!\", parameter));\n    }\n}\n\npublic class ParameterMenu extends Div {\n    public ParameterMenu() {\n        String route = UI.getCurrent().getRouter()\n                .getUrl(GreetingComponent.class, \"anonymous\");\n        Anchor link = new Anchor(route, \"Greeting\");\n        add(link);\n    }\n}\n----\n\n== 在路线之间导航\n\n您可以使用 `RouterLink` 组件创建链接，以引导到应用程序中的路由目标。\n\n带或不带 url 参数的导航目标的 `RouterLink` 示例\n\n....\nvoid routerLink() {\n    Div menu = new Div();\n    menu.add(new RouterLink(\"Home\", HomeView.class));\n    menu.add(new RouterLink(\"Greeting\", GreetingComponent.class, \"default\"));\n}\n....\n\n带URL参数的 `GreetingComponent` 组件\n\n[source,java]\n----\n@Route(value = \"greet\")\npublic class GreetingComponent extends Div\n        implements HasUrlParameter<String> {\n\n    @Override\n    public void setParameter(BeforeEvent event,\n            String parameter) {\n        setText(String.format(\"Hello, %s!\", parameter));\n    }\n}\n----\n\n也可以使用普通的类型链接进行导航，但这些链接会导致页面重新加载。相反，使用\n`RouterLink`\n导航会获取新组件的内容，该组件在不重新加载页面的情况下就地更新。\n\n____\n通过向常规链接添加 `router-link`\n属性，您可以告诉框架它应在不重新加载的情况下处理导航，e.g. `<a router-link href=\"company\">Go to the company page</a>`。\n____\n\n要从服务器端触发导航，请使用 `UI.navigate(String)`，其中 String\n参数是要导航到的位置。还有，`UI.navigate(Class<? extends Component> navigationTarget)`\n或\n`navigate(Class<? extends C> navigationTarget, T parameter)`，这样就不必手动生成路由字符串。这将触发浏览器位置的更新并添加新的历史记录状态条目。单击按钮时指向\n`company` 路线目标的示例导航：\n\n....\nNativeButton button = new NativeButton(\"Navigate to company\");\nbutton.addClickListener( e-> {\n     button.getUI().ifPresent(ui -> ui.navigate(\"company\"));\n});\n....\n\n____\n即使会话 session\n已过期，路由器链接也可以工作，因此您应该更喜欢使用这些链接，而不是处理导航服务器端。\n____\n\n== 路由器异常处理\n\nvaadin\n对于导航目标有特殊的支持，因为在**导航过程**中引发了未处理的异常而激活这些目标，以便向用户显示``错误视图''。\n\n这些目标通常与常规导航目标的工作方式相同，尽管它们通常没有任何特定的\n`@Route`，因为它们是为任意 URL 显示的。\n\n错误导航根据导航期间引发的异常类型解析为 target。\n\n在启动时，将收集实现接口 `HasErrorParameter<T extends Exception>`\n的所有类，以便在导航期间用作异常 targets。\n\n例如，这里是 `NotFoundException` 的默认目标，当给定的 URL\n没有目标时，将显示该目标。\n\nRouteNotFoundError for NotFoundException during routing\n\n[source,java]\n----\n@Tag(Tag.DIV)\npublic class RouteNotFoundError extends Component\n        implements HasErrorParameter<NotFoundException> {\n\n    @Override\n    public int setErrorParameter(BeforeEnterEvent event,\n            ErrorParameter<NotFoundException> parameter) {\n        getElement().setText(\"Could not navigate to '\"\n                    + event.getLocation().getPath() + \"'\");\n        return HttpServletResponse.SC_NOT_FOUND;\n    }\n}\n----\n\n这将返回 404 的 HTTP 响应并向用户显示设置的文本。\n\n异常匹配将首先按异常原因运行，然后按异常超类型运行。\n\n实现的默认异常为 `NotFoundException（404）` 的 `RouteNotFoundError`\n，`Java.lang.Exception（500）` 的 `InternalServerError` 。\n\n默认的异常处理程序可以通过如下方式进行扩展来重写：\n\nCustom route not found that is using our application layout\n\n[source,java]\n----\n@ParentLayout(MainLayout.class)\npublic class CustomNotFoundTarget extends RouteNotFoundError {\n\n    @Override\n    public int setErrorParameter(BeforeEnterEvent event,\n            ErrorParameter<NotFoundException> parameter) {\n        getElement().setText(\"My custom not found class!\");\n        return HttpServletResponse.SC_NOT_FOUND;\n    }\n}\n----\n\n作为一个更复杂的示例，我们可以有一个仪表板，它可以收集和向用户显示小部件，并且可以有不应为未经身份验证的用户显示的小部件。出于某种原因，为未经身份验证的用户加载\n`ProtectedWidget`。\n\n集合本应捕获受保护的小部件，但出于某种原因实例化了它，但幸运的是，该小部件检查创建时的身份验证，并抛出\n`AccessDeniedException`\n\n此未处理的异常在导航过程中传播，并由 `AccessDeniedExceptionHandler`\n处理，该处理程序仍保留主布局的菜单栏，但显示发生异常的信息。\n\n错误加载受保护的小部件时访问被拒绝的异常示例\n\n[source,java]\n----\n@Route(value = \"dashboard\", layout = MainLayout.class)\n@Tag(Tag.DIV)\npublic class Dashboard extends Component {\n    public Dashboard() {\n        init();\n    }\n\n    private void init() {\n        getWidgets().forEach(this::addWidget);\n    }\n\n    public void addWidget(Widget widget) {\n        // Implementation omitted\n    }\n\n    private Stream<Widget> getWidgets() {\n        // Implementation omitted, gets faulty state widget\n        return Stream.of(new ProtectedWidget());\n    }\n}\n\npublic class ProtectedWidget extends Widget {\n    public ProtectedWidget() {\n        if (!AccessHandler.getInstance().isAuthenticated()) {\n            throw new AccessDeniedException(\"Unauthorized widget access\");\n        }\n        // Implementation omitted\n    }\n}\n\n@Tag(Tag.DIV)\npublic abstract class Widget extends Component {\n    public boolean isProtected() {\n        // Implementation omitted\n        return true;\n    }\n}\n\n@Tag(Tag.DIV)\n@ParentLayout(MainLayout.class)\npublic class AccessDeniedExceptionHandler extends Component\n        implements HasErrorParameter<AccessDeniedException> {\n\n    @Override\n    public int setErrorParameter(BeforeEnterEvent event,\n            ErrorParameter<AccessDeniedException> parameter) {\n        getElement().setText(\n            \"Tried to navigate to a view without correct access rights\");\n        return HttpServletResponse.SC_FORBIDDEN;\n    }\n}\n----\n\n异常目标可以定义 `ParentLayouts`，并且在进行导航之前和之后发送的\n`NavigationEvent` 将与正常导航相同。\n\n一个异常只能有一个异常处理程序（只允许扩展实例）。\n\n=== 重新路由到错误视图\n\n可以从 `BeforeEnterEvent` 和 `BeforeLeaveEvent`\n重新路由到为异常注册的错误视图。\n\n重新路由是通过使用其中一个重载来完成的，该重载用于只将异常类重新路由到目标或添加自定义错误消息。\n\n重新路由到错误视图\n\n[source,java]\n----\npublic class AuthenticationHandler implements BeforeEnterObserver {\n    @Override\n    public void beforeEnter(BeforeEnterEvent event) {\n        Class<?> target = event.getNavigationTarget();\n        if (!currentUserMayEnter(target)) {\n            event.rerouteToError(AccessDeniedException.class);\n        }\n    }\n\n    private boolean currentUserMayEnter(Class<?> target) {\n        // implementation omitted\n        return false;\n    }\n}\n----\n\n如果重新路由方法捕获到异常，并且需要添加自定义消息，则可以使用\n`rerouteToError(Exception, String)` 方法设置自定义消息。\n\n包含自定义消息的日志示例错误视图\n\n[source,java]\n----\n@Tag(Tag.DIV)\npublic class BlogPost extends Component implements HasUrlParameter<Long> {\n\n    @Override\n    public void setParameter(BeforeEvent event, Long parameter) {\n        removeAll();\n\n        Optional<BlogRecord> record = getRecord(parameter);\n\n        if (!record.isPresent()) {\n            event.rerouteToError(IllegalArgumentException.class,\n                    getTranslation(\"blog.post.not.found\",\n                            event.getLocation().getPath()));\n        } else {\n            displayRecord(record.get());\n        }\n    }\n\n    private void removeAll() {\n        // NO-OP\n    }\n\n    private void displayRecord(BlogRecord record) {\n        // NO-OP\n    }\n\n    public Optional<BlogRecord> getRecord(Long id) {\n        // Implementation omitted\n        return Optional.empty();\n    }\n}\n\n@Tag(Tag.DIV)\npublic class FaultyBlogPostHandler extends Component\n        implements HasErrorParameter<IllegalArgumentException> {\n\n    @Override\n    public int setErrorParameter(BeforeEnterEvent event,\n            ErrorParameter<IllegalArgumentException> parameter) {\n        Label message = new Label(parameter.getCustomMessage());\n        getElement().appendChild(message.getElement());\n\n        return HttpServletResponse.SC_NOT_FOUND;\n    }\n}\n----\n\n== 获取已注册的路由\n\n要检索应用程序中所有已注册的路由，可以使用：\n\n....\nRouter router = UI.getCurrent().getRouter();\nList<RouteData> routes = router.getRoutes();\n....\n\n`RouteData` 对象包含有关已定义路由的所有相关信息，如 URL、参数和父布局。\n\n=== 按父布局获取已注册路由\n\n要获取由父布局定义的所有路由，可以使用：\n\n....\nRouter router = UI.getCurrent().getRouter();\nMap<Class<? extends RouterLayout>, List<RouteData>> routesByParent = router.getRoutesByParent();\nList<RouteData> myRoutes = routesByParent.get(MyParentLayout.class);\n....\n\n== 更新导航页面标题\n\n导航期间有两种更新页面标题的方法：\n\n* 使用 `@PageTitle` 注解\n* 实现 `HasDynamicTitle`\n\n这两种方法是互斥的：在同一个类上同时使用这两种方法将在启动时导致运行时异常。\n\n=== 使用 `@PageTitle` 注解\n\n更新页面标题的最简单方法是在组件类上使用 `@PageTitle` 注释。\n\n[source,java]\n----\n@PageTitle(\"home\")\nclass HomeView extends Div {\n\n  HomeView(){\n    setText(\"This is the home view\");\n  }\n}\n----\n\n____\n`@PageTitle` 注释仅从实际导航目标读取；不考虑其超类或其父视图。\n____\n\n=== 动态设置页面标题\n\n实现 `HasDynamicTitle` 接口使我们可以在运行时从 Java 更改标题：\n\n[source,java]\n----\n@Route(value = \"blog\")\nclass BlogPost extends Component\n        implements HasDynamicTitle, HasUrlParameter<Long> {\n  private String title = \"\";\n\n  @Override\n  public String getPageTitle() {\n    return title;\n  }\n\n  @Override\n  public void setParameter(BeforeEvent event,\n        @OptionalParameter Long parameter) {\n    if (parameter != null) {\n      title = \"Blog Post #\" + parameter;\n    } else {\n      title = \"Blog Home\";\n    }\n  }\n}\n----\n\n== 结束语\n\n路由这一块还不错，相比于 vertx\n至少他的注解是很友好的（其实两者不是一性质哈哈），不过 html\n组件构建方面有点麻烦，慢慢学习适应下咯只有，不过重点是\n资料少！资料少！资料少！ 啊！不过我喜欢（逃。。。\n\n","fields":{"slug":"/articles/2019/02/25/1551107245928.html","birthTime":"2019-02-25T15:19:59.337Z","modifiedTime":"2019-02-25","year":2019},"document":{"title":"Vaadin —— Java 从后端到前端 （路由与导航）"}},{"content":"= 我校资源仓库 使用详解\n:page-description: 我校资源仓库 使用详解\n:page-category: 归档\n:page-image: https://img.hacpai.com/bing/20180517.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2019/03/01/1551410272344.html\n:page-created: 1551413018404\n:page-modified: 1553735570120\n:toc:\n\n最近在上 分布式应用系统 的课程，在使用 maven、npm、pip\n等这些依赖管理工具的时候，出现了一个很严重的问题，就是我们校园网由于 dns\n的问题，造成了下载依赖的时候总是下不全，dns\n总是要解析第二遍才能成功，为此，我特地利用学校已有的资源服务器，搭建了我们学校的私服仓库，此篇文章就是如何使用的。\n\n____\n*注意：校内私服只有在新校区连接校园网以后才能使用。只连接 wifi\n，不用登录校园网也可以使用。*\n____\n\n'''''\n\n== 私服介绍\n\n通过 nexus3 搭建校内私服，可以在通过 `http://10.100.0.11:5741`\n进行查看和搜索当前私服已经下载的包和仓库，已经开启匿名访问免登陆，如果发现有下载不全的情况，请联系`lzy@echocow.cn`\n，有奖励哦～！现在私服仓库如下：\n\n* ☒ Maven -> 建议配置永久的\n* ☒ Npm -> 建议配置临时的\n* ☒ Pip -> 建议配置临时的\n* ☐ Yum\n* ☐ Epel\n* ☐ Docker\n\n____\n还可以搭建很多，但是都不在计划之内\n____\n\n== 优点\n\n[arabic]\n. 内网传输，可靠性高，速度快\n. 内网无需 DNS\n解析，完美解决学校校园网问题（如果使用阿里云或者其他私服，依旧可能出现\nDNS 解析或者网络缓慢的问题）\n. 可以直接搜索和查看 Maven 私服的库\n\n== Maven\n\n=== 在这之前\n\n在这之前，你需已经成功安装并配置 maven 环境变量，请通过 `mvn -v`\n检测。并且要拥有 maven 的基础知识，你需要选择性的明白以下内容：\n\n* 如果你希望全局使用私服，你需要了解 maven 全局配置文件 `setting.xml`\n* 如果你希望当前项目使用私服，你需要了解当前项目的 maven 配置文件\n`pom.xml`\n* 如果你希望 gradle 项目使用私服，你需要了解当前项目的 gradle 配置文件\n`build.gradle`\n\n____\nmaven 私服地址：http://10.100.0.11:5741/repository/maven-public/\n____\n\n*如果你曾经有过未下载完全的依赖，请先删除原来的本地仓库： - windows\n默认目录 `C:/Users/用户名/.m2` 的隐藏文件夹，请直接删除， - linux\n默认目录 `/home/用户名/.m2` ，请直接删除 - 如果你自己在 `setting.xml`\n配置了本地仓库地址，即使用了 `localRepository`\n标签，请找到你指定的文件夹进行删除。*\n\n=== 全局使用私服\n\n你需要找到你当前 maven 的`setting.xml` 配置文件，找到 `<mirrors>`\n标签，添加如下内容即可：\n\n[source,xml]\n----\n    <mirror>\n      <id>com.gzmu</id>\n      <mirrorOf>*</mirrorOf>\n      <name>gzmu-maven</name>\n      <url>http://10.100.0.11:5741/repository/maven-public/</url>\n    </mirror>\n----\n\n*请注意，如果你使用 `IDEA` 进行项目构建，必须使用以下方式进行构建。在\n`windows/linux` 下你需要进入\n`File -> Setting -> Build... ->  Build Tools  -> maven`\n中，有以下几种方式 1. 修改 maven 为你 本地的而不是使用内置的，同时修改\n`User Setting File` 为你本地的。 2. 使用内置的 maven 修改\n`User Setting File` 为你本地的。 3. 都不修改，找到\n`User Setting File`中的文件（没有就自己加一个或者复制过来）然后添加上面的\n配置*。\n\n=== 当前 maven 项目使用私服\n\n如果你使用 maven 进行项目构建，你的 maven 项目根目录下存在一个 `pom.xml`\n依赖管理配置文件，你需要 `project` 标签下添加子标签如下\n\n....\n    <repositories>\n        <repository>\n            <id>com.gzmu</id>\n            <name>gzmu-maven</name>\n            <url>http://10.100.0.11:5741/repository/maven-public/</url>\n        </repository>\n    </repositories>\n....\n\n=== 当前 gradle 项目使用私服\n\n如果你使用 gradle 进行项目构建，你的 gradle 项目根目录下存在一个\n`build.gradle` 项目构建文件，你需要添加 `repositories`\n闭包，设置仓库地址如下：\n\n....\n    repositories {\n        mavenLocal()\n        maven { url \"http://10.100.0.11:5741/repository/maven-public/\"}\n        // .... 其它maven中心，以备万一\n        mavenCentral()\n    }\n....\n\n=== 验证\n\n[arabic]\n. 使用任何一个 ide，在 maven\n项目添加一个依赖，观察右下角依赖下载地址是否为私服地址。\n. 使用命令行，切换到一个 maven 项目根目录，添加一个依赖，使用\n`mvn install` 进行部署，会自动下载依赖，观察下载地址是否为私服地址。\n\n== Npm\n\n=== 在这之前\n\n在这之前，你需已经成功安装并配置 npm 环境变量(Windows\n安装版会自动配置)，请通过 `npm -v` 检验，并且你需要具有基础的 npm\n知识，你需要选择性的明白以下内容： - 如果你希望全局使用私服，你需要了解\nnpm 全局配置文件 `.npmrc`或者 `命令配置` -\n如果你希望临时使用私服，你需要了解 npm 命令\n\n____\n单个项目中也可以指定使用私服，修改 `package.json` 配置文件，修改\n`install` 命令，但是非常不友好，故而不做阐述。\n____\n\n=== 全局使用私服\n\n==== 修改配置文件\n\n你需要找到你的 npm 配置文件目录，默认情况下，他存在于 当前用户的家目录\n下（如果没有可以自行创建或者通过下一种方式安装），例如\n\n* windows：`C:\\Users(用户)\\用户名\\.npmrc`\n* linux/mac：`/home/用户名/.npmrc`\n\n添加如下配置即可\n\n....\nregistry=http://10.100.0.11:5741/repository/npm-publilc/\n....\n\n==== 命令配置\n\n运行如下命令即可\n\n....\n// 配置仓库\nnpm config set registry http://10.100.0.11:5741/repository/npm-publilc/\n\n// 查看配置\nnpm config list\n....\n\n他会自动在家目录里面添加上面提到的配置文件\n\n=== 临时使用私服\n\n只需要一个命令即可\n\n....\nnpm --registry http://10.100.0.11:5741/repository/npm-publilc install express\n....\n\n____\n*请注意，此方法的私服的配置是临时的，将会只对当前命令行有效，一旦关闭，下次使用活打开新的命令行还需要重新修改。*\n____\n\n=== 验证\n\n[arabic]\n. 使用任何一个 ide，在 npm\n项目添加一个依赖，观察右下角依赖下载地址是否为私服地址。\n. 使用命令行，安装整个项目依赖，切换到一个 npm\n项目根目录，添加一个依赖，使用 `npm -loglevel info install`\n进行依赖下载，观察下载地址是否为私服地址。\n. 使用命令行，安装单个全局依赖，例如\n`npm -loglevel info i -g @vue/cli`，观察下载地址是否为私服地址。\n\n== Pip\n\n=== 在这之前\n\n在这之前，你需已经成功安装并配置 pip 环境变量(windows\n安装版需要注意勾选加入环境变量选项)，请通过 `pip --version`\n检测。并且要拥有 pip 的基础知识，你需要选择性的明白以下内容：\n\n* 如果你希望全局使用私服，`命令配置` 你的 pip 需要在 10 以上。\n* 如果你希望安装单个库时使用，你需要在每次安装的时候添加参数。\n\n____\n*注意，此处我不使用配置文件进行配置，通过配置文件也可以修改，但是因为他的配置不像\nnpm 一样固定，有些系统是不一样的，所以有需要请自行去查找资料。*\n____\n\n=== 全局使用私服\n\n....\n// 配置仓库\npip config set global.index-url http://10.100.0.11:5741/repository/pypi-public/simple\n\n// 添加信任\npip config set install.trusted-host 10.100.0.11\n....\n\n他会输出自动写入的配置文件的位置。\n\n=== 安装单个库\n\n....\npip install --trusted-host 10.100.0.11 -i http://10.100.0.11:5741/repository/pypi-public/simple 库名\n....\n\n例如\n\n....\npip install --trusted-host 10.100.0.11 -i http://10.100.0.11:5741/repository/pypi-public/simple flask\n....\n\n== Yum\n\n待完成……\n\n== Epel\n\n待完成……\n\n== Docker\n\n待完成……\n\n== 总结\n\n使用以上方式，安装依赖速度快很多，因为服务器 DNS\n是没有问题的，并且外网速度也比校园网给力的。如果遇到问题请及时和我联系！\n\n== 其它\n\n=== Jrebel 激活\n\n除了私服的搭建，我也搭建了 Jrebel\n的激活服务，如果有需要的请自取。http://58.16.40.236:8889/[网页链接]\n\n","fields":{"slug":"/articles/2019/03/01/1551410272344.html","birthTime":"2019-03-01T04:03:38.404Z","modifiedTime":"2019-03-28","year":2019},"document":{"title":"我校资源仓库 使用详解"}},{"content":"= [阅读] 敏捷软件开发 —— 敏捷开发（一）\n:page-description: [阅读] 敏捷软件开发 —— 敏捷开发（一）\n:page-category: 阅读\n:page-image: https://img.hacpai.com/bing/20180612.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2019/03/01/1551401439594.html\n:page-created: 1551520473257\n:page-modified: 1551520473257\n:toc:\n\n很久没有好好的静下来看一本经典的书籍了，一些经典的书籍即使已经有些年头了，但是却依旧能够带给后人不少启示，寒假的时候选择的是\n《spring 实战》，开学了，在刘欣老师的推荐下，选择了《敏捷软件开发\n、原则、模式与实践》，也决定要写下的自己的观后感。其实反观这大学的几年，自己底子过于虚浮，不重视基础，总是过于追求于新的流行技术，然后对底层却一无所知，自己需要更多的书籍来为自己以后的道路奠下基础。\n\n== 开篇\n\n____\n对用户来说，通过直观、简单的界面呈现出恰当特性的程序就是美的。对软件设计者来说，被简单、直观地分割，并且有最小内部耦合的内部结构就是美的。对开发人员来说和管理者来说，每周都会取得重大进展，并且生产出无缺陷的具有活力的团队就是美的。\n——中文版序：软件之美\n____\n\n从开篇本书就很明确的说明了一点\n\n____\n我要告诉你，使本书的内容跟得上最新的技术知识是很困难的。\n____\n\n在挨踢行业，技术的更替是非常快的，至今为止摩尔定律依旧适用。在如此快的情况下，需要一本书不断的对技术进行跟进和更新很明显是十分困难的，本书更加注重的是思想方面的学习以及软件开发的原则、模式等，并不是对一项最新的技术进行学习与使用，这与一些实用性的工具书有非常不同的性质的。\n\n== 开始之前\n\n在读这本书之前，我有过一次为学校开发项目的经历，也是体验不太好的一次经历，我就以此次经历为背景来阅读此书。\n\n2018 年 7\n月，我们学校接到一个项目，在我们老师的带领下我们参与了这个项目。我作为学生这边的负责人之一，由我对项目做了技术上的选型，然后自己尝试，搭建了以后书写了文档，给予了我们组内成员，他们根据我的文档进行环境上的搭建。由于时间紧迫，我们自己以及老师并没有书写任何关于需求的分析文档，仅有的不过一张流程图而已，并且由于在学校的客观原因，我们之间的交流基本使用\nQQ\n语言进行交流，项目从七月中旬正式开始，每两三天语音一次，然而是和老师进行语音以了解需求，到八月中旬结束，后面又继续了长达半年的修修补补与维护，整个过程变得十分缓慢以及冗长，到了今年二月，才正式结束。\n\n以此为背景，来写对于敏捷软件开发的读后感。\n\n== 第一章 敏捷开发\n\n____\n人与人之间的交互是复杂的，并且其效果从来都是难以预测的，但却是工作中最为重要的方面。\n____\n\n这一章从一开始就**强调了人是影响软件开发过程的最大的一项重要因素**。一个项目的成功，是需要一个具有**合作精神、自组织**的团队。\n\n在没有任何项目经验之前，去完成一个新的项目，并且没有太多人进行带头的情况下，想要制作出一个优秀的软件作品是十分困难的，当完成后，就不会再想去看自己写出来的如此劣质的产品，正如书中所说，*一旦经历了这样的惨败，就会害怕重蹈覆辙*。在我们学校项目构建过程中，老师由于工作原因十分有限，只能给予我们数据库的设计的一些帮助，然后我们自己去开发、研究以及设计，最后回头看，整个代码犹如一坨翔一般，这也是造成我们后期维护的过程十分痛苦的原因之一，最可怕的是他不仅降低了我们团队的开发效率，还完全压灭了我们团队的开发的积极性。这个结果让我们十分不满意，但是也不得不接受，以至于我们在后面其它项目的设计中十分小心翼翼和提醒吊胆。\n\n=== 敏捷软件开发宣言\n\n____\n个体和交互 胜过 过程和工具\n\n可以工作的软件 胜过 面面俱到的文档\n\n客户合作 胜过 合同谈判\n\n响应变化 胜过 遵循计划\n____\n\n=== 敏捷软件开发原则\n\n* 尽早的、持续的交付有价值的软件\n* 欢迎改变需求，敏捷过程利用变化来为客户创造竞争优势\n* 经常性地交付可以工作的软件\n* 开发期间，业务人员和开发人员必须天天都在一起工作\n* 围绕被激励起来的个人来构建项目，给他们提供所需要的环境和支持，并且信任他们能够完成工作\n* 面对面交谈\n* 工作的软件是首要的进度度量标准\n* 可持续的开发速度、责任人、开发者和活用应该能够保持一个长期的、恒定的开发速度\n* 不断关注优秀的集合和好的设计增强敏捷能力\n* 简单——使未完成的工作最大化的艺术——是根本的\n* 最好的架构、需求和设计出自于自组织的团队\n* 每隔一定时间，团队会在如何才能更有效地工作方面进行反省，然后相应地对自己的行为进行调整。\n\n=== 回看\n\n以我前面开始之前的背景为例子，进行一一验证，可以发现自己上一次失败的经历完全背离了敏捷开发的宣言和原则，我对自己曾经的项目进行反思\n\n[arabic]\n. 企图使用任何最新的工具，能够带给我们最好的开发效率。后来发现，最新的不一定是最好的，自己最大的要求就是必须使用\nIDEA 2018.02\n进行开发，但是对于我们项目而言，此要求纯粹是强迫症作祟，后来也证明，2016\n也是一样可以完整开发的。没错，2018 的确在某些方面也带给了我相应的烦恼。\n. 企图用一个完整的文档去进行软件的交接，我把文档看得十分重要，见我博客的分类https://echocow.cn/category/%E5%AD%A6%E6%A0%A1[学校]，还有很多没有发出来，为了写文档，花费了不少时间，有时候一个下午就在完善一个文档。因而造成的结果就是，大家都在等我的文档出来后，再进行部署和搭建，并且其中有问题只能通过\nQQ\n进行交流，到时进度的拖延，这是一个严重的问题。后来我意识到了问题所在，但是却还是放不下写文档。应该明白的是\n*直到迫切需要并且重大意义时，才来编制文档*。\n. 企图通过老师就了解整个需求。可以说让我们这个项目``失败''的最大原因就是因为客户合作。我们从头到尾，真正见过客户只有一次，其他的所有东西都是由老师进行转达，老师进行测试。后面许多地方完全和客户想的不一样，造成了做许多重复功以及非常垃圾的设计。\n. 企图期望客户不去修改需求。按照我们的计划，能够把 流程图\n上面的流程做完即可，但是却忘记，客户的需求是在不断交付中进行修改的，因为每次检验与交付时间过长，客户的计划改变，造成我们这边手忙脚乱，完全没有办法保持一个良好的进度，而是不断的去修改以前乃至很久以前的代码。\n. 团队过于松散。我们的团队是由几个学生组织而来，虽然我是负责人，但是同是学生的身份，没有谁可以命令谁这一说，大家刚开始，并不太能配合，自己也没有作为一个管理者天赋。\n. 企图一个人一个功能模块。一开始我只负责架构与部署，然后后面的开发过程我来写好了文档让他们看和学习，然后分配功能一个一个的完成，以至于到了后来，作为一个开发人员，都不能完整的过一遍程序，因为有一大部分不是由我开发，后面的流程是什么我都不清楚。应该做的是，要在项目中的所有方面都参与，一个地方出问题，大家可以一起解决，而不是说一句，这里不是我写的我不知道，你自己看看这种话。\n. 不会反省。作为几个还在大学的 90\n后，实在是抱怨大于反省，用我们学姐的话说，就说过于愤青，常常有问题不是想着如何解决，而是抱怨。\n\n回看下来，项目的失败不是没有原因的，只是当局者迷。反思之后也会有很多需要改进的地方的。一个敏捷开发的团队，在我看来应该有如下一些特点\n\n[arabic]\n. 几个友好交流的团队成员组成的自组织团队\n. 持续性的、短期的交付有价值的软件\n. 敏捷软件开发，欢迎改变需求\n. 不断关注优秀的技能和设计\n. 采取与目标一直的最简单的方法\n. 面对面的交流\n. 必须能够一起工作\n. 时常反省，积极改变 9.文档必要，但不是全部\n. 为下两周做详尽计划，为下三个月做粗略计划\n. 自组织团队\n\n== 第二章 敏捷软件开发、原则、模式与实践\n\n____\n作为开发人员，我们应该记住，XP 并非唯一选择。\n____\n\n敏捷方法很多，极限编程（cXtreme Programing，简称\nXP）是最著名的一个，他是由许多相互依赖的实践组成。\n\n* 客户作为团队成员：\n无论谁是客户，他们都是能够和团队一起工作的团队成员。\n* 用户素材：他是一个计划工具，客户可以使用它并根据他的优先级和估算代价来安排实现该需求的时间。\n* *短交付周期：每两周交付一个可以工作的软件。*\n* 验收测试：由能够自动并且反复运行的某种脚本语言编写，这些测试共同验证胸痛按照客户指定的行为运转。\n* *结对编程：所有的产品代码都是由结对的程序员使用同一台电脑共同完成。*\n* *测试驱动开发：所有的代码都是先编写测试用例再去书写业务。*\n* 集体所有权：结对编程中的每一对都具有拆出任何模块并对他进行改进的权力。\n* 持续集成：XP 团队会进行多次系统构建，重新创建整个系统。\n* 可持续的开发速度：团队必须保持旺盛的精力和敏锐的警觉。不允许团队加班工作，在版本发布前的一个星期是例外。\n* 开放的工作空间：团队在一个开放的房间中一起工作。\n* 计划游戏：划分业务人员和开发人员之间的职责，业务人员（客户）决定特性的重要性，开发人员决定实现一个特性所花费的代价。\n* 简单的设计：设计尽可能的简单、具有表现力。XP 指导原则\n** 考虑能够工作的最简单的事情：尽可能寻找能够实现用户素材的最简单的设计。\n** 你将不需要他：只有在有证据，或则至少由十分明显的迹象表明现在引入这些基础结构比继续等待更加合算时，才会引入这些基础机构。\n** *一次，并且只有一次：不能容忍重复的代码。*\n* *重构：经常性的代码重构并保证测试用例能够通过。*\n* 隐喻：XP\n所有实践中中最重要的实践之一，他是将整个系统联系再一次的全局视图。\n\n以上来自于书中或者自己的总结，加粗的是我自己体验过的，他们的确为我带来了不小的助力。其实\nXP\n的中的单个实践都不足以为道，但是一旦他们结合起来形成一个系统或整体，就带来了意想不到的效果。其中我最赞同的莫过于\n*隐喻*\n，为什么？因为如果能够为当前的系统建造一个隐喻出来，那么你开发的时候就能够很快的知道自己是否达到了目标，能够尽可能早的发现错误；而且他的有趣与幽默，不仅能够减少错误，还为工作带来一点新的乐趣。不太好理解的，便是用户素材和计划游戏。用户素材其实是一个包含的需求、时间、优先级、代价等信息的计划列表，在这个列表中，客户和开发人员都能够很快的知道最值得做的事情是什么，什么事情可以暂时放一放；而计划游戏，则是由开发人员根据自己最近一次发布和迭代得到下次的预算（比如能完成几个用户素材），然后客户根据预算，选择下一个版本需要发布的不超过预算的用户素材。\n\n在 XP\n中，有许多实践都是相辅相成的，比如在开放的环境中进行工作，需要结对编程的辅助。如果各自为营，那么即使是开放的环境，也是没有太大的意义了。XP\n正式由这些一个又一个实践组合而成，才能够带来如此高效的敏捷开发过程。\n\n== 第三章 计划\n\n____\n当你能够度量你所说的，并且能够用数字去表达他时，就表示你了解了他；若你不能度量他，不能用数字去表达他，那么说明你的知识就是匮乏的，不能令人满意的。\n____\n\n正如上面所说，用户素材和计划游戏是我认为较为难以理解的两个点，在第三章就对这俩个进行了很形象和详细的解释。我换一种方式来描述一下我对这两个的理解\n\n=== 初始探索\n\n假设我是一位游戏代练人员，而我的客户则是希望我为他代练代练游戏账号，在一开始进行交涉的的时候，他就提出了他代练的需求：等级从0级到达50级，拥有一套极品装备。这就是他的需求，我们将他转化为用户素材，0级到50级是一个漫长的过程，随着等级提高，难度逐渐增加，他是一个过大的素材点，所以我们将他进行分解：\n\n* 等级 0-10\n* 等级 11-18\n* 等级 19-25\n* …\n\n这样就完成了一个大的用户素材的分解，而一身的极品装备也是一个过大的用户素材，将他分解\n\n* 拥有一个极品头盔\n* 拥有一件极品翅膀\n* …\n\n同时我们假设一个初始的速度因子，两天的时间完成一个用户素材，并对他们分配素材任务点，对于等级代练，都可以是一个固定的\n2 点，也就是一个用户素材，需要 2×2=4 天完成；对于装备，将他固定为 3\n点，那么也就需要 2×3=6 天完成，当然，这个猜测 2\n天是会改变的，这就完成我们的**初始探索**。\n\n=== 发布计划\n\n此时，等级代练属于简单并且容易实现的素材，而极品装备的代练属于重要并且代价高昂的素材，业务人员(客户)寻爱的那个哪些能够嗲来最大化利益的素材，对第一次交接（发布）达成一致，并确定这些素材的实现顺序。这就是**发布计划**。\n\n=== 迭代计划\n\n我们与客户决定迭代的规模，一般需要两周，客户选择了素材后，这期间的实现顺序则是由代练人员进行决定，采用最具有技术意义的顺序来实现这些素材。一旦开始，就不能够改变实现期间的素材，除正在完成的素材，其他的都可以修改。由第一次的迭代能够得出速度，能够及时调整任务点。例如代练预计两天的速度因子，但是由于游戏活动期间，经验翻倍，爆率翻倍，那么第一次迭代完成了十四个任务点，速度因子应该调整为一天，同时计划下一次迭代中也完成十四个点，速度就是每次迭代十四个点。这样的速度反馈是非常及时的，能够有助于保持计划与实际状况的同步，这就是**迭代计划**。\n\n=== 任务计划\n\n等级代练中，0-10\n级为一个用户素材，我们将他分解为一个一个的代练任务任务，一个任务就是能够在4-16小时内完成的功能，在客户的帮组下对素材进行分析，尽可能完全地列举出所有的任务。每个代练的人员都知道最近一次的迭代中所完成的任务点数，那么下次接任务的时候，就不会超过个人预算。同样如果你是等级代练的人员，你可以选择去代练极品装备，因为并没有强制要求必须对口，更加希望的是能够将知识传播给每个团队成员。这就是**任务计划**。\n\n=== 迭代的中点\n\n在我们代练的过程中，完成了素材一半的时候，应该召开一次会议，\n同时应该有一般的用户素材被完成。如果没有完成要及时告知客户，以做出新的策略和改变。\n\n=== 迭代\n\n客户在每次迭代过程中都能看到代练的进度，代练进入了以各种可以预测的、舒适的节奏。\n\n=== 结论\n\n一个完整计划是复杂的，但是一旦完成，那么收获和后期都是一个十分美好和轻松的，它意味着管理人员能够控制着团队以最小的代价获得最大的商业价值。\n\n== 第四章 测试\n\n____\n烈火验真金，逆境磨意志。\n____\n\n这一章是内容是让我们了解测试驱动开发（TDD）的方法和理念，自己深受影响。引用中的``烈火''和``逆境''，就像是一次次测试的失败，当你测试成功后，就是你代码完成的时候。而正如开头的几个疑问句，都问进我心里，测试驱动的开发方式有什么好处呢？\n\n[arabic]\n. 程序中的每一项功能都有测试来验证它的操作的正确性。\n. 迫使我们使用不同的观察点。\n. 迫使我们把程序设计为可测试的。\n. 无价的文档格式。\n. 有意图的编程。\n. 暴露程序中应该被解耦合的区域。\n\n这样，使用测试就潜移默化的在改变着我们程序的构架，在他的用例中，先写测试，再按照测试所按时的接口去写，再通过测试，对于junit来说，就是从\n*红灯 —— 绿灯* 的过程。\n\n不过以前自己以为写一个 junit\n单元测试（对java来说）就算是测试用例了，没错，单元测试是必要的，但是不够充分。一个项目是一个整体，我们需要去验证系统作为一个整体时工作的正确性，这个时候就是需要**验收测试**了\n\n* 单元测试：用来验证系统中个别机制的白盒测试。\n* 验收测试：用来验证系统满足客户需求的黑盒测试。\n\n一个黑盒，一个白盒，具有很大的区别。前期验收测试使用自动化，会对我们的迭代带来意想不到的效果。\n\n== 第五章 重 构\n\n____\n大千世界中，唯一缺乏的就是人类的注意力。\n____\n\n的确，世界那么大，你注意到了多少美好呢？你能够专注于多少事呢？书中提到在我们软件开发中，每一个软件模块都有三项职责\n\n[arabic]\n. 能够运行起来所完成的功能。\n. 它要应对的变化。\n. 要和阅读他的人沟通。\n\n这一章节他通过一个案例进行讲述，我也去实现了这个案例，但是发现似乎在某些方面自己不能够理解。\n\n....\n/**\n * 这是一个重构代码示例，此代码为原始代码\n * <p>\n * 他的功能是计算 0 到某个最大值区间的所有素数\n *\n * @author EchoCow\n */\nclass GeneratePrimes {\n    static int[] generatePrimes(int maxValue) {\n        if (maxValue >= 2) {\n            // 初始化\n            int s = maxValue + 1;\n            boolean[] f = new boolean[s];\n            int i;\n\n            // 初始化所有数组为 真\n            for (i = 0; i < s; i++) {\n                f[i] = true;\n            }\n\n            f[0] = f[1] = false;\n\n            // 筛选\n            int j;\n            for (i = 2; i < Math.sqrt(s) + 1; i++) {\n                for (j = 2 * i; j < s; j += i) {\n                    f[j] = false;\n                }\n            }\n\n            int count = 0;\n            for (i = 0; i < s; i++) {\n                if (f[i]) {\n                    count++;\n                }\n            }\n            int[] primes = new int[count];\n            for (i = 0, j = 0; i < s; i++) {\n                if (f[i]) {\n                    primes[j++] = i;\n                }\n            }\n            return primes;\n        } else {\n            return new int[0];\n        }\n    }\n}\n....\n\n这是项目的初始代码，在我看来的确一般，正如一个初学者一样，曾经自己写的代码也是如此，一个方法走到底，各种垃圾变量名满天飞，但是他确实是能够很好的达到目标的，测试如下：\n\n....\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n * 单元测试\n *\n * @author EchoCow\n */\nclass GeneratePrimesTest {\n    @Test\n    void test() {\n        int[] nullArray = GeneratePrimes.generatePrimes(0);\n        assertEquals(nullArray.length, 0);\n        int[] minArray = GeneratePrimes.generatePrimes(2);\n        assertEquals(minArray.length, 1);\n        int[] threeArray = GeneratePrimes.generatePrimes(3);\n        assertEquals(threeArray.length, 2);\n        assertEquals(threeArray[0], 2);\n        assertEquals(threeArray[1], 3);\n        int[] centArray = GeneratePrimes.generatePrimes(100);\n        assertEquals(centArray.length, 25);\n        assertEquals(centArray[24], 97);\n    }\n}\n....\n\n绿灯通过，似乎我们的任务完成了？如果你不想被以后来的程序员在心里大骂大可以放心走了\n，但是作为有点代码洁癖的人，是不能够忍受的。我们按照他的路程，先将一个冗长的方法修改为各司其职的私有方法\n\n....\n/**\n * 这是一个重构代码示例，此代码为修改的第一个版本\n * <p>\n * 在这个版本里，我们将他一个方法修改了三个方法，各司其职\n * 并抽取了公共变量并改名为 PrimesGenerateV1\n *\n * @author EchoCow\n */\nclass PrimesGenerateV1 {\n    private static int s;\n    private static boolean[] f;\n    private static int[] primes;\n\n    static int[] generatePrimes(int maxValue) {\n        if (maxValue < 2) {\n            return new int[0];\n        } else {\n            initSieve(maxValue);\n            sieve();\n            loadPrimes();\n            return primes;\n        }\n    }\n\n    /**\n     *  加载素数\n     */\n    private static void loadPrimes() {\n        int i,j;\n        int count = 0;\n        for (i = 0; i < s; i++) {\n            if (f[i]) {\n                count++;\n            }\n        }\n        primes = new int[count];\n        for (i = 0, j = 0; i < s; i++) {\n            if (f[i]) {\n                primes[j++] = i;\n            }\n        }\n    }\n\n    /**\n     * 筛选\n     */\n    private static void sieve() {\n        int i, j;\n        for (i = 2; i < Math.sqrt(s) + 1; i++) {\n            for (j = 2 * i; j < s; j += i) {\n                f[j] = false;\n            }\n        }\n    }\n\n    /**\n     * 初始化\n     *\n     * @param maxValue 最大值\n     */\n    private static void initSieve(int maxValue) {\n        // 初始化\n        s = maxValue + 1;\n        f = new boolean[s];\n        int i;\n\n        // 初始化所有数组为 真\n        for (i = 0; i < s; i++) {\n            f[i] = true;\n        }\n\n        f[0] = f[1] = false;\n    }\n}\n....\n\n在这个版本里，我们将他一个方法修改了三个方法，各司其职。哪里出了问题都能够及时找出来。但是依旧可以看到一些\ns 还有杂乱的 initSieve 方法，我们继续修改得到第二版\n\n....\n/**\n * 这是一个重构代码示例，此代码为修改的第二个版本\n * <p>\n * 在这个版本里，我们对 initSieve 方法进行了整理\n * 修改了三个函数的名字\n *\n * @author EchoCow\n */\nclass PrimesGenerateV2 {\n    private static boolean[] f;\n    // 修改一个变量名，结果\n    private static int[] result;\n\n    static int[] generatePrimes(int maxValue) {\n        if (maxValue < 2) {\n            return new int[0];\n        } else {\n            // 修改函数名称\n            initArrayOfIntegers(maxValue);\n            crossOutMultiples();\n            putUncrossedIntegerIntoResult();\n            return result;\n        }\n    }\n\n    /**\n     * 加载素数\n     */\n    private static void putUncrossedIntegerIntoResult() {\n        int i, j;\n        int count = 0;\n        for (i = 0; i < f.length; i++) {\n            if (f[i]) {\n                count++;\n            }\n        }\n        result = new int[count];\n        for (i = 0, j = 0; i < f.length; i++) {\n            if (f[i]) {\n                result[j++] = i;\n            }\n        }\n    }\n\n    /**\n     * 筛选\n     */\n    private static void crossOutMultiples() {\n        int i, j;\n        for (i = 2; i < Math.sqrt(f.length) + 1; i++) {\n            for (j = 2 * i; j < f.length; j += i) {\n                f[j] = false;\n            }\n        }\n    }\n\n    /**\n     * 初始化\n     *\n     * @param maxValue 最大值\n     */\n    private static void initArrayOfIntegers(int maxValue) {\n        // 修改初始化方式\n        f = new boolean[maxValue + 1];\n        int i;\n        f[0] = f[1] = false;\n        for (i = 2; i < f.length; i++) {\n            f[i] = true;\n        }\n    }\n}\n....\n\n在这个版本里，我们对 initSieve\n方法进行了整理，修改了三个函数的名字。以及一些变量的名字，依旧可以看到一些不知名的变量比如\n·int i = 0`还有`f`，继续修改\n\n....\n/**\n * 这是一个重构代码示例，此代码为修改的第三个版本\n * <p>\n * 在这个版本里，我们对许多变量进行了重构\n * 去掉了初始化语句，提取循环\n * 添加一个新的函数消除歧义\n * 所有的循环变量都是在 for 内有效，所有 i 都从 2 开始\n *\n * @author EchoCow\n */\nclass PrimesGenerateV3 {\n    // 修改变量名，同时修改了所有布尔值的含义\n    private static boolean[] isCrossed;\n    private static int[] result;\n\n    static int[] generatePrimes(int maxValue) {\n        if (maxValue >= 2) {\n            initArrayOfIntegers(maxValue);\n            crossOutMultiples();\n            putUncrossedIntegerIntoResult();\n            return result;\n        }\n        return new int[0];\n    }\n\n    /**\n     * 加载素数\n     */\n    private static void putUncrossedIntegerIntoResult() {\n        // 获取到没有被过滤掉的整数条目，初始化\n        result = new int[numberOfUncrossedIntegers()];\n        // 把没有被过滤掉的整数搬移到结果数组中\n        for (int j = 0, i = 2; i < isCrossed.length; i++) {\n            if (notCrossed(i)) {\n                result[j++] = i;\n            }\n        }\n    }\n\n    /**\n     * 计算数组中没有被过滤掉的整数条目\n     *\n     * @return 没有被过滤掉的整数条目\n     */\n    private static int numberOfUncrossedIntegers() {\n        int count = 0;\n        for (int i = 2; i < isCrossed.length; i++) {\n            if (notCrossed(i)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * 筛选\n     */\n    private static void crossOutMultiples() {\n        for (int i = 2; i < calcMaxPrimeFactor(); i++) {\n            if (notCrossed(i)) {\n                crossOutMultiplesOf(i);\n            }\n        }\n    }\n\n    /**\n     * 初始化\n     *\n     * @param maxValue 最大值\n     */\n    private static void initArrayOfIntegers(int maxValue) {\n        // 修改初始化方式\n        isCrossed = new boolean[maxValue + 1];\n        for (int i = 2; i < isCrossed.length; i++) {\n            isCrossed[i] = false;\n        }\n    }\n\n    private static void crossOutMultiplesOf(int i) {\n        for (int multiple = 2 * i; multiple < isCrossed.length; multiple += i) {\n            isCrossed[multiple] = true;\n        }\n    }\n\n    /**\n     * 修改原来的 if\n     */\n    private static boolean notCrossed(int i) {\n        return !isCrossed[i];\n    }\n\n    /**\n     * 获取到条件值\n     */\n    private static int calcMaxPrimeFactor() {\n        return (int) (Math.sqrt(isCrossed.length) + 1);\n    }\n\n}\n....\n\n第三个版本改动比较多，我们对许多变量进行了重构，最重要的是以前只有三个方法，虽然三个方法都描述了功能，但是却一个方法里面包含了多个功能以及多个\n`for`\n循环，因此，我们将他抽取了出来，能够见名知意，到了这，重构其实已经很成功了，但是我们还需要再次阅读，然后发现有些地方还是有瑕疵，再次重构。\n\n....\n/**\n * 这是一个重构代码示例，此代码为修改的第四个版本\n * <p>\n * 在这个版本里，我们再次对方法名和变量名进行重构\n *\n * @author EchoCow\n */\nclass PrimesGenerateV4 {\n    // 修改变量名\n    private static boolean[] crossedOut;\n    private static int[] result;\n\n    static int[] generatePrimes(int maxValue) {\n        if (maxValue >= 2) {\n            uncrossIntegersUpTo(maxValue);\n            crossOutMultiples();\n            putUncrossedIntegerIntoResult();\n            return result;\n        }\n        return new int[0];\n    }\n\n    /**\n     * 把没有被过滤掉的整数搬移到结果数组中\n     */\n    private static void putUncrossedIntegerIntoResult() {\n        // 获取到没有被过滤掉的整数条目，初始化\n        result = new int[numberOfUncrossedIntegers()];\n        for (int j = 0, i = 2; i < crossedOut.length; i++) {\n            if (notCrossed(i)) {\n                result[j++] = i;\n            }\n        }\n    }\n\n    /**\n     * 计算数组中没有被过滤掉的整数条目\n     *\n     * @return 没有被过滤掉的整数条目\n     */\n    private static int numberOfUncrossedIntegers() {\n        int count = 0;\n        for (int i = 2; i < crossedOut.length; i++) {\n            if (notCrossed(i)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * 筛选\n     */\n    private static void crossOutMultiples() {\n        for (int i = 2; i < determineIterationLimit(); i++) {\n            if (notCrossed(i)) {\n                crossOutMultiplesOf(i);\n            }\n        }\n    }\n\n    private static void uncrossIntegersUpTo(int maxValue) {\n        crossedOut = new boolean[maxValue + 1];\n        for (int i = 2; i < crossedOut.length; i++) {\n            crossedOut[i] = false;\n        }\n    }\n\n    private static void crossOutMultiplesOf(int i) {\n        for (int multiple = 2 * i; multiple < crossedOut.length; multiple += i) {\n            crossedOut[multiple] = true;\n        }\n    }\n\n    /**\n     * 修改原来的 if\n     */\n    private static boolean notCrossed(int i) {\n        return !crossedOut[i];\n    }\n\n    /**\n     * 获取到条件值\n     */\n    private static int determineIterationLimit() {\n        /*\n          去掉了 +1 ，因为他是不必要的，\n          真正的遍历上限是小于或者等于数组长度的平方根的最大素数\n         */\n        return (int) Math.sqrt(crossedOut.length) ;\n    }\n\n}\n....\n\n第四个版本也是最后一个版本，在这里，做了一点小小的改动，一个是修改名称，另外一个是去掉了\n`+1`，测试用例通过。\n\n这就是重构，我们没有修改他的功能，而只是对内部进行了修改，使他能够满足三项职责的\n二、三。重构后的代码，能够更加友好，为了每天清洁代码，保持代码的清洁，对于由代码洁癖的同学，重构简直的天生定制一般。\n\n== 疑问\n\n*Q：书中多次提到自组织团队，到底是什么？*\n\nA：在经过刘大指点后，自己理解的自组织团队应该具有这么几个特点\n\n[arabic]\n. 对产品由所有权\n. 能够自觉干活，自觉改进\n. 全能型团队，具有各色的人\n. 能够自治，主动的完成任务\n. 定期讨论，积极友好\n\n这样的团队多么友好，在极限编程那一章节中，多次提到的就是不需要一个人完全只负责他专业对口的模块，即使他是做\nUI\n的，他也可以接受数据库的任务，在与结对编程实践与数据库专家学习的途中，能够很好的提升专业知识，能够很好的是的团队专业水平提高，我想这也是极限编程核心之一，一个团队的平均水平上来了，远强于于只有一个大佬的团队。\n\n*Q：为什么在重构中提取了一句话代码单独封装到一个私有方法中？*\n\n在实践书中重构的的示例的时候，发现有两个方法都是一句话代码\n\n....\n    private static int determineIterationLimit() {\n        /*\n          去掉了 +1 ，因为他是不必要的，\n          真正的遍历上限是小于或者等于数组长度的平方根的最大素数\n         */\n        return (int) Math.sqrt(crossedOut.length) ;\n    }\n....\n\n此方法是获取 遍历的极限 的方法，他会的就是 `for`\n循环中的条件，但是为什么要单独拿出来一个方法呢？因为多点注释？还是因为能够更好的明白这一句呢？\n\n....\n    private static boolean notCrossed(int i) {\n        return !crossedOut[i];\n    }\n....\n\n此方法只是单纯为能够更好的读懂代码。\n\n那如果按照这种思路，实际开发中，一个 class\n里面要多少个一句话私有方法啊？我一直没有想明白这点。\n\n== 结论\n\n三十多页还是很快就看完了，大多都是理论上的知识，不过也架构了敏捷开发的一个知识体系，能够更好读懂一些必要的东西，下一章的一个实例就占据前五章的篇幅，想必是个很有意思的期待吧。\n\n","fields":{"slug":"/articles/2019/03/01/1551401439594.html","birthTime":"2019-03-02T09:54:33.257Z","modifiedTime":"2019-03-02","year":2019},"document":{"title":"[阅读] 敏捷软件开发 —— 敏捷开发（一）"}},{"content":"= [阅读] 敏捷软件开发 —— 敏捷开发（二）\n:page-description: [阅读] 敏捷软件开发 —— 敏捷开发（二）\n:page-category: 阅读\n:page-image: https://img.hacpai.com/bing/20180816.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2019/03/09/1552119273889.html\n:page-created: 1552119274161\n:page-modified: 1552149418718\n:toc:\n\n快一周过去了，再次拿起这本书。周六是美好的日子，没有学校的课程，不用担心作业，没有人约，也不用去考虑太多其他琐事，只需要静下来看会儿书，多么惬意美好。\n\n== 回顾\n\n总得回顾一下上周看了些什么的，然而写读后感的好处莫过于不用再去翻书啦。看看自己上周写的文章，文字不多不少，但是也是体会颇深，也会有一些不同的体会。\n\n* 敏捷是有组织的，是团队性的。\n* 敏捷开发方法：极限编程。\n* 用户素材 与 任务计划。\n* 测试驱动开发，从无到有的构建。\n* 重构是必要的。\n\n今天开始学习第六章，一次编程实战，*长文预警！*\n\n== 一次编程实战\n\n____\n设计和编程都是人的活动，忘记了这一点，将会失去一切。\n____\n\n这一章节，是一次 XP\n的编程的实践，章节中采用的是以对话的形式展现，相比于无聊的阐述，以故事的方式却好了很多。汲取朋友的经验，在这之前先去最后一页翻看了\n保龄球比赛\n规则，了解了规则后再看看确实棒很多！但是发现光看的话不能全身心的投入进去，所以准备实践一番。\n\n在这里，我将我所学习到的分为连个部分来总结，不过在那之前，还是需要了解的应该是保龄球规则~~~\n\n== 保龄球规则\n\n保龄球是一种比赛，比赛者把一个哈密瓜大小的球顺着一条窄窄的球道投向10个木瓶。目的是在每次投球中击倒尽可能多的木瓶。\n\n一局比赛由10轮组成。每轮开始，10个木瓶都是竖立摆放的。比赛者可以投球两次，尝试击倒所有木瓶。\n\n如果比赛者在第一次投球中就击倒了所有木瓶，称之为``全中''，并且本轮结束。\n\n如果比赛者在第一次投球中没有击倒所有木瓶，但在第二次投球中成功击倒了所有剩余的木瓶，称之为``补中''。一轮中第二次投球后，即使还有未被击倒的木瓶，本轮也宣告结束。\n\n[arabic]\n. 全中轮的记分规则为：10，加上接下来的两次投球击倒的木瓶数，再加上前一轮的得分。\n. 补中轮的记分规则为：10，加上接下来的一次投球击倒的木瓶数，再加上前一轮的得分。\n. 其他轮的记分规则为：本轮中两次投球所击倒的木瓶数，加上前一轮的得分。\n\n如果在第10轮全中，那么比赛者可以再多投球两次，以完成对全中的记分。同样，如果第10轮为补中，那么比赛者可以再多投球一次，以完成对补中的记分。因此，第10轮可以包含3次投球而不是2次。\n\n* 保龄球：bowling\n* 木瓶：ball\n* 局：game\n* 轮：frame\n* 全中：strike\n* 补中：spare\n\n== 测试驱动开发\n\n两个人的 XP\n编程，一起商讨需求，在确定好了以后，每次首先进行的就是编写测试用例。*主人公分别是\nRSK 和 RCM，以下简称 S 和 C。*\n\n=== 普通情况\n\n对于这个实战，我们需要明白 `输入` 和 `输出` 是什么。\n\n* *输入： 一个投掷（throw）的序列*\n* *输出：每一轮（Frame）的得分*\n\n然而，S 提出对于 `Throw` 类并不需要测试：\n\n____\n关注有实际行为的对象，而不是仅仅存储数据的对象。\n____\n\n很明显，throw 不过是一个存储数据的对象。所以，将目光移至依赖链上的\n`Frame` 类，所以，为他编写测试用例。\n\n* 测试用例\n`java      @Test      void testScoreNoThrows(){          Frame frame = new Frame();          frame.add(5);          assertEquals(5, frame.getScore());      }`\n* 编译通过 ```java public class Frame \\{ private int itsScore = 0;\npublic void add(int pins) \\{\n+\n....\n }\n\n public int getScore() {\n     return 0;\n }\n....\n+\n} ```\n* 测试通过\n+\n[source,java]\n----\npublic class Frame {\n    private int itsScore = 0;\n    public void add(int pins) {\n        itsScore += pins;\n    }\n\n    public int getScore() {\n        return itsScore;\n    }\n}\n----\n\n这个时候，最最最基本的要求就达到了。但是对于 `add`\n方法，是十分脆弱的，当参数为 `11`\n的时候，就会出现预料之外的情况。但是现在其实并不需要太过多的考虑，我们首先做的不过是基础的进球能够实现。\n\n这时 C 提出，现在的代码却有一个问题，我们以 _一轮_\n为单位，但是保龄球比赛是有十轮的，当进行到后面几轮的时候，调用\n`getScore` 是没有意义的，因为一个 `Frame`\n只代表了一轮。而且，当计算总分的时候还需要将所有的 `Frame`\n给一起计算起来，是十分繁琐的，那么我们希望的是什么呢？ —— `Frame`\n之间互相知晓，而谁会持有这些不同的 `Frame`\n对象呢？那应该上升依赖链，多个`Frame`\n是属于一场游戏（Game）的，这个时候，输出应该由 `Frame` 变成\n`Game`。`Game` 对象构建了 `Frame`\n并把他们串连起来，所以，我们注意力开始再次变化：\n\n____\nThrows 分数 ——> Frame 轮数 ——> Game 一场游戏\n____\n\n现在我们将注意力放到 `Game` 上面，写一个同样的测试用例。\n\n* 测试用例\n+\n[source,java]\n----\n    @Test\n    void testOneThrows() {\n        Game game = new Game();\n        game.add(5);\n        assertEquals(5, game.score());\n    }\n----\n* 编译通过 ```java public class Game \\{ private int itsScore = 0; public\nint score()\\{ return 0; }\n+\n....\n public void add(int pins) {\n\n }\n....\n+\n} ```\n* 测试通过\n+\n[source,java]\n----\npublic class Game {\n    private int itsScore = 0;\n    public int score(){\n        return itsScore;\n    }\n\n    public void add(int pins) {\n        itsScore += pins;\n    }\n}\n----\n\n它具有和 `Frame` 具有同样的功能。但我们任然需要解决以及寻找需要多个\n`Frame` 的证据，因为他是我们使用 `Game` 的最初理由。我们逐步完成\n`Game`，S 提出编写一个有两次投掷但是没有补中的测试。\n\n* 测试用例\n+\n[source,java]\n----\n    @Test\n    void testTwoThrowsNoMark(){\n        Game game = new Game();\n        game.add(5);\n        game.add(4);\n        assertEquals(9, game.score());\n    }\n----\n* 无需修改其他，编译通过\n* 无需修改其他，测试通过\n\n一轮两次的投掷，是没有问题，那么如果两轮四次呢？并且我们需要知道每一轮之后的分数是多少，接下来我们继续测试用例的书写。\n\n* 测试用例\n+\n[source,java]\n----\n    @Test\n    void testFourThrowsNoMark(){\n        Game game = new Game();\n        game.add(5);\n        game.add(4);\n        game.add(7);\n        game.add(2);\n        assertEquals(18, game.score());\n        assertEquals(9, game.scoreForFrame(1));\n        assertEquals(18, game.scoreForFrame(2));\n    }\n----\n* 编译通过\n+\n[source,java]\n----\n    public int scoreForFrame(int frame) {\n        return 0;\n    }\n----\n* 测试通过\n+\n[source,java]\n----\npublic class Game {\n    /**\n     * 投掷序列，最大可能的投掷次数是 21 次 —— C 的回答\n     */\n    private int[] itsThrows = new int[21];\n    /**\n     * 当前第几轮投掷\n     */\n    private int itsCurrentThrow = 0;\n\n    private int itsScore = 0;\n    public int score(){\n        return itsScore;\n    }\n\n    public void add(int pins) {\n        // 存放到 投掷序列 中\n        itsThrows[itsCurrentThrow++] = pins;\n        itsScore += pins;\n    }\n\n    public int scoreForFrame(int frame) {\n        // 到指定轮数的总分\n        int score = 0;\n        for (int ball = 0;\n             frame > 0 && (ball < theFrame);\n             ball += 2, frame --) {\n            score += itsThrows[ball] + itsThrows[ball + 1];\n        }\n        return score;\n    }\n}\n----\n\n现在测试用例已经通过了，但是 S 提出他似乎不是那么美观，因为他违反了\n单一职责原则（SRP），所以需要重构，不过我们暂且把重构这件事情放放，C\n来简化这个循环。\n\n[source,java]\n----\n    public int scoreForFrame(int theFrame) {\n        // 到指定轮数的总分\n        int score = 0;\n        int ball = 0;\n        for (int currentFrame = 0;\n             currentFrame < theFrame;\n             currentFrame ++) {\n            score += itsThrows[ball++] + itsThrows[ball++];\n        }\n        return score;\n    }\n----\n\n这样看上去比上面的好了很多，但是 C\n觉得会不会有其他问题呢？是的，他可能存在的的问题就是运算符的优先级问题，对于\n`score` 的值似乎和我们预想的不一样。我们稍微修改一下。\n\n[source,java]\n----\n    public int scoreForFrame(int theFrame) {\n        // 到指定轮数的总分\n        int score = 0;\n        int ball = 0;\n        for (int currentFrame = 0; currentFrame < theFrame; currentFrame ++) {\n            int firstThrow = itsThrows[ball++];\n            int secondThrow = itsThrows[ball++];\n            score += firstThrow + secondThrow;\n        }\n        return score;\n    }\n----\n\n这样可能就明白了很多，对于密友补中和全中的情况，我们似乎已经完成了，来进行一次完整的测试——运行整个\n`TestGame` 类，他的三个已有的测试方法都会是绿色通过。\n\n=== 简单重构\n\nC 提出我们现在的测试似乎有点问题\n\n[source,java]\n----\nclass TestGame {\n    @Test\n    void testOneGame(){\n        Game game = new Game();\n        //... other code\n    }\n\n    @Test\n    void testTwoThrowsNoMark(){\n        Game game = new Game();\n        //... other code\n    }\n\n    @Test\n    void testFourThrowsNoMark(){\n        Game game = new Game();\n        //... other code\n    }\n}\n----\n\n是的，似乎都是重复性的 `new`\n，十分不友好，也__不敏捷__，那我们简单的重构下测试吧。\n\n[source,java]\n----\nclass TestGame {\n    private Game game;\n    // 对于 junit 4 ，你应该使用 @Before 注解\n    @BeforeEach\n    void setUp() {\n        game = new Game();\n    }\n\n    @Test\n    void testOneGame() {\n        game.add(5);\n        assertEquals(5, game.score());\n    }\n\n    @Test\n    void testTwoThrowsNoMark(){\n        game.add(5);\n        game.add(4);\n        assertEquals(9, game.score());\n    }\n\n    @Test\n    void testFourThrowsNoMark(){\n        game.add(5);\n        game.add(4);\n        game.add(7);\n        game.add(2);\n        assertEquals(18, game.score());\n        assertEquals(9, game.scoreForFrame(1));\n        assertEquals(18, game.scoreForFrame(2));\n    }\n}\n----\n\n修改完后，应该运行整个类，以保证所有的测试方法都是可以通过的。\n\n=== 补中情况\n\n简单重构测试完成，那么我们继续来写关于补中的情况，同样，测试驱动：\n\n* 测试用例\n+\n[source,java]\n----\n    @Test\n    void testSimpleSpare(){\n        game.add(3);\n        game.add(7);\n        game.add(3);\n        assertEquals(13, game.scoreForFrame(1));\n    }\n----\n* 无需修改，编译通过\n* 测试通过\n+\n[source,java]\n----\n    public int scoreForFrame(int theFrame) {\n        // 到指定轮数的总分\n        int score = 0;\n        int ball = 0;\n        for (int currentFrame = 0;\n             currentFrame < theFrame;\n             currentFrame ++) {\n            int firstThrow = itsThrows[ball++];\n            int secondThrow = itsThrows[ball++];\n            // 这一轮的分数\n            int frameScore = firstThrow + secondThrow;\n            // 是否补选\n            if (frameScore == 10){\n                // 补选的情况需要加上下一轮的第一次分数\n                score += frameScore + itsThrows[ball++];\n            } else {\n                score += frameScore;\n            }\n        }\n        return score;\n    }\n----\n\nC\n觉得看起来似乎不错，因为测试用例通过了，但是是否就完成了呢？来进行一个测试\n\n[source,java]\n----\n    @Test\n    void testSimpleFrameAfterSpare() {\n        game.add(3);\n        game.add(7);\n        game.add(3);\n        game.add(2);\n        assertEquals(13, game.scoreForFrame(1));\n        assertEquals(18, game.score());\n    }\n----\n\n结果是红灯，为什么呢？（C\n似乎很高兴发现这个错误）看看期望值的得到的值的区别\n\n....\nExpected :18\nActual   :15\n....\n\n结果相差三分，就是第三次 投掷 的分数，因为我们在 `scoreForFrame`\n方法最后，使得 `ball` 加一了，所以跳过了第三次 投掷 的分数，那我们去掉\n`++` 看看\n\n[source,java]\n----\n    if (frameScore == 10){\n        // 补选的情况需要加上下一轮的第一次分数\n        score += frameScore + itsThrows[ball++];\n    }\n----\n\n测试结果\n\n....\nExpected :18\nActual   :15\n....\n\n依旧不对且不变，那么我们试着把 `game.score()` 换成\n`game.scoreForFrame(2)` 试试？\n\n[source,java]\n----\n    @Test\n    void testSimpleFrameAfterSpare() {\n        game.add(3);\n        game.add(7);\n        game.add(3);\n        game.add(2);\n        assertEquals(13, game.scoreForFrame(1));\n        assertEquals(18, game.scoreForFrame(2));\n    }\n----\n\n嘿，他通过了，那么问题应该是出在 `score()` 方法上了，我们来看看 `score`\n方法：\n\n[source,java]\n----\n    public int score(){\n        return itsScore;\n    }\n\n    public void add(int pins) {\n        // 存放到 投掷序列 中\n        itsThrows[itsCurrentThrow++] = pins;\n        itsScore += pins;\n    }\n----\n\nC 发现了错误：是的，似乎问题，确实出在这里，因为返回的是 `itsScore`\n，而这个变量标识的仅仅是木瓶数目的综合，但他却不是得分，我们应该让\n`score` 做的是用当前轮作为参数去调用 `scoreForFrame()`\n方法。我们不知道当前哪轮，所以我们需要先写一个能够让我们知道当前第几轮的方法，完善下前面已经通过的所有测试用例：\n\n* 完善测试用例\n+\n[source,java]\n----\n@Test\nvoid testOneGame() {\n    game.add(5);\n    assertEquals(5, game.score());\n    // 当前第一轮\n    assertEquals(1, game.getCurrentFrame());\n}\n\n@Test\nvoid testTwoThrowsNoMark(){\n    game.add(5);\n    game.add(4);\n    assertEquals(9, game.score());\n    // 当前第一轮\n    assertEquals(1, game.getCurrentFrame());\n}\n\n@Test\nvoid testFourThrowsNoMark(){\n    game.add(5);\n    game.add(4);\n    game.add(7);\n    game.add(2);\n    assertEquals(18, game.score());\n    assertEquals(9, game.scoreForFrame(1));\n    assertEquals(18, game.scoreForFrame(2));\n    // 当前第二轮\n    assertEquals(2, game.getCurrentFrame());\n}\n----\n* 编译通过\n+\n[source,hava]\n----\npublic int getCurrentFrame() {\n    return 0;\n}\n----\n* 测试通过\n+\n[source,java]\n----\n    /**\n     * 当前第几轮\n     */\n    private int itsCurrentFrame = 0;\n    /**\n     * 是否是第一次投掷\n     */\n    private boolean firstThrow = true;\n\n    public int getCurrentFrame() {\n        return itsCurrentFrame;\n    }\n\n    public void add(int pins) {\n        // 存放到 投掷序列 中\n        itsThrows[itsCurrentThrow++] = pins;\n        itsScore += pins;\n        // 计算当前轮\n        if (firstThrow){\n            firstThrow = false;\n            itsCurrentFrame++;\n        } else {\n            firstThrow = true;\n        }\n    }\n----\n\n我们为他添加了两个成员变量用来让我们更好的查找当前轮，然后在 `add`\n里面设置值，这时运行修改的测试用例都是通过了的。不过 `add`\n函数的功能似乎有点多了，我们来把他修改得更易读一些。\n\n[source,java]\n----\n    public void add(int pins) {\n        // 存放到 投掷序列 中\n        itsThrows[itsCurrentThrow++] = pins;\n        itsScore += pins;\n        adjustCurrentFrame();\n    }\n\n    /**\n     *  计算当前轮\n     */\n    private void adjustCurrentFrame() {\n        if (firstThrow){\n            firstThrow = false;\n            itsCurrentFrame++;\n        } else {\n            firstThrow = true;\n        }\n    }\n----\n\nS 觉得似乎好多了，但是 当前轮 `itsCurrentFrame` 初始化为 0\n，是不是不太好？因为他不应该初始化为 0 ，应该为\n1，游戏是从第一轮开始而不是第 0\n轮。并且当前轮应该是正在进行的投掷的所在轮，应该在最后一次投掷完毕，才对他进行递增，而不是第一次投掷就递增，所以修改一下。\n\n* 修改测试用例\n+\n[source,java]\n----\n@Test\nvoid testTwoThrowsNoMark(){\n    game.add(5);\n    game.add(4);\n    assertEquals(9, game.score());\n    // 第一轮已经结束，到了第二轮了\n    assertEquals(2, game.getCurrentFrame());\n}\n\n@Test\nvoid testFourThrowsNoMark(){\n    game.add(5);\n    game.add(4);\n    game.add(7);\n    game.add(2);\n    assertEquals(18, game.score());\n    assertEquals(9, game.scoreForFrame(1));\n    assertEquals(18, game.scoreForFrame(2));\n    // 第二轮已经结束，到了第三轮了\n    assertEquals(3, game.getCurrentFrame());\n}\n----\n* 无需修改，编译通过\n* 测试通过\n+\n[source,java]\n----\nprivate int itsCurrentFrame = 1;\n\n/**\n *  计算当前轮\n */\nprivate void adjustCurrentFrame() {\n    if (firstThrow){\n        firstThrow = false;\n    } else {\n        firstThrow = true;\n        itsCurrentFrame++;\n    }\n}\n----\n\nC 觉得不错，修改了后，更容易让人理解了。现在我们来为 `getCurrentFrame`\n方法编写两个具有补中情况的测试用例。\n\n[source,java]\n----\n    @Test\n    void testSimpleSpare(){\n        game.add(3);\n        game.add(7);\n        game.add(3);\n        assertEquals(13, game.scoreForFrame(1));\n        assertEquals(2, game.getCurrentFrame());\n    }\n\n    @Test\n    void testSimpleFrameAfterSpare() {\n        game.add(3);\n        game.add(7);\n        game.add(3);\n        game.add(2);\n        assertEquals(13, game.scoreForFrame(1));\n        assertEquals(18, game.scoreForFrame(2));\n        assertEquals(3, game.getCurrentFrame());\n//        assertEquals(18, game.score());\n    }\n----\n\n通过了，现在我们回到原来的 `score` 的问题上来，现在已经有了\n当前轮，那么我们可以大胆的调用 `scoreForFrame` 方法了：\n\n* 测试用例\n+\n[source,java]\n----\n@Test\nvoid testSimpleFrameAfterSpare() {\n    game.add(3);\n    game.add(7);\n    game.add(3);\n    game.add(2);\n    assertEquals(13, game.scoreForFrame(1));\n    assertEquals(18, game.scoreForFrame(2));\n    assertEquals(3, game.getCurrentFrame());\n    assertEquals(18, game.score());\n}\n----\n* 无需修改，编译通过\n* 测试通过\n+\n[source,java]\n----\npublic int score(){\n    return scoreForFrame(getCurrentFrame() - 1);\n}\n----\n\n是的，这个方法测试通过了，但是其他的方法呢？在运行整个\n测试类，`testOneGame` 似乎有点问题：\n\n....\nExpected :5\nActual   :0\n....\n\n[source,java]\n----\n@Test\nvoid testOneGame() {\n    game.add(5);\n    assertEquals(5, game.score());\n    // 当前第一轮\n    assertEquals(1, game.getCurrentFrame());\n}\n----\n\n是代码的问题吗？不，你会发现这个测试用例根本不符合保龄球的规则，所以这个测试用例是不合法的。所以大可以将他直接去掉。\n\n补中的情况就完成了。\n\n=== 全中情况\n\n我们依旧来编写一个全中的测试用例\n\n* 测试用例\n+\n[source,java]\n----\n@Test\nvoid test(){\n    game.add(10);\n    game.add(3);\n    game.add(6);\n    assertEquals(19, game.scoreForFrame(1));\n    assertEquals(28, game.score());\n    assertEquals(3, game.getCurrentFrame());\n}\n----\n* 无需修改，编译通过\n* 测试通过\n+\n[source,java]\n----\n/**\n * 投掷\n *\n * @param pins 得分\n */\npublic void add(int pins) {\n    // 存放到 投掷序列 中\n    itsThrows[itsCurrentThrow++] = pins;\n    adjustCurrentFrame(pins);\n}\n\n/**\n *  计算当前轮\n */\nprivate void adjustCurrentFrame(int pins) {\n    if (firstThrow){\n        if (pins == 10){\n            // 全中\n            itsCurrentFrame++;\n        } else {\n            firstThrow = false;\n        }\n    } else {\n        firstThrow = true;\n        itsCurrentFrame++;\n    }\n}\n\n/**\n * 指定轮的总分\n *\n * @param theFrame 轮\n * @return 总分\n */\npublic int scoreForFrame(int theFrame) {\n    // 到指定轮数的总分\n    int score = 0;\n    int ball = 0;\n    for (int currentFrame = 0; currentFrame < theFrame; currentFrame ++) {\n        int firstThrow = itsThrows[ball++];\n        if (firstThrow == 10){\n            // 全中\n            score += 10 + itsThrows[ball] + itsThrows[ball + 1];\n        } else {\n            int secondThrow = itsThrows[ball++];\n            // 这一轮的分数\n            int frameScore = firstThrow + secondThrow;\n            // 是否补选\n            if (frameScore == 10){\n                // 补选的情况需要加上下一轮的第一次分数\n                score += frameScore + itsThrows[ball];\n            } else {\n                score += frameScore;\n            }\n        }\n    }\n    return score;\n}\n----\n\n通过啦！全中的情况似乎完成了？C 提出我们来一次完美的比赛评分看看\n\n[source,java]\n----\n    @Test\n    void testPerfectGame() {\n        for (int i = 0; i < 12; i++) {\n            game.add(10);\n        }\n        assertEquals(300, game.score());\n        assertEquals(10, game.getCurrentFrame());\n    }\n----\n\n但是似乎结果与我们相信的不同\n\n....\nExpected :300\nActual   :330\n....\n\nS 一眼就看出来了，是的，当前轮一直被累加到了 12，所以我们应该将他限定在\n10，修改一下方法\n\n[source,java]\n----\n    private void adjustCurrentFrame(int pins) {\n        if (firstThrow){\n            if (pins == 10){\n                // 全中\n                itsCurrentFrame++;\n            } else {\n                firstThrow = false;\n            }\n        } else {\n            firstThrow = true;\n            itsCurrentFrame++;\n        }\n        itsCurrentFrame = Math.min(10, itsCurrentFrame);\n    }\n----\n\n但是。。。C 很暴躁的发现结果似乎不对，因为代码似乎是没有问题的\n\n....\nExpected :300\nActual   :270\n....\n\nS 细心的发现， `score`\n需要减一，所以他只给出了第九轮的得分，而不是第十轮，所以因该是十一\n\n[source,java]\n----\nprivate void adjustCurrentFrame(int pins) {\n    if (firstThrow){\n        if (pins == 10){\n            // 全中\n            itsCurrentFrame++;\n        } else {\n            firstThrow = false;\n        }\n    } else {\n        firstThrow = true;\n        itsCurrentFrame++;\n    }\n    itsCurrentFrame = Math.min(11, itsCurrentFrame);\n}\n----\n\n但是运行后，发现当前轮似乎不对。。。\n\n....\nExpected :10\nActual   :11\n....\n\nC 和 S\n讨论了一下，似乎觉得这也应该是正确的结果及时有点不舒服（What？）所以应该修改的是测试用例：\n\n[source,java]\n----\n    @Test\n    void testPerfectGame() {\n        for (int i = 0; i < 12; i++) {\n            game.add(10);\n        }\n        assertEquals(300, game.score());\n        assertEquals(11, game.getCurrentFrame());\n    }\n----\n\nS 又想到了一种情况，如果最后数组全满了呢？\n\n[source,java]\n----\n@Test\nvoid testEndOfArray() {\n    for (int i = 0; i < 9; i++) {\n        game.add(0);\n        game.add(0);\n    }\n    game.add(2);\n    game.add(8);\n    game.add(10);\n    assertEquals(20, game.score());\n}\n----\n\n很好，S 很开心因为他也通过了。\n\n再来测试下如果记分板的所有数据输入到程序中呢？\n\n[source,java]\n----\n@Test\nvoid testSampleGame() {\n    game.add(1);\n    game.add(4);\n    game.add(4);\n    game.add(5);\n    game.add(6);\n    game.add(4);\n    game.add(5);\n    game.add(5);\n    game.add(10);\n    game.add(0);\n    game.add(1);\n    game.add(7);\n    game.add(3);\n    game.add(6);\n    game.add(4);\n    game.add(10);\n    game.add(2);\n    game.add(8);\n    game.add(6);\n    assertEquals(133, game.score());\n}\n----\n\n通过啦，C 提议再来测试一下边界情况\n\n[source,java]\n----\n@Test\nvoid testHeartBreak(){\n    for (int i = 0; i < 11; i++) {\n        game.add(10);\n    }\n    game.add(9);\n    assertEquals(299, game.score());\n}\n----\n\n通过啦，C 再次提议第十轮补中的情况如何：\n\n[source,java]\n----\n@Test\nvoid testTenthFrameSpare() {\n    for (int i = 0; i < 9; i++) {\n        game.add(10);\n    }\n    game.add(9);\n    game.add(1);\n    game.add(1);\n    assertEquals(270, game.score());\n}\n----\n\n=== 重构\n\nC 和 S\n都想不出其他的测试用例了，他们觉得应该重构这个这个程序。在这之前，应该测试一下整个\n`TestGame` 测试类的所有方法，保证他们都能够通过。\n\n____\n请注意，重构过程中一定保证所有测试用例都是通过的。\n\nimage:https://resources.echocow.cn/file/2019/3/9/QQ%E6%88%AA%E5%9B%BE20190309224101.png[image]\n____\n\n下面来看看第一个需要重构的 `scoreForFrame` 方法\n\n[source,java]\n----\npublic int scoreForFrame(int theFrame) {\n    // 到指定轮数的总分\n    int score = 0;\n    int ball = 0;\n    for (int currentFrame = 0; currentFrame < theFrame; currentFrame ++) {\n        int firstThrow = itsThrows[ball++];\n        if (firstThrow == 10){\n            // 全中\n            score += 10 + itsThrows[ball] + itsThrows[ball + 1];\n        } else {\n            int secondThrow = itsThrows[ball++];\n            // 这一轮的分数\n            int frameScore = firstThrow + secondThrow;\n            // 是否补选\n            if (frameScore == 10){\n                // 补选的情况需要加上下一轮的第一次分数\n                score += frameScore + itsThrows[ball];\n            } else {\n                score += frameScore;\n            }\n        }\n    }\n    return score;\n}\n----\n\nemmmmm，，，的确很乱。C 提议可以把 `else` 下的一堆都给抽离为一个方法，S\n提议把局部变量变成成员变量，S 抢过键盘，进行重构。\n\n[source,java]\n----\n    /**\n     * 是否是第一次投掷\n     */\n    private boolean firstThrowInFrame = true;\n    /**\n     * 当前序列\n     */\n    private int ball;\n    /**\n     * 第一次投掷\n     */\n    private int firstThrow;\n    /**\n     * 第二次投掷\n     */\n    private int secondThrow;\n    /**\n     *  计算当前轮\n     */\n    private void adjustCurrentFrame(int pins) {\n        if (firstThrowInFrame){\n            if (pins == 10){\n                // 全中\n                itsCurrentFrame++;\n            } else {\n                firstThrowInFrame = false;\n            }\n        } else {\n            firstThrowInFrame = true;\n            itsCurrentFrame++;\n        }\n        itsCurrentFrame = Math.min(11, itsCurrentFrame);\n    }\n\n    /**\n     * 指定轮的总分\n     *\n     * @param theFrame 轮\n     * @return 总分\n     */\n    public int scoreForFrame(int theFrame) {\n        // 到指定轮数的总分\n        int score = 0;\n        ball = 0;\n        for (int currentFrame = 0; currentFrame < theFrame; currentFrame ++) {\n            firstThrow = itsThrows[ball++];\n            if (firstThrow == 10){\n                // 全中\n                score += 10 + itsThrows[ball] + itsThrows[ball + 1];\n            } else {\n                score += handleSecondThrow();\n            }\n        }\n        return score;\n    }\n\n    /**\n     * 第二次投掷的结果\n     *\n     * @return 分数\n     */\n    private int handleSecondThrow(){\n        int score = 0;\n        secondThrow = itsThrows[ball++];\n        // 这一轮的分数\n        int frameScore = firstThrow + secondThrow;\n        // 是否补选\n        if (frameScore == 10){\n            // 补选的情况需要加上下一轮的第一次分数\n            score += frameScore + itsThrows[ball];\n        } else {\n            score += frameScore;\n        }\n        return score;\n    }\n----\n\n这似乎好多了，**修改完成后，一定要记得运行所有的测试用例保证通过。**但是对于\n`scoreForFrame` 似乎不是那么易理解，C 提出的伪代码\n\n....\nif strike\n    score += 10 + nextTwoBalls();\nelse if spare\n    score += 10 + nextBall();\nelse\n    score += twoBallInFrame();\n....\n\nS 看到很高兴，因为这不就是保龄球的积分规则吗？我们改改看，并且去掉\n`firstThrow` 和 `secondThrow` 两个成员变量，并用恰当的函数来替代他。\n\n[source,java]\n----\n/**\n * 指定轮的总分\n *\n * @param theFrame 轮\n * @return 总分\n */\npublic int scoreForFrame(int theFrame) {\n    // 到指定轮数的总分\n    int score = 0;\n    ball = 0;\n    for (int currentFrame = 0; currentFrame < theFrame; currentFrame ++) {\n        if (strike()){\n            ball ++;\n            // 全中\n            score += 10 + nextTwoBalls();\n        } else {\n            score += handleSecondThrow();\n        }\n    }\n    return score;\n}\n\n/**\n * 第二次投掷的结果\n *\n * @return 分数\n */\nprivate int handleSecondThrow(){\n    int score = 0;\n    // 是否补中\n    if (spare()){\n        // 补中的情况需要加上下一轮的第一次分数\n        ball += 2;\n        score += 10 + nextBall();\n    } else {\n        score += twoBallsInFrame();\n        ball += 2;\n    }\n    return score;\n}\n\n/**\n * 2. 添加方法：是否全中\n *\n * @return 结果\n */\nprivate boolean strike() {\n    return itsThrows[ball] == 10;\n}\n\n/**\n * 3. 添加方法：下面两次投掷的结果之和\n *\n * @return 和\n */\nprivate int nextTwoBalls(){\n    return itsThrows[ball] + itsThrows[ball + 1];\n}\n\n/**\n * 4. 添加方法，是否补中\n *\n * @return 补中\n */\nprivate boolean spare() {\n    return (itsThrows[ball] + itsThrows[ball + 1]) == 10;\n}\n\n/**\n * 5. 添加方法：下一次投掷分数\n *\n * @return 分数\n */\nprivate int nextBall() {\n    return itsThrows[ball];\n}\n\n/**\n * 6. 一轮中的两个投掷结果之和\n *\n * @return 和\n */\nprivate int twoBallsInFrame() {\n    return itsThrows[ball] + itsThrows[ball + 1];\n}\n----\n\n运行测试用例全部通过，并且不会再有 `firstThrow` 和 `secondThrow` 和\n`frameScore` 三个成员变量了。接下来我们看看，C 提出唯一耦合的就是 `ball`\n这个变量了，现在都是独立处理三种情况的，那我们合并处理看看\n\n[source,java]\n----\n/**\n * 指定轮的总分\n *\n * @param theFrame 轮\n * @return 总分\n */\npublic int scoreForFrame(int theFrame) {\n    // 到指定轮数的总分\n    int score = 0;\n    ball = 0;\n    for (int currentFrame = 0; currentFrame < theFrame; currentFrame ++) {\n        if (strike()){\n            // 全中\n            score += 10 + nextTwoBalls();\n            ball ++;\n        } else if (spare()){\n            // 补中\n            score += 10 + nextBallForSpare();\n            ball += 2;\n        } else {\n            score += handleSecondThrow();\n        }\n    }\n    return score;\n}\n/**\n * 一轮中的两个投掷结果之和\n *\n * @return 和\n */\nprivate int twoBallsInFrame() {\n    return itsThrows[ball] + itsThrows[ball + 1];\n}\n----\n\n这样就很帮棒了，一眼就看出来规则。不过 C 和 S\n又吵起来了。有一句话非常好：\n\n____\n自上而下，测试优先设计，坦白地说，我不知道这是不是一个好的规则，只是这次，他帮了我们。所以下次，我会再次尝试看看他会发生什么。\n____\n\n他们最后商定将他们分成几个对象，一些小规模的更改。\n\n[source,java]\n----\npublic class Game {\n    /**\n     * 当前第几轮\n     */\n    private int itsCurrentFrame = 1;\n    /**\n     * 分数\n     */\n    private int itsScore = 0;\n    /**\n     * 得分运动员\n     */\n    private Scorer itsScorer = new Scorer();\n    /**\n     * 是否是第一次投掷\n     */\n    private boolean firstThrowInFrame = true;\n    /**\n     * 计算总分\n     *\n     * @return 总分\n     */\n    public int score(){\n        return itsScorer.scoreForFrame(getCurrentFrame() - 1);\n    }\n\n    /**\n     * 投掷\n     *\n     * @param pins 得分\n     */\n    public void add(int pins) {\n        // 存放到 投掷序列 中\n        itsScorer.addThrow(pins);\n        itsScore += pins;\n        adjustCurrentFrame(pins);\n    }\n\n    /**\n     *  计算当前轮\n     */\n    private void adjustCurrentFrame(int pins) {\n        if (firstThrowInFrame){\n            if (pins == 10){\n                // 全中\n                itsCurrentFrame++;\n            } else {\n                firstThrowInFrame = false;\n            }\n        } else {\n            firstThrowInFrame = true;\n            itsCurrentFrame++;\n        }\n        itsCurrentFrame = Math.min(11, itsCurrentFrame);\n    }\n\n\n\n    /**\n     * 当前第几轮\n     *\n     * @return 当前轮\n     */\n    public int getCurrentFrame() {\n        return itsCurrentFrame;\n    }\n\n    public int scoreForFrame(int theFrame) {\n        return itsScorer.scoreForFrame(theFrame);\n    }\n}\n----\n\n[source,java]\n----\npublic class Scorer {\n    /**\n     * 当前序列\n     */\n    private int ball;\n    /**\n     * 投掷序列，最大可能的投掷次数是 21 次\n     */\n    private int[] itsThrows = new int[21];\n    /**\n     * 当前第几轮投掷\n     */\n    private int itsCurrentThrow = 0;\n\n    public void addThrow(int pins) {\n        itsThrows[itsCurrentThrow++] = pins;\n    }\n    /**\n     * 指定轮的总分\n     *\n     * @param theFrame 轮\n     * @return 总分\n     */\n    public int scoreForFrame(int theFrame) {\n        // 到指定轮数的总分\n        int score = 0;\n        ball = 0;\n        for (int currentFrame = 0; currentFrame < theFrame; currentFrame ++) {\n            if (strike()){\n                // 全中\n                score += 10 + nextTwoBalls();\n                ball ++;\n            } else if (spare()){\n                // 补中\n                score += 10 + nextBallForSpare();\n                ball += 2;\n            } else {\n                score += handleSecondThrow();\n            }\n        }\n        return score;\n    }\n\n    /**\n     * 第二次投掷的结果\n     *\n     * @return 分数\n     */\n    private int handleSecondThrow(){\n        int score = 0;\n        // 是否补中\n        if (spare()){\n            // 补中的情况需要加上下一轮的第一次分数\n            ball += 2;\n            score += 10 + nextBallForSpare();\n        } else {\n            score += twoBallsInFrame();\n            ball += 2;\n        }\n        return score;\n    }\n\n    /**\n     * 2. 添加方法：是否全中\n     *\n     * @return 结果\n     */\n    private boolean strike() {\n        return itsThrows[ball] == 10;\n    }\n\n    /**\n     * 3. 添加方法：下面两次投掷的结果之和\n     *\n     * @return 和\n     */\n    private int nextTwoBalls(){\n        return itsThrows[ball + 1] + itsThrows[ball + 2];\n    }\n\n    /**\n     * 4. 添加方法，是否补中\n     *\n     * @return 补中\n     */\n    private boolean spare() {\n        return (itsThrows[ball] + itsThrows[ball + 1]) == 10;\n    }\n\n    /**\n     * 5. 添加方法：下一次投掷分数\n     *\n     * @return 分数\n     */\n    private int nextBallForSpare() {\n        return itsThrows[ball + 2];\n    }\n\n    /**\n     * 6. 一轮中的两个投掷结果之和\n     *\n     * @return 和\n     */\n    private int twoBallsInFrame() {\n        return itsThrows[ball] + itsThrows[ball + 1];\n    }\n}\n----\n\nS 很高兴，因为现在 `Game` 只知晓 `Frame`，`Scorer`\n只计算得分，完全符合单一职责原则。\n\nC 发现多余的变量 `itsScore`\n\n[source,java]\n----\npublic void add(int pins) {\n    itsScorer.addThrow(pins);\n    adjustCurrentFrame(pins);\n}\n----\n\n现在应该来看看 `adjustCurrentFrame` 啦\n\n[source,java]\n----\n/**\n *  计算当前轮\n */\nprivate void adjustCurrentFrame(int pins) {\n    if (firstThrowInFrame){\n        if (pins == 10){\n            // 全中\n            itsCurrentFrame++;\n        } else {\n            firstThrowInFrame = false;\n        }\n    } else {\n        firstThrowInFrame = true;\n        itsCurrentFrame++;\n    }\n    itsCurrentFrame = Math.min(11, itsCurrentFrame);\n}\n----\n\nC 非常不喜欢那个 十一 ，但是却没有办法。。。\n\n[source,java]\n----\nprivate void adjustCurrentFrame(int pins) {\n    if (firstThrowInFrame){\n        if (pins == 10){\n            advanceFrame();\n        } else {\n            firstThrowInFrame = false;\n        }\n    } else {\n        firstThrowInFrame = true;\n        advanceFrame();\n    }\n}\n\nprivate void advanceFrame() {\n    itsCurrentFrame = Math.min(11, itsCurrentFrame + 1);\n}\n----\n\n接下来我们把关于全中的情况判断取出来作为一个独立的方法。\n\n[source,java]\n----\nprivate void adjustCurrentFrame(int pins) {\n    if (firstThrowInFrame){\n        if(!adjustFrameForStrike(pins)){\n            firstThrowInFrame = false;\n        }\n    } else {\n        firstThrowInFrame = true;\n        advanceFrame();\n    }\n}\n\nprivate boolean adjustFrameForStrike(int pins) {\n    if (pins == 10){\n        advanceFrame();\n        return true;\n    }\n    return false;\n}\n----\n\n接下来，去掉 `getCurrentFrame` 方法，也去掉调用的地方，就可以把 11 改成\n10 啦。\n\n[source,java]\n----\n/**\n * 计算总分\n *\n * @return 总分\n */\npublic int score(){\nreturn itsScorer.scoreForFrame(itsCurrentFrame);\n}\n\nprivate void advanceFrame() {\n    itsCurrentFrame = Math.min(10, itsCurrentFrame + 1);\n}\n----\n\n`adjustCurrentFrame` 似乎有点表意不明\n\n[source,java]\n----\nprivate void adjustCurrentFrame(int pins) {\n    if (!firstThrowInFrame || pins == 10){\n        advanceFrame();\n    } else {\n        firstThrowInFrame = false;\n    }\n}\n----\n\n让他表意更加明确\n\n[source,java]\n----\nprivate void adjustCurrentFrame(int pins) {\n    if (lastBallInFrame(pins)){\n        advanceFrame();\n    } else {\n        firstThrowInFrame = false;\n    }\n}\n\nprivate boolean lastBallInFrame(int pins) {\n    return strike(pins) || !firstThrowInFrame;\n}\n\nprivate boolean strike(int pins) {\n    return firstThrowInFrame && pins == 10;\n}\n----\n\nC 和 S 很高兴，因为终于完成了。我也很高兴，因为终于看懂了 T\nT，所以实践真的很重要。完整的测试（添加显示的名称）\nimage:https://resources.echocow.cn/file/2019/3/9/QQ%E6%88%AA%E5%9B%BE20190309224835.png[image]\n\n== 总结\n\n理论结合实践，是学习的不变真理。上周学习的时候不过是一些理论的东西，这周参与实践了一番，不得不说的是，敏捷开发真的挺累，但是效率与结果都让人满意，不过这不就是他诱人的地方吗？其中比较出名的\nXP\n编程，对于结对的思想也有了概念，但是有时候在想，倘若两个人的思想、基础都存在太大差异，对于弱势方自然收益匪浅，但是对于强势方就是有点累了。不过相比起一个团队的和谐程度，以及进步水平都是具有十分快速的提高的。就像敏捷开发里面的思想：*你大可以选择你完全没有接触过和你不懂的专业领域，因为你相信在那里会有人和你一起结对，你可以在这个团队中快速的进步，这就是敏捷开发，一个自组织团队应该有的。*\n\n在这次实践中，从一开始两个人的互相思考，再到各自的思想结合，C\n总能发现一些小细节，S\n总能提出一些很好的解决问题的办法，他们两个能够想到覆盖后面可能出现的情况，从开始设计，到编程，两个人都进行了互补。而我也从这个过程彻底明白了**测试驱动开发**，在我总结下来三个非常重要的步骤\n\n[arabic]\n. 编写测试用例\n. 编译通过\n. 测试通过\n\n并且，他们对用户素材非常清楚，在最后的重构中，一直不断往用户素材靠拢，例如，他们一直记得保龄球的三种情况，随后重构出来的几个方法的语句是完全和保龄球的规则是对应的。并且每一个语句都能够见名知意，即使有些变量封装成了方法，但是也是一眼就知道什么意思了。他们两总能在彼此看不到的地方提出新的建议，结对莫过于此，忽然感觉，自己一个人学了那么久，变得了自私了很多，这是可悲的，有时候一个人久了，就不太想和别人一起了，以前学习的时候找过别人，但都没有人陪我走下去，最后剩下的也只有自己。这可能是我非常喜欢\nXP\n思想结对编程的原因之一吧，因为自己十分羡慕这么一份团队。所以也慢慢反省这两年来的大学生活，在余下的大学生活里面也会慢慢改变自己。\n\n后面的章节，学习到了很多重构的细节，但是重构真的是一门学问，始终不太清楚重构到一种什么程度才算完美，可能就是不断地不断地让代码更加易读更加友好，这或许就是重构的意义。重构最后思考来或许可以从以下几点入手：\n\n[arabic]\n. 代码易读性，能够见名知意。\n. 尽量消除成员变量，因为永远不知道多少个地方进行修改了，能够选择函数最好。\n. 一个函数最好负责已经事情，不要让他负责过多的事情。\n. 多对条件语句的条件进行封装，能够增加代码的易读性。\n. 尽量遵循一些必要的原则，例如 开放封闭原则、单一职责原则等。\n. 对于耦合的变量，尽量消除。\n. 每一次重构，务必要保证所有已有的测试用例通过，才算成功一半。\n. 有意义的重构，才算成功的另一半。\n\n而作者在结论最后一章提到了几个很重要的点。\n\n____\n[arabic]\n. 面向对象不是必须的，某些时候，敏捷开发也提倡简单。\n. 图示有时是不需要的，在创建了他们而没有验证他们的代码就打算遵循他们时，图示就是无意的。\n. 有时，最好的设计是在你首先编写测试，一小步一小步前进时逐渐形成的。\n____\n\n下一章开始敏捷设计，期待到来。晚安各位～\n\n","fields":{"slug":"/articles/2019/03/09/1552119273889.html","birthTime":"2019-03-09T08:14:34.161Z","modifiedTime":"2019-03-09","year":2019},"document":{"title":"[阅读] 敏捷软件开发 —— 敏捷开发（二）"}},{"content":"= solo 独立部署和 Tomcat 模式自动更新\n:page-description: solo 独立部署和 Tomcat 模式自动更新\n:page-category: 归档\n:page-image: https://img.hacpai.com/bing/20180813.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2019/03/12/1552380944073.html\n:page-created: 1552380944230\n:page-modified: 1560074450505\n:toc:\n\n最近很是焦虑啊，有时候想不清楚自己要干嘛。所以干脆懒得想，找点事做吧。自己搭建\n`solo` 也有三个多月了，从 `v2.8.0` 一直到现在的\n`v3.2.0`，一直很喜欢这种社区与博客的交互方式。中间升级过很多版本，自己也有不下五次的升级经历了，修改了很多皮肤，但是头疼的就是更新问题，每次都要上服务器，所以有点难受。自己写了一个自动检测更新。自动更新的，当然是自用的，所以只支持\n`linux 系统`，可以支持 `独立部署` 和 `Tomcat` 部署，我的是 `centos`\n系统。\n\n====\ngithub 地址： https://github.com/lizhongyue248/solo-auto[solo-auto]\n\n配置在线生成： https://lizhongyue248.github.io/solo-auto-ui/[solo-auto-ui]\n\nUI 地址： https://github.com/lizhongyue248/solo-auto-ui[github]\n====\n\nhttps://vertx.io[image:https://img.shields.io/badge/vert.x-3.6.3-purple.svg[image]]\n\n== 简述\n\nsolo 博客独立部署方式自动检测更新。\n\n功能：自动检测版本，自动下载更新，自动解压，自动复制配置文件以及其他的文件。\n\n*目前仅支持 linux 版本。*\n\n== 在这之前\n\n* 仅支持 `linux` 系统下的独立部署、`tomcat` 部署。\n* 建议您先备份数据库以及配置文件，虽然不对数据库进行任何操作，但是定时备份是好习惯。\n* 为避免不必要的错误，请务必使用 `root` 用户运行。\n* 独立部署仅支持系统命令，不能使用别名定义的命令。\n* 独立部署请检查 `pkill -9 -f org.b3log.solo.Starter`\n命令是否能够杀死你的 `solo` 进程。\n\n== 使用\n\n获取最新版本\n\n* https://github.com/lizhongyue248/solo-auto/releases[github]\n* http://downloads.echocow.cn/solo/soloauto-1.2.0-SNAPSHOT-fat.jar[七牛云]\n\n== 使用记录\n\n* 2019-3-26 早 九点四十六，`centos + 独立部署`，自动升级至 v3.4.0\n版本成功\n** [line-through]*警告：DNS\n解析出现一些小问题，不影响使用，但是可以改进。*\n** 解决办法：不使用 `vertx` 自带的 dns 解析，使用本地 dns 解析\n** 思路：每次更新都要上去修改 banner 图片的 url\n** 解决办法：直接配置 `solo-auto`\n移动复制功能覆盖皮肤下的图片就好啦=-=好笨还去改 css\n\nimage::https://resources.echocow.cn/file/2019/3/24/201903261159171111111.png[v3.4.0]\n\n* 2019-3-18 晚 十二点，`centos + 独立部署`，自动升级至 v3.3.0 版本成功\n** [line-through]*已知问题：点对点会由于下载比较慢的问题将错误信息的写入日志*\n** 解决办法：完全丢弃超时响应\n** [line-through]*已知问题：现在 favicon 可以自由配置*\n** 解决办法：所以应该删除默认复制的两个文件\n\nimage::https://resources.echocow.cn/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190318085800.png[v3.3.0]\n\n== 更新记录\n\n=== 2019-3-18 v1.2.0-SNAPSHOT\n\n* 删除默认复制的 `favicon` 两个文件，见\nhttps://github.com/b3log/solo/issues/12706?utm_source=hacpai.com[issue]\n* 默认检测时间由 `6` 小时变为 `1` 小时\n* 默认版本修改为 `v3.3.0`\n* 延长 `EventBus` 超时等待时间\n\n____\n*注意：这可能是 `v3` 版本最后一次更新 `solo-auto`，因为作为一个辅助\n`solo` 的存在，不应该让他像 `solo`\n一样频繁更新。并且现在已有的功能已经适用大多情况，所以以后只要 `solo`\n不进行大版本的更新或者 `solo-auto` 出现重大 `bug`，将不再更新此项目。*\n____\n\n=== 2019-3-13 v1.1.0-SNAPSHOT\n\n* 添加 `tomcat` 部署方式自动检测更新\n* 现 `homeDir` 末尾可以不添加文件分隔符 `/`\n* 现 `startCommand` 开头可以不添加英文分号 `;`\n* 添加 `debug` 参数开启运行时的文件路径获取详情\n\n=== 2019-3-12 v1.0.0-SNAPSHOT\n\n* 独立模式部署\n\n== 配置\n\n在线配置生成：https://lizhongyue248.github.io/solo-auto-ui/[solo-auto-ui]\n\nimage:https://resources.echocow.cn/solo/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190609170931.png[image]\n\n____\n注意，你的配置将会完全覆盖默认配置！配置文件为 `json` 格式\n____\n\n[width=\"100%\",cols=\"25%,25%,25%,25%\",options=\"header\",]\n|===\n|属性名 |类型 |默认值 |描述\n|latestUrl |String\n|https://api.github.com/repos/b3log/solo/releases/latest |最新版本 solo\n的 github restful 接口地址\n\n|homeDir |String |/root/ |解压后的文件夹路径，结尾必须有文件分隔符\n`/`，当前版本以及新版本都会存放在此目录\n\n|deploy |String |solo |部署方式，可选 `tomcat`，其他值无效\n\n|tomcatDir |String |solo |`tomcat` 部署在 `webapps` 目录下的 `solo`\n的文件名称\n\n|interval |Number |6 |几小时检测一次版本更新\n\n|version |String |v3.3.0 |当前已经部署的版本号，格式必须与 github 上相同\n\n|timeOut |Number |30 |Event Bus 等待时间\n\n|otherFiles |Array |[``favicon.ico'', favicon.png\"]\n|其他的需要移动的文件名称\n\n|startCommand |Stirng\n|`;nohup java -cp WEB-INF/lib/*:WEB-INF/classes org.b3log.solo.Starter >/dev/null 2>&1 &`\n|启动命令，前面必须加英文符分号 `;`\n|===\n\n== 运行\n\n____\n请注意：建议以 root 身份运行，否则可能会出现权限问题无法执行命令的情况。\n____\n\n* 前台运行，假设配置文件与 `jar` 包位于同一目录且名称为 `solo-auto.json`\n\n`java -jar soloauto-1.0.0-SNAPSHOT-fat.jar -conf solo-auto.json`\n\n* 后台运行，假设配置文件与 `jar` 包位于同一目录且名称为 `solo-auto.json`\n\n`nohup java -jar soloauto-1.0.0-SNAPSHOT-fat.jar -conf solo-auto.json >/dev/null 2>&1 &`\n\n____\n建议，先前台运行，检查控制台输出中的配置文件是否有配置错误，确认无误且不报错后，再后台运行。\n____\n\n=== 独立部署注意事项\n\n[arabic]\n. 正在运行的 `solo` 的文件夹的目录名称必须类似为 `solo-v3.1.0` 形式。\n. 建议以 `root` 方式运行。\n\n=== tomcat 部署注意事项\n\n[arabic]\n. 请注意填写以下属性\n\n[cols=\",\",options=\"header\",]\n|===\n|属性 |注意\n|`homeDir` |`tomcat` 的 `webapps` 目录\n|`deploy` |`tomcat`\n|`tomcatDir` |`tomcat` 的 `webapps` 下的部署 `solo` 的文件夹名称\n|===\n\n== 其它\n\nQ: 为什么会写这个？\n\nA: 从 `V2.8.0` 开始用 `solo`，至今到了\n`V3.2.0`，以前除了部署应用的时候上一下服务器，其他时候都用不上，`hexo`\n这些博客基本很少更新。现在每次更新都要上去重复一边操作，实在太麻烦了。但是又特别喜欢\n`solo` 这样活跃的博客与社区，所以遇到问题当然是想自己解决下问题。\n\nQ: 为什么不用 `docker`？\n\nA: 服务器资源有限，除了 `solo` 还运行者其他的应用，运行 `docker`\n就会有一些资源被占用，并且想自己 `DIY`\n部分主题比较麻烦，每次都要进服务器，再进容器里面改，为了运行 `solo`\n直接上 `docker` 觉得没必要。如果后面还有应用使用 `docker` 会换，或者 D\n大说的会重写 `Docker` 镜像构建的时候可能会换。\n\nQ: 为什么不用 `tomcat`？\n\nA: `tomcat` 跑着其它应用，没做负载均衡，并且担心访问速度，所以直接用\n`独立容器 + nginx` 部署了。v1.1.0 版本已经可以使用tomcat\n\n== 示例\n\n=== 独立部署\n\n* 运行在指定端口：请修改 `startCommand`, *前面一定要加分号 `;`*\n\n[source,json]\n----\n{\n  \"startCommand\":\";nohup java -cp 'WEB-INF/lib/*:WEB-INF/classes' org.b3log.solo.Starter -lp 8765 >/dev/null 2>&1 &\"\n}\n----\n\n* 如果你需要复制其它文件，可以采用这个配置：请修改 `otherFiles`\n\n[source,json]\n----\n{\n  \"homeDir\": \"/root/\",\n  \"version\": \"v3.3.0\",\n  \"otherFiles\": [\n    \"favicon.ico\",\n    \"favicon.png\",\n    \"background.jpg\"\n  ]\n}\n----\n\n解释如下:\n\n[width=\"100%\",cols=\"40%,30%,30%\",options=\"header\",]\n|===\n|属性名　 |值 |　解释\n|homeDir |/home/echocow/\n|解压后的文件夹路径，结尾必须有文件分隔符，当前版本以及新版本都会存放在此目录\n\n|version |v3.3.0 |当前已经启动且部署好的 solo 版本\n\n|otherFiles |[``favicon.ico'', ``favicon.png'', ``background.jpg'']\n|其它需要复制的文件，一旦填写，就会覆盖默认的，所以这里要加上默认的，然后多加了\n`background.jpg`\n|===\n\n* 如果你不需要复制其它文件，可以采用这个配置\n\n[source,json]\n----\n{\n  \"homeDir\": \"/home/echocow\",\n  \"version\": \"v3.2.0\"\n}\n----\n\n解释如下:\n\n[cols=\",,\",options=\"header\",]\n|===\n|属性名　 |值 |　解释\n|homeDir |/home/echocow/\n|解压后的文件夹路径，结尾必须有文件分隔符，当前版本以及新版本都会存放在此目录，默认\n/root/\n\n|version |v3.2.0 |当前已经启动且部署好的 solo 版本\n|===\n\n=== `Tomcat` 部署\n\n* 假设我现在已经部署好了 `solo`，并且路径为\n`/home/echo/Other/apache-tomcat-9.0.16/webapps/solo`，配置文件如下：\n\n[source,json]\n----\n{\n  \"homeDir\": \"/home/echo/Other/apache-tomcat-9.0.16/webapps/\",\n  \"deploy\": \"tomcat\",\n  \"tomcatDir\": \"solo\",\n  \"version\": \"v3.2.0\",\n  \"otherFiles\": [\n    \"favicon.ico\",\n    \"favicon.png\",\n    \"background.jpg\"\n  ]\n}\n----\n\n其中 `deploy` 和 `tomcatDir` 必填\n\n== 说明\n\n使用 vertx 事件驱动，使用 `Event Bus` 点对点消息模式，`MainVerticle`\n获取默认配置，再获取用户配置以覆盖默认配置。然后分别部署两个\n`Verticle`。\n\n* `WebClientVerticle` 定时检测版本\n* `FileVerticle` 处理文件下载、移动操作\n\n'''''\n\n=== 独立部署\n\n[arabic, start=0]\n. `WebClientVerticle`\n检测当前最新版是否与配置中的版本匹配，如果不匹配，携带请求的部分信息通知\n`FileVerticle`。\n. `FileVerticle`\n使用类名注册一个处理器以接受请求，收到通知以后，获取最新版本。\n. 下载最新版本的 `war` 包，解压，然后移动用户自定义的文件（配置文件中\n`otherFiles`）。\n. 移动 `solo`\n配置文件：`local.properties`，`latke.properties`，`solo.properties`.\n. 复制完毕后，使用 `pkill -9 -f org.b3log.solo.Starter` 杀死以前的\n`solo` 进程，\n. 使用\n`cd 解压后的路径;nohup java -cp WEB-INF/lib/*:WEB-INF/classes org.b3log.solo.Starter >/dev/null 2>&1 &`\n命令启动\n`solo`，后面的启动命令用户可以自定义，*请注意：自定义启动命令前请务必加上分号！*\n. `FileVerticle` 执行完毕，回复 `WebClientVerticle`\n，`WebClientVerticle` 收到回复日志记录。\n\n=== Tomcat 部署\n\n这个过程不会重启 tomcat。\n\n* 0-3 同上\n* 修改原来版本的 `solo` 的文件夹名称为 `tomcatDir配置的名称+当前时间`\n* 修改新下载的 `solo` 的文件夹名称为 `tomcatDir` 所配置的参数\n* `FileVerticle` 执行完毕，回复 `WebClientVerticle`\n，`WebClientVerticle` 收到回复日志记录。\n\n== 我的配置\n\n2019 年 3 月 26 日\n\n* `solo-auto.json`\n\n[source,json]\n----\n{\n    \"startCommand\":\";nohup java -cp 'WEB-INF/lib/*:WEB-INF/classes' org.b3log.solo.Starter -lp 8765 >/root/solo-auto/soloInfo.log 2>&1 &\",\n    \"version\":\"v3.4.0\",\n    \"otherFiles\":[\n        \"skins/Finding/images/header-bg.jpg\"\n    ]\n}\n----\n\n* 启动命令\n\n[source,bash]\n....\nnohup java -jar soloauto-1.2.0-SNAPSHOT-fat.jar -conf solo-auto.json >/dev/null 2>&1 &\n....\n\n== 未来\n\n[arabic, start=0]\n. 目前没有写 `windows` 的打算。\n. 打算加入邮件或者短信通知，以能够更好的感知博客更新变化。\n. 考虑是否加入 `web` 页面，但是觉得没必要。\n. 想过做成 `solo`\n插件，但是文档太少，并且感觉局限性比较大且自己水平有限，所以放弃了。\n\n== 构建\n\n测试:\n\n[source,bash]\n....\n./mvnw clean test\n....\n\n打包\n\n[source,bash]\n....\n./mvnw clean package\n....\n\n运行\n\n[source,bash]\n....\n./mvnw clean exec:java\n....\n\n== 结语\n\n也不知道能不能帮助到您，不过还是希望这个小东西能够为您带来方便，如果有问题请在\nhttps://github.com/lizhongyue248/solo-auto/issues[github]\n上提出；如果对您有帮助，欢迎给个 star 哈。\n\n","fields":{"slug":"/articles/2019/03/12/1552380944073.html","birthTime":"2019-03-12T08:55:44.230Z","modifiedTime":"2019-06-09","year":2019},"document":{"title":"solo 独立部署和 Tomcat 模式自动更新"}},{"content":"= 高效 manjaro i3 —— 你值得拥有\n:page-description: 高效 manjaro i3 —— 你值得拥有\n:page-category: linux\n:page-image: https://img.hacpai.com/bing/20171225.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2019/03/15/1552649977490.html\n:page-created: 1552649977661\n:page-modified: 1561429624069\n:toc:\n\n2019 年 3 月 11 日， https://www.deepin.org/2019/03/11/%E6%B7%B1%E5%BA%A6%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0%EF%BC%882019-03-11%EF%BC%89/[深度系统更新];3\n月 13 日，小雨，升级 deepin，显卡驱动崩溃，开机卡屏 LOGO\n界面，多种方式解决，无效。告别 deepin。晚上很难受，觉得用了那么久的\nlinux，它给我的带来的是烦恼。回想一下自己使用的方式，似乎和 windows\n一样的使用方式，依旧是图形界面，点击，运行，点击运行。感觉到的好处也就莫过于不用担心太多开发环境的问题。但是这真的就是\nlinux 吗？自己很迷茫。然后在犹豫是否继续使用 deepin 的时候，尝试了一下\nubuntu，可惜自己启动盘制作出问题，没有成功，而且自己也对 ubuntu\n有这莫名的排斥情感。\n\n然后逛回到了 arch，找到了自己的第一个实体机安装的\nhttps://www.manjaro.org/[manjaro] 。19 年的官网，比起来 18\n年的，变化了很多。不仅漂亮了很多，也有了更加完善的文档说明。曾经的\nhttps://www.manjaro.org/download/[download]\n也从四五个到了现在的十多个版本，各有所长。也就是在这里，我找到了真正的高效的工具\nhttps://www.manjaro.org/download/i3/[i3] 和\nhttps://www.manjaro.org/download/awesome/[awesome]\n。当了解了他们之后，自己觉得这才是真正的 linux\n啊，能够提高我们开发者的工作效率，能够让我们完全脱离鼠标的 wm\n真的是太让人着迷了。与那些华丽的 linux\n不同，他们能够用u最少的资源做最效率的工作，我果断的选择了他们。然而却也遇到了不少问题，记录一下网上很难搜到的一些困难点。\n\n== i3 还是 awesome\n\n说实话我一开始选的是\nawesome，可是我做好启动盘后，在安装界面选择中文，他的中文完全是乱码。不得已我只有换了\ni3，两个都是 vm 中的佼佼者，孰优孰劣，各有所好吧。先上截图\n\nimage::https://resources.echocow.cn/file/2019/3/16/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_20190316141254.png[manjaroi3]\n\n== 安装\n\n有了 manjaro kde\n的安装经验，一路畅通无阻，遇到的问题莫过于就是显卡问题，见\nhttps://echocow.cn/articles/2018/09/16/1546344571882.html#b3_solo_h3_6[manjaro\n笔记 显卡问题]，这样就解决了以下问题：\n\n[arabic]\n. 安装时启动问题\n. 安装完成后启动登录卡死的问题\n. 关机的时候完全卡死的问题\n\n== 右上角日期中文乱码\n\n在安装和安装好以后，右上角的日期 某月 星期几\n都是框框乱码。解决办法如下：\n\n[arabic]\n. 找到 `/usr/share/conky/conky_maia`\n. 使用 `vim` 命令 `：%s/Bitstream Vera/anti/` 统一修改把\n`Bitstream Vera` 修改为 `anti`\n\n然后就方块就变成中文了。\n\n== 浮动问题\n\n这个就是因为要使用 `yakuake`\n雷神终端，但是第一次打开的时候挺好的，第二次他就平铺了。但是我希望他是浮动在上方的，所以要将它修改为浮动的。\n\n[arabic]\n. `vim ~/.i3/config`\n. `for_window [class=\"yakuake\"] floating enable`\n\n这样她就浮动了。\n\n== 科学上网\n\n=== `shadowsocks` 非图形界面\n\n[arabic]\n. `yaourt -S shadowsocks` 安装\n. 修改配置文件 `/etc/shadowsocks/config.json`\n\n[source,json]\n----\n{\n    \"server\":\"remote-shadowsocks-server-ip-addr\",\n    \"server_port\":443,\n    \"local_address\":\"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"your-passwd\",\n    \"timeout\":300,\n    \"method\":\"chacha20-ietf\",\n    \"fast_open\":false,\n    \"workers\":1\n}\n----\n\n[cols=\",\",options=\"header\",]\n|===\n|Name |Explanation\n|server |服务端监听地址(IPv4或IPv6)\n\n|server_port |服务端端口，一般为`443`\n\n|local_address |本地监听地址，缺省为`127.0.0.1`可用-b参数设置\n\n|local_port |本地监听端口，一般为`1080`\n\n|password |用以加密的密匙\n\n|timeout |超时时间（秒）\n\n|method\n|参阅 https://github.com/shadowsocks/shadowsocks/wiki/Encryption[加密]\n\n|mode |设置为tcp或udp或tcp_and_udp\n\n|fast_open\n|是否启用 https://github.com/clowwindy/shadowsocks/wiki/TCP-Fast-Open[TCP-Fast-Open]\n\n|wokers |worker数量，如果不理解含义请不要改\n|===\n\n[arabic, start=3]\n. `ss-local -c /etc/shadowsocks/config.json`\n运行。或可尝试手动运行：`ss-local -s _服务器地址_ -p _服务器端口_ -l _本地端端口_ -k _密码_ -m _加密方法_`。配合nohup和&可以使之后台运行，关闭终端也不影响：`#nohup ss-local -s _服务器地址_ -p _服务器端口_ -l _本地端端口_ -k _密码_ -m _加密方法_ &`增加`-v`参数获取详细log信息\n. 浏览器通过 `SwitchyOmega` 可以科学上网。\n\n=== `shadowsocks-qt5` 图形界面\n\n[arabic]\n. `yaourt -S shadowsocks-qt5`\n. 运行 `ss-qt5`\n. 图形界面可以直接扫码导入，很方便，改下本地端口即可。\n\n=== `proxychains`\n\n[arabic]\n. `yaourt -S proxychains`\n. `vim /etc/proxychains.conf`\n. 末尾添加配置，例如 `socks5 127.0.0.1 1080`\n\n遇到一个问题，我希望用 `chrome` 登录我的 `google`\n帐号同步我的书签、插件、应用，但是 `chrome` 不能离线安装 `SwitchyOmega`\n的文件，很奇怪。然后发现 `chrome` 在 `arch` 上面没有 `chromium`\n支持好，https://chromium.googlesource.com/chromium/src/+/master/docs/linux_chromium_packages.md[官网（需要科学上网）]推荐的i也是用\n`chromium`，所以我换了，但是我希望科学上网在应用商店下载 `SwitchyOmega`\n，所以需要用 `proxychains` 启动 `chromium`，但是报错如下：\n\n\n[source,bash]\n....\n[proxychains] config file found: /etc/proxychains.conf\n[proxychains] preloading /usr/lib/libproxychains4.so\n[proxychains] DLL init: proxychains-ng 4.13\n[proxychains] DLL init: proxychains-ng 4.13\n[proxychains] DLL init: proxychains-ng 4.13\n[1]    6322 trace trap (core dumped)  proxychains chromium\n....\n\n找了一段时间在 https://github.com/rofl0r/proxychains-ng/issues/45[github] 找到答案。\n\n创建一个 shell 脚本如下\n\n[source,bash]\n....\n#!/bin/bash\nfunction _start-with-proxy() {\n    export SOCKS_SERVER=127.0.0.1:1080\n        export SOCKS_VERSION=5\n        chromium %U --user-data-dir=\"/home/[USER]/.chromium profiles/[PROFILEDIR]\"\n}\n_start-with-proxy\n....\n\n然后 `chmod +x 文件名` 添加权限，使用 `./文件名`\n运行，即可完美运行并且可以科学上网，然后就可以下载 `SwitchyOmega`\n这些啦～\n\n=== 开机自启\n\n以守护进程形式运行\n\n`systemctl start shadowsocks@配置名称`，\n\n比如我的配置文件叫做 `ss .json` ，运行 `systemctl start shadowsocks@ss`\n即可开启\n\n运行 `systemctl enable shadowsocks@ss` 即可开机自启。\n\n== QQ / TIM\n\n这里使用 deepin wine qq/tim\n\n前提：*添加archlinuxcn源*。在 `/etc/pacman.conf` 里加入以下代码：\n\n[source,bash]\n....\n[archlinuxcn]\nSigLevel = Never\nServer =[http://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch](http://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch)\n....\n\n[arabic]\n. 修改了pacman.conf之后，执行`pacman -Sy`命令更新一下数据库。\n. *安装QQ或TIM的任意一种*。终端里运行`pacman -S deepin.com.qq.office` 或\n`pacman -S deepin.com.qq.im`\n. 切换到对应目录 `cd /opt/deepinwine/apps/Deepin-TIM` 或者\n`/opt/deepinwine/apps/Deepin-QQ`\n. 运行 `./run.sh`\n\n非常感谢\nhttps://github.com/wszqkzqk[wszqkzqk同学]，*QQ或TIM只能开一个、不能多开*：据称是deepin-wine防止资源占用过多而限制的，建议使用QQ/TIM自带的多帐号切换功能。\n\n=== 遇到问题\n\n==== 无法启动\n\n[source,bash]\n....\nX Error of failed request: BadWindow (invalid Window parameter)\nMajor opcode of failed request: 20 (X_GetProperty)\nResource id in failed request:\n0x0 Serial number of failed request:\n10 Current serial number in output stream: 10\n....\n\n解决方案\n\n[arabic]\n. `yaourt -S gnome-settings-daemon`\n. 然后运行 `/usr/lib/gsd-xsettings`，或者后台运行\n`nohup /usr/lib/gsd-xsettings > /dev/null 2>&1 &`\n. 切换到对应目录 `cd /opt/deepinwine/apps/Deepin-TIM` 或者\n`/opt/deepinwine/apps/Deepin-QQ`\n. 运行 `./run.sh`\n\n完美解决！参见 https://github.com/wszqkzqk/deepin-wine-ubuntu/issues/12#issuecomment-443656358[github]，然后可以将第二步添加到\n`i3` 的启动项即可。\n\n==== 中文问题\n\n系统语言非中文时，中文全显示成方块，需要在\n`/opt/deepinwine/tools/run.sh` 中将 WINE_CMD 那一行修改为 `WINE_CMD=\"LC_ALL=zh_CN.UTF-8 deepin-wine\"`\n\n== 定制主题\n\n[arabic]\n. 安装想要的主题，比如 `arc-gtk-theme` 和图标主题 `numix-icon-theme`\n. 使用 `$mod + d` 调出 `dmenu`，输入 `lxappearance` 打开配置工具\n. 自由配置即可主题即可\n\n=== 登录壁纸\n\n[arabic]\n. 把壁纸放在/usr/share/backgrounds/目录下（类似的非用户目录）\n. 使用命令打开配置 `lightdm-settings`\n. 选择背景图片即可\n\n=== 默认终端\n\n[arabic]\n. `vim ~/.i3/config`\n. 搜索 `+Return`，大概在 31 行\n. 修改为对应的终端，比如我用的 `konsole` 如下\n\n....\nbindsym $mod+Return exec konsole\n....\n\n=== `polybar`\n\n[arabic]\n. `yaourt -S polybar`\n. `install -Dm644 /usr/share/doc/polybar/config $HOME/.config/polybar/config`\n弄一份 `example` 的配置文件过来\n. 编辑启动文件 `vim ~/.config/polybar/launch.sh` 如下：\n\n[source,bash]\n----\n#!/usr/bin/env bash\n\n# Terminate already running bar instances\nkillall -q polybar\n\n# Wait until the processes have been shut down\nwhile pgrep -u $UID -x polybar >/dev/null; do sleep 1; done\n\n# Launch bar1 and bar2\n# polybar bar1 &\n# polybar bar2 &\npolybar example &\n\necho \"Bars launched...\"\n----\n\n[arabic, start=4]\n. `vim ~/.i3/config`\n. 搜索 `start_conky`,注释掉\n. 添加 `exec_always --no-startup-id ~/.config/polybar/launch.sh`\n替换原来系统的 `conky`\n. 注释掉 `i3bar_command i3bar`，添加\n`i3bar_command $HOME/.config/polybar/launch.sh`。\n. `$mod + shift + r` 重新加载 `i3`\n\n=== `rofi`\n\n[arabic]\n. 安装 `yaourt -S rofi`\n. 编辑 `vim .i3/config`\n. 注释掉有 `$mod+d` 的那一行，添加 `bindsym $mod+d exec rofi -show run`\n. `$mod+shift+r` 重新加载配置\n. `$mod+shift+d` 运行\n. 切换到 `cd ~/.config/rofi/`, 使用 `rofi -dump-Xresources > config`\n生成配置文件\n. `rofi-theme-selector` 选择你想要的主题即可\n\n== 推荐软件\n\n[arabic]\n. ydcv —— 翻译工具\n. ranger —— 命令行文本浏览\n. w3m —— 图片预览\n. deepin-screenshot —— deepin 良心截图工具\n. zsh —— 非常好用的 shell\n\n其他记起来再说，，，，\n\n== 结束语\n\n花了一段时间才配置好，才熟悉了\n`i3wm`，现在只是配置好一些基本的，还有一些开发工具够我折腾=-=不过在折腾的时候熟悉了，工作效率提升真的太爽了。现在笔记本去教室都不用带鼠标了，在摸索一下\n`idea` 这些工具的快捷键，真的太棒！壮哉我 manjaro，壮哉 arch！\n\n","fields":{"slug":"/articles/2019/03/15/1552649977490.html","birthTime":"2019-03-15T11:39:37.661Z","modifiedTime":"2019-06-25","year":2019},"document":{"title":"高效 manjaro i3 —— 你值得拥有"}},{"content":"= [阅读] 敏捷软件开发 —— 敏捷设计（一）\n:page-description: [阅读] 敏捷软件开发 —— 敏捷设计（一）\n:page-category: 阅读\n:page-image: https://img.hacpai.com/bing/20180322.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2019/03/16/1552732721283.html\n:page-created: 1552732721385\n:page-modified: 1552895207921\n:toc:\n\n敏捷的开发能够让我们开发出来的软件变得易用且优秀。如果敏捷性是以最小增量的方式构建软件，那么我们如何去设计软件呢？《敏捷软件开发》第二部分就是对敏捷设计的学习，与第一部分不同的是，他注重的更多是设计而不是代码的书写与实践，所以相比起来这章是对思想的一种锤炼。\n\n== 回顾\n\n上周真正的体验了一次 XP\n的实战，里面学习到了不少。但是总会有一个疑问，因为多次发现许多重构后提出来的私有方法都是一句话代码，都是\n`return`\n直接返回回去了，除了更易读以外似乎没有太多明显的好处了。而在这章开篇就提到了这个问题：\n\n____\n如果以最小增量的方式构建软件，难道不是打着重构的旗号，而实际上却导致了去多无用的代码碎片和返工吗？\n____\n\n所以也激起来了我的兴趣。\n\n== 开篇\n\n在开始，我们必须知道如何衡量一个软件设计的优劣，因为这样才能够更好的了解如何去评判一个软件。而后则是一写开发的原则，一些经历了时间沉淀下来的经验，能够让我们软件更加优雅的原则。\n\n== 什么是敏捷设计\n\n____\n在按照我的理解方式审查了软件开发的生命周期后。我得出一个结论：实际上满足工程设计标准的唯一软件文档，就是代码清单。\n____\n\n曾经自己以为的设计，应该是有一个设计图，对每一个类详细的标识出一些方法这些。但是书中的设计，则有很大不同：\n\n____\n软件项目的设计是一个抽象的概念，他和程序的概括形状、结构以及每一个模块、类和方法的详细形状和结构够管，可以使用许多不同的媒介uq描绘他，但是他最终体现为源代码。最后源代码就是设计。\n____\n\n的确，回想起来，所有的文档都没有源代码具有说服力。文档作为辅助，代码作为主体，相辅相成。\n\n评判一个软件的优劣，往往通过下面的特征：\n\n* 僵化性：进行一个改动的时候，程序的其他的许多地方都有可能出现问题。\n* 牢固性：设计中包含了对其他地方有用的部分，但是却无法把这些部分从系统中分离出来，或者需要巨大的风险和代价。\n* 粘滞性：\n** 软件：面临一个改动的时候，开发人员往往会有多种改动的方法。其中一些方法会保持设计，而另外一些方法会破坏设计。而当那些可以保持系统设计的方法比那些波坏设计的方法更加难以应用时，就表明设计具有高的粘滞性。\n** 环境：当开发环境迟钝、低效时，就会产生环境的粘滞性。\n* 不必要的复杂性：如果设计中包含当前没有用的组成部分，他就含有不必要的复杂性。\n* 不必要的重复：复制——粘贴 的重复性代码。\n* 晦涩性：模块难以理解。\n\n我们面对一个好的设计，最大的挑战莫过于软件的需求在不断的变化。所以，一个好的团队，必须要找到一种办法，使得设计对于这种变化具有弹性，并且应用一些实践来防止设计腐化。并且最为重要的是，敏捷的团队依靠变化来获取活力，他们几乎不会预先的设计，保持系统设计尽可能的干净、简单。通过许多的单元测试，保持设计的灵活性、易于理解性。\n\n书中为我们举了一个 copy\n程序的例子，展现了**需求的需求的变化带来的设计的退化**。然而这就是软件开发最重要的事实之一：*需求总在变化*。不过，再一次强调，对于敏捷开发团队来说，*如果我们软件的设计由于需求变化了而退化，那么我们就不是敏捷的。*\n\n从软件开发的三个方面来发现要做什么。\n\n[arabic]\n. 遵循敏捷实践去发现问题。\n. 应用设计原则去诊断问题。\n. 应用适当的设计模式去解决问题。\n\n软件开发的三个方面间的相互作用就是设计。\n\n敏捷设计是一个过程，不是一个事件。*敏捷开发人员不会对一个庞大的预先设计应用那些原则和模式。相反，这些原则和模式被应用在一次次的迭代中，力图使代码以及代码所表达的设计保持干净。*\n\n== 单一职责原则（SRP）\n\n____\n只有佛自己应当担负起公布玄妙秘密的职责\n____\n\n曾经我们在写保龄球实例的时候，最后的重构中，将一个 `Game`\n给分离到了两个类中，一个负责游戏，一个负责积分，各司其职。这就是单一职责。\n\n如果一个类承担的职责过多，那么就会产生耦合，这样的设计往往会造成一个职责的变化可能会影响或削弱其他职责的能力。\n\n这里的 _职责_ 怎么理解好呢？应该将它定义为\n``变化的原因''。如果有多于一个动机去改变一个类，那么这个类就不符合单一职责原则。这个时候我们就要进行分离。\n\n但是万事皆有特例，有时候可能会由于一些客观原因造成我们没有办法，我们就要采用其他的方法进行处理，比如抽象。书中举例了一个类实现两个接口的例子，虽然在类中多于一个职责，但是通过分离他的接口，也实现了解耦。\n\nSRP 最简单，也是最难运用的。\n\n== 开放——封闭原则（OCP）\n\n* ``对于扩展是开放的''：这意味着模块的行为是可以扩展的，当应用的需求改变时，我们可以对模块及性能扩展，使其具有满足那些改变的新行为。换句话说，我们可以改变模块的功能。\n* ``对于更改是封闭的''：对模块行为进行扩展时，不必改动模块的源代码或者二进制代码。\n\n这个还是比较好理解的，最好的实现就是抽象。例子是C++的有点不太明白。书中有一点我非常同意：为了防止软件背着不必要的复杂性，我们会允许自己被愚弄一次，这意味着我们在最初的代码编写时，假设变化不会发生，当变化发生时，我们就创建抽象来隔离发生的同类变化。\n\n始终遵循该原则才能从面向对象技术中持续地获得最大的益处，例如：可重用性和可维护性。而更确切的说，它需要程序我们更专注于将抽象技术应用到程序中那些趋于变化的部分上。\n\n== 总结\n\n这周感觉难度不是很大，20页很快就过了，不过自己没有动手实现。后面应该找事件实践一下。而且这周可能是由于电脑系统的原因，自己静不下来好好的看书。要好好调整自己的状态才行。\n\n","fields":{"slug":"/articles/2019/03/16/1552732721283.html","birthTime":"2019-03-16T10:38:41.385Z","modifiedTime":"2019-03-18","year":2019},"document":{"title":"[阅读] 敏捷软件开发 —— 敏捷设计（一）"}},{"content":"= [阅读] 敏捷软件开发 —— 敏捷设计（二）\n:page-description: [阅读] 敏捷软件开发 —— 敏捷设计（二）\n:page-category: 阅读\n:page-image: https://img.hacpai.com/bing/20180915.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2019/03/23/1553311043768.html\n:page-created: 1553311043950\n:page-modified: 1553438365674\n:toc:\n\n有时候觉得读书真的很有用，在文字中的感觉很美好，特别是喜欢朗读出来的感觉，越发的那样，越发能够体验书的境遇。这周的计划依旧被自己推迟，总是拖延症，不知不觉又到了周六，疲惫十分。不过依旧觉得不能放弃继续看这本书。世间太美，诱人的东西太多，有多少人可以面不改色呢？有时候觉得一个人的时候，才是自己变化最大的时候。\n\n== 回顾\n\n上一周的两个原则 ——\nSRP、OCP。都是十分简单但是却偏偏难以满足的，需要不断地去实践。相比较来说，SRP\n更好理解，书中的 OCP 是 C++ 的例子，始终有些懵，网上找了写 java\n其他的例子，也是理解了部分。不过这种的代码，依旧是 C++\n的例子，但是比起来却好理解了一些。\n\n== Listov 替换原则（LSP）\n\n____\n子类型必须能够替换掉他们的基类型。\n____\n\n*替换性质：若对每个类型 S 的对象 o1，都存在一个类型 T 的对象\no2，使得在所有针对 T 编写的程序 P 中，用 o1 替换 o2 后，程序 P\n行为功能不变，则 S 是 T 的子类型。*\n\n违反 LSP 原则是很严重的，因这常常会导致明显违反 OCP\n原则，就像一条连锁链一样。\n\n=== 一个违反 LSP 的简单例子\n\n书中的代码使用 C++ 完成，我采用 java 类似的完成了一下如下：\n\n[source,java]\n----\n// Point.java\npublic class Point {\n    double x;\n    double y;\n}\n----\n\n[source,java]\n----\n// Shape.java ，书中代码使用了枚举，java 可以省略，因为他有更好的判断类型的方式\n// 构造函数使用默认即可\npublic class Shape {\n\n}\n----\n\n[source,java]\n----\n// Circle.java  我全部暴露出去，省掉 get/set 方法\npublic class Circle extends Shape {\n    public Point itsCenter;\n    public double itsRadius;\n\n    public void draw() {\n        System.out.println(\"circle\");\n    }\n}\n----\n\n[source,java]\n----\n// Square.java 同上\npublic class Square extends Shape {\n    public Point itsTopLeft;\n    public double itsSide;\n\n    public void draw() {\n        System.out.println(\"square\");\n    }\n\n}\n----\n\n[source,java]\n----\n// ShapeTest.java\nclass ShapeTest {\n\n    @Test\n    void testDrawShape() {\n        drawShapeV1(new Circle());\n    }\n\n    // 按照书上的这样写，先假设这样写。\n    private void drawShapeV1(Shape shape) {\n        if (shape instanceof Circle) {\n            ((Circle) shape).draw();ShapeTest\n        } else if (shape instanceof Square) {\n            ((Square) shape).draw();\n        }\n    }\n}\n----\n\n这样的模型，`drawShape` 函数也就违反 OCP，因为他必须知道所有的 `Shape`\n的派生类，一旦有变化就要来修改此函数，但是我是仿照书上的 C++\n的代码写的，这是一个很明显违反了 LSP 的例子。\n\n=== 微妙的违反 LSP 的例子\n\n下面我们来看一个更为微妙的违反了 LSP\n的方式。现在已有一个正在运行的矩形如下：\n\n[source,java]\n----\n// Rectangle.java\npublic class Rectangle {\n    private Point itsTopLeft;\n    private double itsWidth;\n    private double itsHeight;\n\n    public double getItsWidth() {\n        return itsWidth;\n    }\n\n    public void setItsWidth(double itsWidth) {\n        this.itsWidth = itsWidth;\n    }\n\n    public double getItsHeight() {\n        return itsHeight;\n    }\n\n    public void setItsHeight(double itsHeight) {\n        this.itsHeight = itsHeight;\n    }\n}\n----\n\n如果我们现在要添加正方形呢？从一般意义上来讲，一个正方形就是一个矩形，所以把\n`Square` 类视为从 `Rectangle` 类派生是合乎逻辑的。他们存在一种 IS-A\n的关系。当然，IS-A\n这种用法有时会被认为是面向对象分析（OOA）基本技术之一。\n\n当我们在编写代码的时候会注意到一些问题，比如，对于 `Square`\n来说，其实并不同时需要 `itsHeight` 和\n`itsWidth`，但是由于继承的关系，他依旧会获得这两个属性，这显然是一种浪费。我们暂且不在乎内存的问题，换一个角度上看，当\n`Square` 会同事继承 `setItsWidth` 和 `setItsHeight`\n函数，这两个函数其实并不适用于正方形，因为他的长和宽都是相等的，现在我们作出些许改变：\n\n[source,java]\n----\npublic class Square extends Rectangle {\n    @Override\n    public void setItsWidth(double itsWidth) {\n        super.setItsWidth(itsWidth);\n        super.setItsHeight(itsWidth);\n    }\n\n    @Override\n    public void setItsHeight(double itsHeight) {\n        super.setItsHeight(itsHeight);\n        super.setItsWidth(itsHeight);\n    }\n}\n----\n\n现在长宽同时改变，保持了 `Square`\n几何上的不变性。接下来我们考虑下面的这个函数。\n\n[source,java]\n----\nvoid f(Rectangle r){\n    r.setItsWidth(32);\n}\n----\n\n在 java 中这个函数是没有问题，但是在 c++ 中就要将他们声明为 虚函数\n才能正确运行，因而不再讨论。\n\n这样的设计似乎是正确的，但是我们考虑下面的这个函数。\n\n....\nvoid f(Rectangle r){\n    r.setItsWidth(5);\n    r.setItsHeight(4);\n    assertEquals(20);\n}\n....\n\n这个函数认为传递过来的一定是 `Rectangle`，并调用了他的两个方法，对于\n`Rectangle` 来说是正确的，但是如果是 `Square` 来说确断言错误。函数 `f`\n对于 `Square/Rectangle` 层次结构来说是脆弱的。`f`\n的编写者完全可以对和这个不变的性质进行断言，倒是 `Square`\n违反了这个不变性。然而 `Square` 并没有违反正方形的不变性，违反的应该是\n`Rectangle` 的不变性。。。。（绕晕了=-=）\n\n____\nLSP\n让我们得出一个非常重要的结论，一个模型，如果独立地看，并不具有真正意义上的有效性。模型的有效性只能通过他的客户程序来表现。\n____\n\n=== 基于契约设计（DBC）\n\n许多开发人员可能会对``合理假设''行为方式的概念感到不安，有一种技术可以使合理的假设明确化，从而支持了\nLSP，他被称为基于契约设计（DBC）。\n\n简单的说就是为一个方法增加一个**前置**条件和一个**后置**条件，前置条件必须为真，执行完毕后，该方法要保证后置条件为真。对于\n`Rectangle` 的 `setItsWidth` 的后置条件可以是：\n\n....\n    assert ((this.itsWidth == itsWidth) && (this.itsHeight == old.itsHeight));\n....\n\n后面的介绍有点懵，一段文字中一会儿出现换句话，一会儿出现也就是说。按照我的理解，对于派生类，其前置条件应该更弱，后置条件应该更强。对于\n`Square` 来说，他的 `setItsWidth` 方法违反了基类定下的契约。\n\n不过对于 C++ 和 java 来说，并没有此项语言特征。\n\n但是我们可以选择在单元测试中指定契约，比如 `@BeforeEach` 这些 `junit`\n注解。\n\n=== 抽取公共部分的方法代替继承\n\n在书中举了一个曾经实际开发的一个例子，不过是用 C++\n实现，所以有点晕，不过理解了倒是不难。\n\n提取公共部分是一个设计工具，最好在代码不是很多的应用。\n\n=== 其他\n\n* 完成功能少于其基类的派生类通常是不能替换其基类的，因此就违反了 LSP。\n* 派生类中存在 _退化函数_ 并不总是表示违反了\nLSP，但是当存在这种情况时，还是值得注意一下的。\n* 派生类不应该抛出__异常__。\n\n____\n术语 ``IS-A''\n的含义国语宽泛以至于不能作为子类型的定义。子类型的正确定义是\n``可替换性的''，这里的可替换性可以通过显式或者隐式的契约来定义。\n____\n\n== 依赖倒置原则（DIP）\n\n____\n决不能再让国家的重大利益依赖于那些会动摇人类薄弱意志的众多可能性。\n____\n\n[arabic]\n. 高层模块不应该依赖于底层模块，二者都应该依赖于抽象。\n. 抽象不应该依赖于细节，细节应该依赖于抽象。\n\n举个例子来说，假如我们设计一辆汽车，那么我们需要如下步骤：\n\n[arabic]\n. 先设计轮子\n. 根据轮子大小设计底盘\n. 接着根据底盘设计车身\n. 最后根据车身设计好整个汽车\n\n如上就出现了一个 _依赖_\n的关系：汽车依赖车身，车身依赖底盘，底盘依赖轮子。\n\nimage::https://resources.echocow.cn/file/2019/3/24/v2-c68248bb5d9b4d64d22600571e996446_hd.jpg[example]\n\n这样的设计看起来没问题，但是可维护性却很低。假设设计完工之后，上司却突然说根据市场需求的变动，要我们把车子的轮子设计都改大一码。这下我们就蛋疼了：因为我们是根据轮子的尺寸设计的底盘，轮子的尺寸一改，底盘的设计就得修改；同样因为我们是根据底盘设计的车身，那么车身也得改，同理汽车设计也得改——整个设计几乎都得改！\n\n我们现在换一种思路。我们先设计汽车的大概样子，然后根据汽车的样子来设计车身，根据车身来设计底盘，最后根据底盘来设计轮子。这时候，依赖关系就倒置过来了：轮子依赖底盘，\n底盘依赖车身， 车身依赖汽车。\n\nimage::https://resources.echocow.cn/file/2019/3/24/v2-e64bf72c5c04412f626b21753aa9e1a1_hd.jpg[example]\n\n这时候，上司再说要改动轮子的设计，我们就只需要改动轮子的设计，而不需要动底盘，车身，汽车的设计了。\n\n这就是依赖倒置原则——把原本的高层建筑依赖底层建筑``倒置''过来，变成底层建筑依赖高层建筑。高层建筑决定需要什么，底层去实现这样的需求，但是高层并不用管底层是怎么实现的。这样就不会出现前面的``牵一发动全身''的情况。\n\n其实刚开始看到这个模式的时候想到的第一个词就是：*面向接口编程*。在 java\n中的表现可以看成下面的几点：\n\n[arabic]\n. 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象产生的。\n. 接口或抽象类不依赖于实现类。\n. 实现类依赖接口或抽象类。\n\n通过找出那些不随具体细节的改变而改变的真理，即抽象。找出这些抽象，倒置这些依赖关系，他就是面向对象的设计的核心。\n\nspring 中的 依赖注入\n正是一种依赖倒置的方法，他依据的依赖倒置的一种实现思路——控制反转（IOC）。通过上层控制下层，*把底层类作为参数传入上层类，实现上层类对下层类的“控制*”。这正是一个\nDIP 的典型例子。\n\n== 接口隔离原则（ISP）\n\n____\n不应该强迫客户依赖于他们不用的方法。\n____\n\n如果强迫客户程序依赖于那些他们不使用的方法，那么这些客户程序就面临着由于这些未使用方法的改变所带来的变更。这无意中导致了所有客户程序之间的耦合。换句话说，如果一个客户程序依赖于一个含有他不使用的方法的类，但是其他的客户程序却要使用该方法，那么当其他客户要求这个类改变时，就会影响到这个客户程序。\n\n如何理解呢？\n\n[arabic]\n. 客户端需要什么接口，就依赖什么接口，不需要的就不要给他。如果依赖了他不需要的接口，那么就代表着他有着未使用的冗余，并且还会因为其他的变更带来其他的危险。\n. 接口应该分离。这个和单一职责有点相似，也就是一个接口就去满足一个类似的功能即可，不应该为他去负责更多的功能。不过单一职责原则主要是类与方法，而接口隔离原则却是对接口而言的。\n\n那么在Java中怎么体现呢？\n\n* 一个类实现多个接口。\n* 功能尽可能的简单单一\n\n这个原则相对来说还是比较好理解的，因为在写代码的时候也多次发现一些使用的地方，所以体会较深且理解比较透彻。\n\n== 总结\n\n这周的其实相比起上周的比较简单，对于 Listov 其实 java\n是有很好的支持，天生没有虚函数的概念的存在还是十分友好的。而后面的依赖倒置原则则是归功于使用\nspring\n后的体会，以至于理解很快，随后医德接口隔离原则则是多次见到一些实现且已经了解过单一职责原则的基础上理解会很快。这周还是很轻松的，不过回顾了一下，面向对象设计的五大原则**SOLID**（**单一职责、开闭原则、里氏替换、接口隔离**以及*依赖反转*）中最难贯彻以及实现的就是**开闭原则**和*单一职责*，还是需要不断的实战来进行学习。\n\n== 参考链接\n\n* https://www.zhihu.com/people/sevenvidia/activities[知乎]\n* https://en.wikipedia.org/wiki/SOLID[维基百科]\n\n","fields":{"slug":"/articles/2019/03/23/1553311043768.html","birthTime":"2019-03-23T03:17:23.950Z","modifiedTime":"2019-03-24","year":2019},"document":{"title":"[阅读] 敏捷软件开发 —— 敏捷设计（二）"}},{"content":"= [阅读] 敏捷软件开发 —— 薪水支付案例研究（一）\n:page-description: [阅读] 敏捷软件开发 —— 薪水支付案例研究（一）\n:page-category: 阅读\n:page-image: https://img.hacpai.com/bing/20180314.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2019/04/03/1554263896709.html\n:page-created: 1554263896824\n:page-modified: 1554263912341\n:toc:\n\n这一部分与前面的两部分不太一样，他通过实际操作来完成一个完整的案例。并且引入一些常见的设计模式，开篇介绍了薪水支付系统的初步规格说明，相当于需求分析。\n\n* 对于钟点工，按照他们雇员记录中**每小时报酬字段**的值对他们进行支付。每天提交工作时间卡，其中记录了**日期以及工作小时数**。如果一天超过八小时，超过的部分会按照**正常报酬的\n1.5 倍**进行支付，**每周五**对他们进交付。\n* 有些雇员完全以**月薪**进行交付。**每个月的最后一个工作日**对他们进行交付，在他们的雇员记录中有一个*月薪字段*。\n* 带薪雇员，根据销售情况，支付**一定量的酬金**。他们会提交销售凭条，其中记录了**销售的日期**和**数量**，在他们的雇员记录中有一个**酬金字段**。**每隔一周的周五**对他们进行交付。\n* 加入协会的雇员，有一个**每周应付款项字段**。将会从他们**薪水中扣除**。协会有时也会**针对单个协会成员征收服务费用**。协会每周会提交这些**服务费用**，服务费用必须要从**相应雇员的下个月的薪水总额中扣除**。\n* 应用程序**每个工作日运行一次**，并在**当天**为相应的雇员进行交付，系统会被告知雇员的**支付日期**，这样他会计算从雇员**上次支付日期到规定的本次支付日期间应支付的数额**。\n\n== COMMAND 模式和 ACTIVE OBJECT 模式\n\n____\n没有人天生就具有命令他人的权利。\n____\n\n先从简单的入手，COMMAND\n模式是最简单、最优雅但同时也是适用性最广的设计模式。\n\n=== COMMAND 模式\n\n他非常简单，看一下下面的接口\n\n[source,java]\n----\npublic interface Command {\n    //　书中为　do()，但是　do　是　java　的关键字，无法作为函数名\n    public void execute();\n}\n----\n\n正如看到的一样，他只是封装了一个没有任何变量的函数。从严格的面向对象的意义上来说，这种做法是被强烈反对的————因为他具有功能分解的味道，他把函数层面的任务提升到了类的层面。然而这正是他有趣的地方。\n\n作者举了一个__复印机软件的例子__，其中通过对依稀的一些的简单的\ncommand　的封装。解除了系统的逻辑互联关系和实际链接的设备之间的耦合。\n\n另外一个例子是**创建和执行事务操作**，例如在对数据库进行操作之前，对数据进行\nvalidate\n操作。他很好的解除了从用户获取数据代码、验证并操作数据的代码以及业务对象本身之间的耦合关系。\n\n第三个例子是__回退__，可以对某个命令进行撤销操作。\n\n=== ACTIVE OBJECT 模式\n\n他是实现多线程的一项古老的技术，他可以自动完成动作或改变状态，隔离了方法执行和方法调用的过程，提高了并行性，对内部拥有控制线程的主动对象，降低了异步访问的复杂性。\n\n我们需要一个例子，看看以下的代码：\n\n[source,java]\n----\npublic interface Command {\n    /**\n     * 执行\n     */\n    public void execute();\n}\n----\n\n建立一个`ActiveObjectEngine`\n\n[source,java]\n----\n/**\n * 维护一个 Command 对象的链表\n *\n * @author echo\n */\npublic class ActiveObjectEngine {\n    private LinkedList<Command> itsCommands = new LinkedList<>();\n\n    /**\n     * 添加命令\n     *\n     * @param command 命令\n     */\n    public void addCommand(Command command) {\n        itsCommands.add(command);\n    }\n\n    /**\n     * 遍历链表，执行并去除每个命令\n     */\n    public void run() {\n        while (!itsCommands.isEmpty()){\n            Command command = itsCommands.getFirst();\n            itsCommands.removeFirst();\n            command.execute();\n        }\n    }\n}\n----\n\n以及一个实现\n\n[source,java]\n----\n/**\n * sleep 命令\n * 等待指定数目的毫秒，然后执行 wakeup 命令\n *\n * @author echo\n */\npublic class SleepCommand implements Command {\n    private Command wakeupCommand;\n    private ActiveObjectEngine engine;\n    private long sleepTime;\n    private long startTime = 0;\n    private boolean started = false;\n\n    public SleepCommand(int milliseconds, ActiveObjectEngine engine, Command wakeupCommand) {\n        this.sleepTime = milliseconds;\n        this.engine = engine;\n        this.wakeupCommand = wakeupCommand;\n    }\n\n    /**\n     * 执行时，检查自己是以前是已经执行过\n     * 如果没有，记录下开始时间\n     * 如果没有过延迟时间，就把自己再加到 ActiveObjectEngine 中\n     * 如果过了延迟时间，就把 wakeup 命令对象加到 ActiveObjectEngine 中\n     */\n    @Override\n    public void execute() {\n        long currentTime = System.currentTimeMillis();\n        if (!started) {\n            // 未开始时\n            started = true;\n            startTime = currentTime;\n            engine.addCommand(this);\n        } else if ((currentTime - startTime) < sleepTime) {\n            // 没有过延迟时间\n            engine.addCommand(this);\n        } else {\n            // 过了延迟时间,添加 -> 执行\n            engine.addCommand(wakeupCommand);\n        }\n    }\n}\n----\n\n然后一个测试\n\n[source,java]\n----\nclass TestSleepCommand {\n    private boolean commandExecuted = false;\n\n    @Test\n    void testSleep() {\n        Command wakeup = () -> commandExecuted = true;\n        ActiveObjectEngine activeObjectEngine = new ActiveObjectEngine();\n        SleepCommand sleepCommand = new SleepCommand(1000, activeObjectEngine, wakeup);\n        activeObjectEngine.addCommand(sleepCommand);\n        long start = System.currentTimeMillis();\n        activeObjectEngine.run();\n        long stop = System.currentTimeMillis();\n        long sleepTime = stop - start;\n        assertTrue(commandExecuted, \"Command executed!\");\n        System.out.println(\"SleepTime \" + sleepTime);\n    }\n}\n----\n\n具体的已经添加注释，在处理事件的时候，他不进行阻塞，常常在不符合执行条件的时候，他就把自己再次放回到\n`ActiveObjectEngine` 之中。\n\n采用该技术的变体去构建多线程系统已经是很常见的实践，这种类型的线程被称为\nrun-to-completion （RTC），意味着 command 不会阻塞。\n\n我们来模拟一个例子\n\n[source,java]\n----\npublic class DelayedTyper implements Command {\n    private int itsDelay;\n    private char itsChar;\n    private static ActiveObjectEngine engine = new ActiveObjectEngine();\n    private static boolean stop = false;\n\n    public DelayedTyper(int delay, char c) {\n        itsDelay = delay;\n        itsChar = c;\n    }\n\n    public static void main(String[] args) {\n        // 进行循环\n        engine.addCommand(new DelayedTyper(100, '1'));\n        engine.addCommand(new DelayedTyper(300, '3'));\n        engine.addCommand(new DelayedTyper(500, '5'));\n        engine.addCommand(new DelayedTyper(700, '7'));\n        // 设置 stop，停止循环\n        Command startCommand = () -> stop = true;\n        // 最后一个命令\n        engine.addCommand(new SleepCommand(20000, engine, startCommand));\n        engine.run();\n    }\n\n    /**\n     * 打印在构造时传入的字符\n     */\n    @Override\n    public void execute() {\n        System.out.print(itsChar);\n        if (!stop) {\n            delayAndRepeat();\n        }\n    }\n}\n----\n\nCOMMAND\n模式的简单性掩盖了他的多功能性，但是它可能是不符合面向对象的思维范式的，因为他对函数的关注查过了类，但是在实际开发中，他确实是非常有用的。\n\n== TEMPLATE METHOD 模式和 STRATEGY 模式：继承与委托\n\n____\n业精于勤\n____\n\n``业精于勤，荒于嬉；行成于思，毁于随。''一本外国的书引入了我们中国的《进学解》，让人意外。这句话很好理解，学业由于勤奋而专精，由于玩乐而荒废；德行由于独立思考而有所成就，由于因循随俗而败坏。在软件开发中，使用继承我们可以基于差异编程，通过集成可以建立完整的软件结构分类。\n\n但是继承的过度使用是非常糟糕的，代价十分昂贵\n\n____\n优先使用对象组合而不是类继承\n____\n\n=== TEMPLATE METHOD 模式\n\n==== 华氏度转摄氏度\n\n他是通过继承来解决问题。现在我们有一个程序如下：\n\n[source,java]\n----\n/**\n * 输入华氏度转化为摄氏度\n *\n * @author echo\n * @version 1.0\n * @date 19-4-3 09:01\n */\npublic class Ftocraw {\n    public static void main(String[] args) throws Exception {\n        // 初始化流\n        InputStreamReader isr = new InputStreamReader(System.in);\n        BufferedReader br = new BufferedReader(isr);\n        boolean done = false;\n        // 主循环中完成工作\n        while (!done) {\n            String fabrString = br.readLine();\n            if (fabrString == null || fabrString.length() == 0) {\n                done = true;\n            } else {\n                double fahr = Double.parseDouble(fabrString);\n                double celcius = 5.0 / 9.0 * (fahr - 32);\n                System.out.println(\"F=\" + fahr + \", C=\" + celcius);\n            }\n        }\n        System.out.println(\"ftoc exit!\");\n    }\n}\n----\n\n他是一个简单且正常运行的主循环结构。我们可以应用 TEMPLATE METHOD\n模式把这个基本结构从 `floc` 程序中分离出来。\n\n*我们把所有的通用代码放入一个抽象基类的实现方法中，这个实现方法完成这个通用算法，但是将所有的实现细节都交付给该积累的抽象方法，修改后的如下：*\n\n[source,java]\n----\n/**\n * 描绘了一个通用的主循环应用程序\n *\n * @author echo\n * @version 1.0\n * @date 19-4-3 09:10\n */\npublic abstract class Application {\n    private boolean isDone = false;\n    protected abstract void init();\n    protected abstract void idle();\n    protected abstract void cleanup();\n\n    public void run() {\n        // 初始化\n        init();\n        // 执行\n        while (!done()) {\n            idle();\n        }\n        // 清除\n        cleanup();\n    }\n\n    protected boolean done() {\n        return isDone;\n    }\n\n    protected void setDone(boolean done) {\n        isDone = done;\n    }\n}\n----\n\n现在，我们可以通过继承 `Application` 来重写 `floc`\n类，只需要实现抽象方法即可，修改后的如下：\n\n[source,java]\n----\n/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 09:15\n */\npublic class FtocTemplateMethod extends Application {\n    private InputStreamReader inputStreamReader;\n    private BufferedReader bufferedReader;\n\n    public static void main(String[] args) {\n        new FtocTemplateMethod().run();\n    }\n\n    @Override\n    protected void init() {\n        inputStreamReader = new InputStreamReader(System.in);\n        bufferedReader = new BufferedReader(inputStreamReader);\n    }\n\n    @Override\n    protected void idle() {\n        String fahrString = readLineAndReturnNullIfError();\n        if (fahrString == null || fahrString.length() == 0) {\n            setDone();\n        } else {\n            double fahr = Double.parseDouble(fahrString);\n            double celcius = 5.0 / 9.0 * (fahr - 32);\n            System.out.println(\"F=\" + fahr + \", C=\" + celcius);\n        }\n    }\n\n    /**\n     * 异常处理\n     *\n     * @return 读取结果\n     */\n    private String readLineAndReturnNullIfError() {\n        String s;\n        try {\n            s = bufferedReader.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n            s = null;\n        }\n        return s;\n    }\n\n    @Override\n    protected void cleanup() {\n        System.out.println(\"ftoc exit!\");\n    }\n}\n----\n\n这就是 TEMPLATE METHOD\n模式的一个简单应用。在这个特定的简单的程序中，我们很容易理解。但是我们真的需要这样吗？*其实，上面的这个是一个滥用模式的好礼自，在这个特定程序中，使用\nTEMPLATE METHOD\n模式是荒谬的，他使得程序变得复杂庞大，他的意义不大，因为俄他的代价高于他所带来的好处。*\n\n==== 冒泡排序\n\n设计模式是很好的东西，但是并不意味着必须要经常使用它们，下面我们看一个设计模式稍微有用些的例子。\n\n[source,java]\n----\n/**\n * 冒泡排序\n *\n * @author echo\n * @version 1.0\n * @date 19-4-3 09:29\n */\npublic class BubbleSorter {\n    static int operations = 0;\n\n    public static int sort(int[] array) {\n        operations = 0;\n        if (array.length <= 1) {\n            return operations;\n        }\n        for (int nextToLast = array.length - 2; nextToLast >= 0; nextToLast--) {\n            for (int index = 0; index <= nextToLast; index++) {\n                compareAndSwap(array, index);\n            }\n        }\n        return operations;\n    }\n\n    private static void compareAndSwap(int[] array, int index) {\n        if (array[index] > array[index + 1]) {\n            swap(array, index);\n        }\n        operations++;\n    }\n\n    private static void swap(int[] array, int index) {\n        int tmp = array[index];\n        array[index] = array[index + 1];\n        array[index + 1] = tmp;\n    }\n}\n----\n\n这是一个非常普通的冒泡排序算法，现在我们使用 TEMPLATE METHOD\n模式，把冒泡排序算法分离出来，放到一个抽象类中，如下：\n\n[source,java]\n----\n/**\n * 抽象\n *\n * @author echo\n * @version 1.0\n * @date 19-4-3 09:35\n */\npublic abstract class BubbleSorterAbstract {\n    private int operations = 0;\n    protected int length = 0;\n\n    protected int doSort() {\n        operations = 0;\n        if (length <= 1) {\n            return operations;\n        }\n        for (int nextToLast = length - 2; nextToLast >= 0; nextToLast--) {\n            for (int index = 0; index <= nextToLast; index++) {\n                if (outOfOrder(index)) {\n                    swap(index);\n                }\n                operations++;\n            }\n        }\n        return operations;\n    }\n\n    protected abstract void swap(int index);\n    protected abstract boolean outOfOrder(int index);\n}\n----\n\n通过继承这个类，就可以完成一些变化的排序如下：\n\n[source,java]\n----\n/**\n * int 类型冒泡排序\n *\n * @author echo\n * @version 1.0\n * @date 19-4-3 09:39\n */\npublic class IntBubbleSorter extends BubbleSorterAbstract {\n    private int[] array = null;\n\n    public int sort(int[] theArray) {\n        array = theArray;\n        length = array.length;\n        return doSort();\n    }\n\n    @Override\n    protected void swap(int index) {\n        int tmp = array[index];\n        array[index] = array[index + 1];\n        array[index + 1] = tmp;\n    }\n\n    @Override\n    protected boolean outOfOrder(int index) {\n        return array[index] > array[index+1];\n    }\n}\n----\n\n[source,java]\n----\n/**\n * double 类型冒泡排序\n *\n * @author echo\n * @version 1.0\n * @date 19-4-3 09:41\n */\npublic class DoubleBubbleSorter extends BubbleSorterAbstract {\n    private double[] array = null;\n    public int sort(double[] theArray) {\n        array = theArray;\n        length = array.length;\n        return doSort();\n    }\n\n    @Override\n    protected void swap(int index) {\n        double tmp = array[index];\n        array[index] = array[index + 1];\n        array[index + 1] = tmp;\n    }\n\n    @Override\n    protected boolean outOfOrder(int index) {\n        return array[index] > array[index+1];\n    }\n}\n----\n\n通过 TEMPLATE METHOD\n模式的继承，把通用方法放在基类中，并且通过继承在不同的上下文中实现该通用算法。但是继承是一种非常强的关系，派生类不得不和基类绑定在一起。例如，其他类型的排序算法也要重新实现\n`outOfOrder` 和 `swap`。\n\n_java 中有范型能够很好的解决上面的例子的问题。_\n\n不过，STRATEGY 提供了一种可选的方案。\n\n=== STRATEGY 模式\n\n==== 华氏度转摄氏度\n\n我们考虑刚才 华氏度转摄氏度\n的例子，我们不再将通用的应用算法放进一个抽象基类中，而是放到一个\n`ApplicationRunner`\n具体类中。我们把通用算法必须要调用的抽象方法定义在一个 `Application`\n接口中，再从这个接口中派生出 `FlocStrategy`，再传给具\n`ApplicationRunner`，之后，就可以把具体工作委托给接口去完成。\n\n先来写 `Application` 接口\n\n[source,java]\n----\n/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 10:00\n */\npublic interface Application {\n    public void init();\n    public void idle();\n    public void cleanup();\n    public boolean done();\n}\n----\n\n看看 `ApplicationRunner`\n\n[source,java]\n----\n/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 09:59\n */\npublic class ApplicationRunner {\n    public Application itsAppliction = null;\n\n    public ApplicationRunner(Application itsAppliction) {\n        this.itsAppliction = itsAppliction;\n    }\n\n    public void run() {\n        itsAppliction.init();\n        while (!itsAppliction.done()) {\n            itsAppliction.idle();\n        }\n        itsAppliction.cleanup();\n    }\n}\n----\n\n然后使用 STRATEGY 模式来进行改造 华氏度转摄氏度 的例子\n\n[source,java]\n----\n/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 10:02\n */\npublic class FtocStrategy implements Application {\n    private InputStreamReader inputStreamReader;\n    private BufferedReader bufferedReader;\n    private boolean isDone = false;\n\n    public static void main(String[] args) {\n        new ApplicationRunner(new FtocStrategy()).run();\n    }\n\n    @Override\n    public void init() {\n        inputStreamReader = new InputStreamReader(System.in);\n        bufferedReader = new BufferedReader(inputStreamReader);\n    }\n\n    @Override\n    public void idle() {\n        String fahrString = readLineAndReturnNullIfError();\n        if (fahrString == null || fahrString.length() == 0) {\n            isDone = true;\n        } else {\n            double fahr = Double.parseDouble(fahrString);\n            double celcius = 5.0 / 9.0 * (fahr - 32);\n            System.out.println(\"F=\" + fahr + \", C=\" + celcius);\n        }\n    }\n\n    @Override\n    public void cleanup() {\n        System.out.println(\"ftoc exit!\");\n    }\n\n    @Override\n    public boolean done() {\n        return isDone;\n    }\n\n    /**\n     * 异常处理\n     *\n     * @return 读取结果\n     */\n    private String readLineAndReturnNullIfError() {\n        String s;\n        try {\n            s = bufferedReader.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n            s = null;\n        }\n        return s;\n    }\n\n}\n----\n\n他和 TEMPLATE METHOD 实现的相比怎么样呢？很明显，STRATEGY\n模式代价更高一点，涉及到更多数量的类和间接层次，`ApplicationRunner`\n委托指针的使用会造成比继承稍微多一点的运行时间和数据空间开销。*但是另一方面，如果有许多不同的程序妖运行，就可以重用\n`ApplicationRunner` 实例，并把许多不同的 `Application`\n实现传给他，从而减小了通用算法和该算法所控制的及具体细节之间的耦合。*\n\n==== 冒泡排序\n\n不过最烦人的问题是 STRATEGY 模式需要很多额外的类，我们来考虑一下使用\nSTRATEGY 模式实现 冒泡排序 看看。\n\n排序接口\n\n[source,java]\n----\n/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 10:13\n */\npublic interface SortHandle {\n    public void swap(int index);\n    public boolean outOfOrder(int index);\n    public int length();\n    public void setArray(Object array);\n}\n----\n\n他的一个实现\n\n[source,java]\n----\n/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 10:13\n */\npublic class IntSortHandle implements SortHandle {\n    private int[] array = null;\n\n    @Override\n    public void swap(int index) {\n        int tmp = array[index];\n        array[index] = array[index + 1];\n        array[index + 1] = tmp;\n    }\n\n    @Override\n    public boolean outOfOrder(int index) {\n        return (array[index] > array[index + 1]);\n    }\n\n    @Override\n    public int length() {\n        return array.length;\n    }\n\n    @Override\n    public void setArray(Object array) {\n        this.array = (int[]) array;\n    }\n}\n----\n\n排序算法\n\n[source,java]\n----\n/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 10:12\n */\npublic class BubbleSorter {\n    private int operations = 0;\n    private int length = 0;\n    private SortHandle itsSortHandle = null;\n\n    public BubbleSorter(SortHandle itsSortHandle) {\n        this.itsSortHandle = itsSortHandle;\n    }\n\n    public int sort(Object array) {\n        itsSortHandle.setArray(array);\n        length = itsSortHandle.length();\n        operations = 0;\n        if (length <= 1) {\n            return operations;\n        }\n        for (int nextToLast = length - 2; nextToLast >= 0; nextToLast--) {\n            for (int index = 0; index <= nextToLast; index++) {\n                if (itsSortHandle.outOfOrder(index)) {\n                    itsSortHandle.swap(index);\n                }\n                operations++;\n            }\n        }\n        return operations;\n    }\n}\n----\n\n和 TEMPLATE METHOD 不同的是，接口实现 `IntSortHandle` 对 `BubbleSorter`\n一无所知，布依赖于任何实现方式。在 TEMPLATE METHOD 中，`swap` 和\n`outOfOrder` 的实现依赖于冒泡排序算法，所以他部分违反了 `DIP`，而\nSTRATEGY 总不包含这样的依赖。所以可以在 `BubbleSorter` 之外的其他任何从\n`SortHandle` 派生出来的类。\n\n==== 冒泡排序的变体\n\n现在，我们创建冒泡排序的一个变体，如果他在一次对于数组的遍历中发现数组的元素已经是按序排列的话，就提前结束。创建一个\n`QuickBubbleSorter`\n\n[source,java]\n----\n/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 10:27\n */\npublic class QuickBubbleSorter {\n    private int operations = 0;\n    private int length = 0;\n    private SortHandle itsSortHandle = null;\n\n    public QuickBubbleSorter(SortHandle itsSortHandle) {\n        this.itsSortHandle = itsSortHandle;\n    }\n\n    public int sort(Object array) {\n        itsSortHandle.setArray(array);\n        length = itsSortHandle.length();\n        operations = 0;\n        if (length <= 1) {\n            return operations;\n        }\n        boolean thisPassInOrder = false;\n        for (int nextToLast = length - 2; nextToLast >= 0 && !thisPassInOrder; nextToLast--) {\n            thisPassInOrder = true;\n            for (int index = 0; index <= nextToLast; index++) {\n                if (itsSortHandle.outOfOrder(index)) {\n                    itsSortHandle.swap(index);\n                    thisPassInOrder = false;\n                }\n                operations++;\n            }\n        }\n        return operations;\n    }\n}\n----\n\n`QuickBubbleSorter` 同样可以使用 `IntSortHandle`，或者任何其他从\n`SortHandle` 派生出来的类。它完全遵循 DIP\n原则，从而允许每个具体实现都可以被多个不同的通用算法操纵。\n\n相比起来，两个模式都可以\n*用来分离高层的算法和底层的具体实现细节，都允许高层的算法独立于他的具体实现细节重用。*\n此外 STRATEGY\n模式也允许具体实现细节独立于高层的算法重用，不过要以一些额外的复杂性、内存以及运行时间开销作为代价。\n\n== FACADE 模式和 MEDIATOR 模式\n\n____\n尊贵的符号外表下，隐藏着卑劣的梦想。\n____\n\nFACADE 模式和 MEDIATOR\n模式有着共同的目的，他们都把某种策略施加到另外一组对象上。 - FACADE\n模式从上面施加策略，使用是明显且受限的。 -\n可以为一组具有复杂且全面的接口的对象提供一个简单且特定的接口，简单的说，就是应藏了具体的内部细节，提供一个非常简单且特定的接口来完成。FACADE\n对其就施加了策略。 - MEDIATOR\n模式从下面施加策略，使用是不明显且不受限的。 -\n无需被施加者允许或者知晓。\n\n== SINGLETON 模式和 MONOSTATE 模式\n\n____\n这是对万物的祝福！除此之外再无其他\n____\n\n这章的两个模式，是强制对象单一性的模式。\n\n=== SINGLETON 模式\n\nSINGLETON 模式 是一个很简单的模式，通过一个一些测试用例来看看。\n\n[source,java]\n----\n/**\n * 单例模式\n *\n * @author echo\n * @version 1.0\n * @date 19-4-3 11:08\n */\npublic class Singleton {\n    private static Singleton theInstance = null;\n    private Singleton(){}\n    public static Singleton instance() {\n        if (theInstance == null) {\n            theInstance = new Singleton();\n        }\n        return theInstance;\n    }\n}\n----\n\n测试\n\n[source,java]\n----\n/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 11:07\n */\nclass TestSimpleSingleton {\n    @Test\n    void testCreateSingleton() {\n        Singleton s1 = Singleton.instance();\n        Singleton s2 = Singleton.instance();\n        assert s1 == s2;\n    }\n\n    @Test\n    void testNoPublicConstructors() throws ClassNotFoundException {\n        Class<?> singleton = Class.forName(\"four.singleton.Singleton\");\n        Constructor[] constructors = singleton.getConstructors();\n        assert constructors.length == 0;\n    }\n}\n----\n\n可以看出，通过私有化构造函数，实现了 SINGLETON 模式\n\n*好处：* 1. 跨平台：使用合适的中间件，可以把 SINGLETON 模式扩展为跨多个\nJVM 和多个计算机工作。 2.\n适用于任何类：只要把一个类的构造函数私有化，并且增加相应的静态函数和变量，就可以把这个类变成\nSINGLETON。 3. 可以通过派生创建：给定一个类，可以创建他的一个 SINGLETON\n子类。 4. 延迟求值：如果 SINGLETON 从未使用过，那么就不会创建他。\n\n*代价：* 1. 摧毁方法未定义：没有好的摧毁方法去摧毁一个\nSINGLETON，或者解除其职责，可能会同时存在两个实例。 2. 不能继承：从\nSINGLETON 类派生出来的类不是 SINGLETON 的。 3. 效率问题：每次调用\ninstance 都会执行 if 语句 4. 不透明性：SINGLETON\n使用者指定他们在使用一个 SINGLETON，因为他们必须调用 instance 方法。\n\n=== MONOSTATE 模式\n\nMONOSTATE\n模式是获取单一对象的另外一种方法。它使用了一种完全不同的工作机制，看看下面的一个例子：\n\n[source,java]\n----\n/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 11:20\n */\npublic class Monostate {\n    private static int itsX = 0;\n    public Monostate(){}\n    public void setX(int x) {\n        itsX = x;\n    }\n    public int getX() {\n        return itsX;\n    }\n}\n----\n\n测试用例\n\n[source,java]\n----\n/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 11:21\n */\nclass TestMonostate {\n    @Test\n    void testInstance() {\n        Monostate monostate = new Monostate();\n        for (int x = 0; x < 10; x++) {\n            monostate.setX(x);\n            assert x == monostate.getX();\n        }\n    }\n\n    @Test\n    void testInstanceBehaveAsOne() {\n        Monostate m1 = new Monostate();\n        Monostate m2 = new Monostate();\n        for (int x = 0; x < 10; x++) {\n            m1.setX(x);\n            assert x == m2.getX();\n        }\n    }\n}\n----\n\n两个对象共享相同的变量，`itsX`\n是静态的，但是方法不是静态的，这一点很重要。无论创建多少个 `Monostate`\n对象的实例，他们都表现得**像一个对象一样，甚至把当前的所有实例都销毁或者解除职责，也不会丢失数据。**\n\n*好处：* 1. 透明性：使用 MONOSTATE\n对象和使用常规对象没有什么区别，使用者不知道对象是 MONOSTATE。 2.\n可派生性：MONOSTATE 的派生类都是 MONOSTATE，事实上，MONOSTATE\n的所有派生类都是同一个 MONOSTATE 的一部分，他们共享相同的静态变量。 3.\n多态性：由于 MONOSTATE 的方法不是静态的，所以可以在派生类中总重写。\n\n*代价* 1. 不可转换性：不能通过派生类把常规类转换成 MONOSTATE 类。 2.\n效率问题：因为 MONOSTATE 是真正的对象，所以会导致许多的创建和销毁开销。\n3. 内存占用：即使从未使用过 MONOSTATE，他的变量也要占据内存空间。 4.\n平台局限性：MONOSTATE 不能跨多个 JVM 或者多个平台工作。\n\n两个模式，一个关注行为，一个。 - SINGLETON\n模式关注结构，强制结构上的单一性。防止创建出多个对象实例。如果希望通过派生去约束一个现存类，并且不介意他的所有调用这都必须要调用\n`instance()` 方法来获取访问权，那么他是最合适的。 - MONOSTATE\n模式关注行为，强制行为上的单一性，而没有强加结构方面的限制。如果希望类的单一性本质对使用者透明，或者希望使用单一对象的多态派生对象，那么他是最合适的。\n\nMONOSTATE 的测试用例对 SINGLETON 类是有效的，但是 SINGLETON\n的测试用例却不远不适用于 MONOSTATE 类。\n\n== NULL OBJECT 模式\n\n____\n残缺即是完美，冷淡即是虚无，死亡即是圆满，没有即是更多。\n____\n\njava 中可能最常见的一个异常就是空指针异常了，使用 `if` 和 `try/catch`\n都不是很优雅，现在我们俩看个 NULL OBJECT 模式的例子。\n\n先编写测试用例\n\n[source,java]\n----\n/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 11:42\n */\nclass TestEmployee {\n\n    @Test\n    void testNull() {\n        // 不存在的数据\n        Employee employee = DB.getEmployee(\"Bob\");\n        assert employee.isTimeToPay(new Date()) || Employee.NULL == employee;\n    }\n}\n----\n\n书写接口\n\n[source,java]\n----\npublic interface Employee {\n    public boolean isTimeToPay(Date payDate);\n    public void pay();\n    public static final Employee NULL = new Employee() {\n        @Override\n        public boolean isTimeToPay(Date payDate) {\n            return false;\n        }\n\n        @Override\n        public void pay() {\n\n        }\n    };\n}\n----\n\n[source,java]\n----\n/**\n * @author echo\n * @version 1.0\n * @date 19-4-3 11:43\n */\npublic class DB {\n    public static Employee getEmployee(String name) {\n        return Employee.NULL;\n    }\n}\n----\n\n我们通过使无效的数据成为一个匿名内部类是一个确保只有单一实例的方法，实际上并不存在。\n\n我突然想到了 jdk 8 的 optional～\n\n== 总结\n\n相比来说，前半部分较难，后面比较简单。周六看完的，但是周三才实现部分代码，理解提高了一点，作业实在太多=-=脑壳疼，加油吧！\n\n","fields":{"slug":"/articles/2019/04/03/1554263896709.html","birthTime":"2019-04-03T03:58:16.824Z","modifiedTime":"2019-04-03","year":2019},"document":{"title":"[阅读] 敏捷软件开发 —— 薪水支付案例研究（一）"}},{"content":"= [阅读] 敏捷软件开发 —— 薪水支付案例研究（二）\n:page-description: [阅读] 敏捷软件开发 —— 薪水支付案例研究（二）\n:page-category: 阅读\n:page-image: https://img.hacpai.com/bing/20181204.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2019/04/06/1554562203987.html\n:page-created: 1554562204039\n:page-modified: 1554562230674\n:toc:\n\n放假总是悠闲的，找不到事做就看看书吧。\n\n____\n那些在任何情况下都是e迷离的事物，其美丽是就其本性而言的。美丽的终结也是就其本性而言的，赞美并不是其本性的一部分。\n____\n\n就第一篇写的记录开始学习。\n\n== 推迟考虑数据库\n\n我们构建一个应用程序，最先考虑到的应该是数据库，往往是先设计数据库然后再来设计，对于该类问题同样，他可以使用某些关系型数据库，并且从需求中可以清楚地知道表和字段的可能样子。可以容易设计出一个可用的数据库模式，然后再构建一些查询。不过，在这种方法产生的应用程序中，数据库就成了关注的中心。\n\n我们换个思路，把数据库看成我们实现的细节！尽可能地推迟考虑数据库。按照**抽象**的定义，我们应该把本质的部分放大，无关紧要部分的去掉，在项目的当前阶段数据库就是无关紧要的，他不过是一项用来存储和访问数据的技术而已。\n\n== 用例\n\n那我们如何分析呢？在一开始的 xp\n编程中，提到一个非常重要的概念——用户素材。**用例**就是用稍多一点的细节描述的用户素材，在进行分析的时候，我们关注用户素材和验收测试。不陷入过多的细节。\n\n== 搜寻\n\n来看看这章做了哪些事\n\n[arabic]\n. 将用户描述转化为了具有细节的用例，而不是过于简单用户素材。\n. 对用例进行一个一个的分析，弄清楚系统怎样去响应这些操作。\n. 前半部分通过对六个用例的分析，初步确定 `COMMAND 模式` 以及可能的\n静态模型。\n. 通过一个用例以及他的变体，改变初步确定的设计模式，由 `COMMAND 模式`\n改为 `STRATEGY 模式` ，同时加上了 `NULL OBJECT`\n模式设计出修订后的系统类图。\n. 通过协同图明确了可能出现的用例变体/情景。\n. 寻找描述中的抽象。\n. 通过抽象发现从属关系，移除 `NULL OBJECT` 模式。\n\n== 设计\n\n在设计中，*不包含任何对数据库的内容*\n\n[arabic]\n. 首先将用户素材n加沙改一些适当的细节描述成为用例\n. 通过对用例的分析，获取到有用的信息以及设计的洞察力\n. 设计不是一成不变的，它可以随着迭代的进行不断修改，最终迭代完成后确定下来\n. 遵循面向对象设计的五大原则\n. 寻找出有用的抽象\n. 设计模式不是用的越多越好\n\n== 总结\n\n这章节似乎是一个小型会议一般，在商讨第一次迭代的点滴与内容，值得注意的是，多次强调妖抵制住数据库的诱惑。i回想一下，我们似乎总是在**面向数据库编程**，这并不是一个好习惯。同时也多次提到了五大原则，在设计时，五大原则是能够架构一个友好的软件架构的重要因素。这次的目的只是为了发起一种思考，但是依旧都是可变的，只是一个快速设计的一个会话展现。\n\n","fields":{"slug":"/articles/2019/04/06/1554562203987.html","birthTime":"2019-04-06T14:50:04.039Z","modifiedTime":"2019-04-06","year":2019},"document":{"title":"[阅读] 敏捷软件开发 —— 薪水支付案例研究（二）"}},{"content":"= [阅读] 2019 阅读书单\n:page-description: [阅读] 2019 阅读书单\n:page-category: 感想\n:page-image: https://resources.echocow.cn/file/2019/4/7/timg.jpg\n:page-href: /articles/2019/04/07/1554568406455.html\n:page-created: 1554568406506\n:page-modified: 1558277803664\n:toc:\n\n书籍真的是世界上最美好的东西。自己何曾想过，会喜欢上阅读。\n\n不知道从什么时候起，自己会感觉空虚，那种``无事可做''的感觉让我害怕和恐慌。自学的时候疯狂吞噬视频，闲暇时刻也不愿翻翻那些早已褪色的书籍，在视频中囫囵吞枣以求进步。是的，对于挨踢来说，视频的确是``进步最快的方式''，也许你会用了，也许就懂了。直到某天，我再次拿起一本书来阅读的时候才发现，自己以前是多么可笑。不过不可否认，视频中的系统化的学习让我的``技术''得以进步，但是却让我不再去思考。不再去看看世界，不再去看看外面。\n\n自己曾经很喜欢旅游，高考毕业去了广州，那是自己第一次出省，看着繁忙的街道，来来往往的从没见过的外国人，以及蒸笼一般的天气，让我对外面憧憬渐渐淡去。后来用爸妈给的钱，大一寒假独自一人去山东济宁，第一次坐飞机，第一次独自旅行，去了自己想去的孔地，在那里感受到了北方的气息，不免留恋，但是那时早已不再阅读任何书籍。后来拿着奖学金再次去了广州，找自己朋友，那时是冬天，大二寒假，不一样的广州却让我对他的印象一点点的改变，或许是因为对的人带来不同的感觉。在回来的高铁上，再次拾起我最爱的三毛。回来后的自己开始真正的学习，Head\nfirst 系列让我找到了自己的兴趣。\n\n可是，后面的日子，自己在各种所谓的比赛中奔波，不知道自己到底算不算成长。总会翻出高中的时候爱听的\n心里FM，听着自己以前最喜欢听的那些文章，至今依旧未变。最后一次出省是一次国赛，去北京参加比赛，去了故宫便回了学校。不喜欢首都的快节奏，那样的节奏让我在短短的三天迷失自己，只会跟着人群随波逐流，那不是我想要的生活。\n\n今年过年，父母开车自驾去了云南，走过了花海，看过了瀑布，但是心里依旧提不起一点兴趣。回来后的假期，再次接触阅读，拿起了书。再次看了三毛的撒哈拉的故事，看见了哑奴依旧会流泪。那时想，自己还有救，我还没有变成一个彻头彻尾的傻瓜。\n\n我开始寻找一本本书籍，那些尘封的，想看的都被我一一寻了出来。我很幸运的找到了自己兴趣，它是我的兴趣，我坚信他也会成为我的工作，我想，我可能不能继续看着三毛了，也不能去看托尔斯泰、契诃夫、巴尔扎克、福楼拜、鲁迅、蒲松龄这些大师的作品，因为我还需要生活，我希望的我的兴趣能够成为我的工作，所以我只有不断的去学习那些能够给未来的自己带来收益并且是我感兴趣的东西，我不知道这算不算可悲，但是在阅读的时候我是快乐的，我不觉得自己有实力去感动自己，但我觉得，在以后，我回忆起来的时候，我不会心中有愧以至于追悔莫及，那种感觉是很痛苦的。\n\n但是我却害怕，因为我知道我是个什么样的人，自己会不会连一本都看不完就放弃？但是想想，那又如何？自己曾经害怕写东西，害怕分享，但是如今的自己不也做了吗？总要去面对一些事情的，自己越不愿意做的事情，就越要尝试去接受，那样自己才会真正的成长。前段时间看\nTED，他的观点深深打动了我，要学会说不，自己越不敢做越不想做的事情，在道德层面以及法律层面上越要勇敢的尝试去做，那样的生活才会有趣，自己才会成长。\n\n在阅读中，最让我着迷的就是时间的充实，这与刷抖音是不一样的，在阅读完一本书后，自己的思想以及心境都会得到洗礼，哪怕是一点点，那也值了。但是自己依旧找不回来那种想出去旅游的冲动了，电脑带来了我的兴趣，但是却带走了我一些东西。我有一腔激情，可以一个人走走，没有了那种冲动，其实更愿意来一片平静，平静的走走，其实也挺好。\n\n熟悉我的人都知道，自己依旧还是一个没有长大的孩子啊。自己想想，2019年，一个月一本书籍我已经很满足了，自己还有更重要的事情等着我去做。这里只会记录那些我正在看和已经看完的书，不会记那些自己想看还没看的书，因为担心自己看不完，因为自己确确实实是一个眼高手低的家伙。目标一个月一本我已经很知足了。\n\n* 《spring 实战》 —— 看了一半多，由于开学暂时搁置了。\n* 《敏捷软件开发原则、模式与实践》——\n非常好的一本书，但是内容有些许过时，我不会把它全部看完，但是会选择看完精华部分，[line-through]*预计看到第十九章*。十九章完成，不再继续。\n* 《深入浅出Docker》 —— 环境原因止步于十四章。\n* 《深入浅出Spring Boot 2.x》 —— 个人觉得很一般，还是比较喜欢 spring\n实战 风格的。\n* 《计算机网络 自顶向下方法》 ——\n正在阅读，真的太棒，第一章就让我喜欢上了他，就是文字太多看得有点慢=-=\n\n2019-05-19\n\n","fields":{"slug":"/articles/2019/04/07/1554568406455.html","birthTime":"2019-04-06T16:33:26.506Z","modifiedTime":"2019-05-19","year":2019},"document":{"title":"[阅读] 2019 阅读书单"}},{"content":"= 智慧树/知到 自动看课脚本 ——js版\n:page-description: 智慧树/知到 自动看课脚本 ——js版\n:page-category: 归档\n:page-image: https://resources.echocow.cn/file/2019/4/7/1/timg.jpg\n:page-href: /articles/2019/04/07/1554643306922.html\n:page-created: 1554643306973\n:page-modified: 1558924250355\n:toc:\n\n使用 jquery 完成自动看课，自动答题，自动倍数播放等，可以自由设置参数等。\n\n____\n友情提醒：刷课有风险，由于是纯 js\n代码，所以我个人觉得我的这个是风险最低的几乎为零，但是却不敢保证完全没有风险。\n____\n\n'''''\n\n____\n免责申明：本脚本仅供技术交流，请勿用于商业及非法用途，如产生法律纠纷与本人无关！使用后产生的一切后果由使用者自行承担，本人概不负责。\n____\n\n== 使用方式\n\n[arabic]\n. F12 打开开发者工具\n. 选择控制台（console）\n. 粘贴源代码\n. 设置好参数，点击开始即可\n\n== 源代码\n\n[source,javascript]\n----\n/**\n* 回答问题\n*/\nfunction echo_question() {\n  if ($(\"#tmDialog_iframe\").length > 0) {\n    $.each($(\"#tmDialog_iframe\").contents().find(\"input[type='radio']\"),(index,value) => {\n      value.click()\n      if($(\"#tmDialog_iframe\").contents().find(\".exam_correct\").length > 0){\n        console.log(\"回答问题成功! 正确答案: \" + $(value).parent().text().trim())\n        setTimeout(() => {\n          $(\".popbtn_cancel\").click()\n        }, 1000)\n        return false\n      }\n    });\n    // 多选默认全选，不判断对错\n    $.each($(\"#tmDialog_iframe\").contents().find(\"input[type='checkbox']\"),(index,value) => {\n      value.click()\n      setTimeout(() => {\n          $(\".popbtn_cancel\").click()\n      }, 1000)\n    });\n  }\n}\n\nfunction echo_play_method () {\n   if ($(\"#echo-play-y\").prop(\"checked\")) {\n          $(\".line1bq\").click()\n   }\n}\n\n/**\n* 设置\n*/\nfunction echo_set () {\n  if($('#echo-sound-y').prop(\"checked\")){\n    $(\".volumeIcon\").click()\n  }\n  if($('#echo-rate-y').prop(\"checked\")){\n    $(\"[rate='1.5']\").click()\n  }\n}\n\n/**\n* 开始\n*/\nfunction echo_cow () {\n  echo_play = !echo_play;\n  if (echo_play) {\n      echo_tip.text(\"停止\");\n      echo_status.text(\"状态: 运行中...\");\n      $('.playButton').click()\n      echo_play_method()\n      setTimeout(() => {\n        echo_set()\n      }, 1000)\n      echo_get()\n      echo_id = setInterval(echo_get,$('#echo-time').val() * 1000)\n      console.log(\"运行中...\")\n  } else {\n      echo_tip.text(\"start\")\n      echo_status.text(\"状态: 已停止...\")\n      window.clearInterval(echo_id)\n      console.log(\"已停止\")\n  }\n}\n\n/**\n* 检测\n*/\nfunction echo_get () {\n  console.log((++echo_times) + \" times run...\");\n  echo_question()\n  if ($('.passTime').css(\"width\") == '100%' || $(\".progressbar_box_tip\").html().indexOf(\"100%\") > 0) {\n    $(\"#nextBtn\").click()\n    setTimeout(() => {\n      echo_play_method()\n    }, 1000)\n    setTimeout(() => {\n      echo_set()\n    }, 3000)\n  }\n}\n\n\nvar echo_box = $(\"<div style='background: wheat;padding: 20px;'><h4 style='margin: 0;'>欢迎使用! By: <u><i><a style='color: coral' href='https://www.echocow.cn' target='_blank'>EchoCow</a></i></u></h4><h4 id='echo_status' style='margin: 0;'>当前状态: 停止...</h4><h4 style='margin: 0;'>现在，你可以选择 <button id='echo_tip' onclick='echo_cow()'>开始</button></h4></div>\");\nvar echo_setting = $(\"<div style='background:wheat;padding:20px;'><p>设置</p><div><label for='echo-time'>运行间隔：</label><input type='number' name='echo-time' id='echo-time' value='10'>秒</div><div>是否关闭声音：<label for='echo-sound-y'><input id='echo-sound-y' name='echo-sound' type='radio' checked='true'>是</label><label for='echo-sound-n'><input id='echo-sound-n' name='echo-sound' type='radio'>否 </label></div><div>是否1.5倍速播放：<label for='echo-rate-y'><input id='echo-rate-y' name='echo-rate' type='radio' checked='true'>是</label><label for='echo-rate-n'><input id='echo-rate-n' name='echo-rate' type='radio'>否 </label></div><div>是否流畅模式播放：<label for='echo-play-y'><input id='echo-play-y' name='echo-play' type='radio'>是</label><label for='echo-play-n'><input id='echo-play-n' name='echo-play' type='radio' checked='true'>否 </label></div></div>\")\n$('.main_right').prepend(echo_box)\n$('.main_right').prepend(echo_setting)\nvar echo_tip = $('#echo_tip')\nvar echo_status = $('#echo_status')\nvar echo_id\nvar echo_times = 0\nvar echo_play = false\n$(\".main_right\").css(\"overflow\", \"auto\")\nconsole.clear()\nconsole.log(\"初始化成功!请点击开始按钮开始...\")\n----\n\n== 截图\n\nimage:https://resources.echocow.cn/file/2019/4/8/Peek%202019-04-08%2011-39.gif[image]\n\n刚刚才发现我朋友也写了=-=早半个小时看到我就懒得写了啊！！！尴尬，见\nhttp://www.rainss.cn/essay/1104.html[rainss]。祝大家刷课愉快哦哈哈哈哈～～～\n\n","fields":{"slug":"/articles/2019/04/07/1554643306922.html","birthTime":"2019-04-07T13:21:46.973Z","modifiedTime":"2019-05-27","year":2019},"document":{"title":"智慧树/知到 自动看课脚本 ——js版"}},{"content":"= spring data rest 缓存/spring boot Jpa 二级缓存 ehcache 与 redis\n:page-description: spring data rest 缓存/spring boot Jpa 二级缓存 ehcache 与 redis\n:page-category: spring\n:page-image: https://img.hacpai.com/bing/20180104.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2019/04/13/1555159292055.html\n:page-created: 1555159292107\n:page-modified: 1555159594507\n:toc:\n\n这两天都在为学校的项目做准备，期间也遇到了很多问题，比如自己写代码生成器，比如授权这些，发现自己还是有点太弱了。但是最为棘手的莫过于缓存的问题。主要原因还是自己太想用\nspring data rest\n了，这个在假期就没有解决缓存的问题，现在还是要来再次面对，不过相隔几个月，今非昔比。\n\n== 问题分析\n\n项目直接使用 spring data rest 进行资源暴露，repository\n完全接手，所以我舍去了 service 层，controller\n也基本没有方法，就算有也被抽象出来了。那么没有 service\n如何做缓存呢？那就是用他 Jpa 底层实现的 hibernate\n了，一级缓存我们是默认开启的，那么我们就要使用 *二级缓存* 来提高性能。\n\n== 使用 ehcache\n\n第一种方式就是使用非常快速的 ehcache 来提高性能，配合 hibernate-jcache\n使用，就可以达到很好的效果，具体如下：\n\n1、 引入依赖，没有加上版本号是因为 spring boot\n的版本管理会自动下载合适的版本。\n\n[source,xml]\n----\n        <!--ehcache-->\n        <dependency>\n            <groupId>org.hibernate</groupId>\n            <artifactId>hibernate-jcache</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.ehcache</groupId>\n            <artifactId>ehcache</artifactId>\n        </dependency>\n----\n\n2、 添加 `ehcache.xml` 配置文件\n\n[source,xml]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<eh:config\n        xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'\n        xmlns:eh='http://www.ehcache.org/v3'\n        xsi:schemaLocation=\"http://www.ehcache.org/v3 http://www.ehcache.org/schema/ehcache-core-3.3.xsd\">\n    <eh:persistence directory=\"${java.io.tmpdir}/lesson-cloud-cache-data\"/>\n\n    <eh:cache-template name=\"default\">\n        <eh:expiry>\n            <eh:ttl unit=\"seconds\">600</eh:ttl>\n        </eh:expiry>\n        <eh:resources>\n            <!--堆内内存可以放2000个条目，超出部分堆外100MB-->\n            <eh:heap unit=\"entries\">2000</eh:heap>\n            <eh:offheap unit=\"MB\">100</eh:offheap>\n        </eh:resources>\n    </eh:cache-template>\n</eh:config>\n----\n\n3、 添加 `hibernate.properties` 配置文件\n\n\n[source,properties]\n....\nhibernate.format_sql=true\nhibernate.cache.use_second_level_cache=true\nhibernate.cache.use_query_cache=true\nhibernate.cache.region_prefix=gzmu_lesson_cloud_\nhibernate.cache.region.factory_class=org.hibernate.cache.jcache.JCacheRegionFactory\nhibernate.cache.provider_configuration_file_resource_path=ehcache.xml\nhibernate.cache.use_structured_entries=true\nhibernate.generate_statistics=false\nhibernate.javax.cache.missing_cache_strategy=create\n....\n\n如果你不喜欢使用 `properties` 文件，可以在 `application.yml` 里面配置\n\n[source,yaml]\n----\nspring:\n  jpa:\n    show-sql: true\n    properties:\n      hibernate:\n        generate_statistics: true\n        javax:\n          cache:\n            missing_cache_strategy: create\n        cache:\n          format_sql: true\n          use_second_level_cache: true\n          use_query_cache: true\n          region:\n            factory_class: org.hibernate.cache.jcache.JCacheRegionFactory\n          region_prefix: lesson_cloud_\n          use_structured_entries: true\n          provider_configuration_file_resource_path: ehcache.xml\n----\n\n4、 不需要在 service 层添加注解，而是在实体类添加注解，如下：\n\n[source,java]\n----\n@Data\n@Cacheable // 缓存\n@Table(name = \"sys_log\")\n@Entity(name = \"sys_log\")\n@Where(clause = \"is_enable = 1\")\n@EqualsAndHashCode(callSuper = true)\n@Cache(region = \"sys_log\", usage = CacheConcurrencyStrategy.READ_WRITE ) // 缓存名字以及策略\npublic class SysLog extends BaseEntity {\n    // ...\n}\n----\n\n____\n默认对查询的列表不缓存，一方面是因为命中率低，另一方面查询的列表会因为其中的一个改变就要销毁，操作频繁，没有缓存的必要。\n____\n\n== 使用 redis\n\n这个是真的搞了好久，因为系统涉及到分布式，所以使用 ehcache\n肯定是不太好的，所以要把它缓存\nredis。一开始自己尝试了很多办法，自己尝试实现一个缓存机制（效率太低并且代码不忍直视）。所以就想到去找别人的，所以在\ngithub 上一搜真的有，找到一个\nhttps://github.com/debop/hibernate-redis[hibernate-redis]，但是一使用发现很多很多问题，然后自己一个一个的排除，最后遇到一个无法解决的问题\n\n\n[source,none]\n....\njava.lang.IncompatibleClassChangeError: Expected static method org.hibernate.cache.internal.DefaultCacheKeysFactory.createEntityKey(Ljava/lang/Object;Lorg/hibernate/persister/entity/EntityPersister;Lorg/hibernate/engine/spi/SessionFactoryI\n....\n\n然后发现这个问题是个 bug，已经在未来的版本解决，见\nhttps://github.com/debop/hibernate-redis/issues/115[issue]，\n由于没有上传到 maven 仓库，需要自己切换到 2.4\n版本的分支自己构建自己打包，并且还要用本地 jar\n导入的方式导入，实在太过麻烦，暂时放弃。\n\n然后找资料，网上乱七八糟的一大堆，没一个有用的，重复的还非常多。最后又回到\nhibernate-redis，然后查看的时候发现了他引用了 redisson\n的依赖，就很好奇这个是什么，然后去 https://redisson.org/[官网]\n看了下，发现他是一个 java 的 redis client，可以通过它来操作\nredis，并且观望上给出的标语 > Redis based cache implementations for Java\nlike JCache API, Hibernate 2nd Level Cache, Spring Cache and application\nlevel caching.\n\n他也可以作为 JCache API, Hibernate, Spring Cache\n的二级缓存，那么是不是意味着我可以用它呢？于是去他的\nhttps://github.com/redisson/redisson/wiki/14.-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88[github\nwiki] 看了下，果然有！而且还有 spring cache\n的！不过我们不用，因为我们不用那几个注解来进行缓存控制，而是通过\nhibernate，所以我尝试一下，完美整合！\n\n1、 导入依赖，不同的是，我们导入的不是 `redisson` 的依赖，而是\n`redisson-hibernate` ，这里算是坑到我了，导入 `redisson` 没用，然后去\nmaven 中央仓库逛了一波才发现\n`redisson-hibernate`，然后尝试了一波才发现居然可以。\n\n[source,xml]\n----\n<!-- 注意先导入你的 hibernate-core -->\n<dependency>\n    <groupId>org.redisson</groupId>\n    <!-- 对于 Hibernate v4.x -->\n    <artifactId>redisson-hibernate-4</artifactId>\n    <!-- 对于 Hibernate v5.0.x - v5.1.x -->\n    <artifactId>redisson-hibernate-5</artifactId>\n    <!-- 对于 Hibernate v5.2.x -->\n    <artifactId>redisson-hibernate-52</artifactId>\n    <!-- 对于 Hibernate v5.3.x - v5.4.x -->\n    <artifactId>redisson-hibernate-53</artifactId>\n    <version>3.10.6</version>\n</dependency>\n----\n\n2、 添加 `hibernate.properties` 如下\n\n[source,properties]\n----\nhibernate.format_sql=true\nhibernate.cache.use_second_level_cache=true\nhibernate.cache.use_query_cache=true\nhibernate.cache.region_prefix=gzmu_lesson_cloud_\nhibernate.cache.region.factory_class=org.redisson.hibernate.RedissonRegionFactory\nhibernate.cache.redisson.config=redisson.yaml\nhibernate.cache.use_structured_entries=true\nhibernate.generate_statistics=false\nhibernate.javax.cache.missing_cache_strategy=create\n----\n\n3、 添加 `redisson.yaml` 如下\n\n[source,yaml]\n----\n# 配置参见 https://github.com/redisson/redisson/wiki/2.-%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95\n\n# 单节点设置，其余模式待测试\nsingleServerConfig:\n  idleConnectionTimeout: 10000\n  pingTimeout: 1000\n  connectTimeout: 1000\n  timeout: 1000\n  retryAttempts: 1\n  retryInterval: 1000\n  reconnectionTimeout: 3000\n  failedAttempts: 5\n  password: null\n  subscriptionsPerConnection: 5\n  clientName: null\n  address: \"redis://127.0.0.1:6379\"\n  subscriptionConnectionMinimumIdleSize: 1\n  subscriptionConnectionPoolSize: 25\n  connectionMinimumIdleSize: 5\n  connectionPoolSize: 100\n  database: 0\nthreads: 0\n# Codec\ncodec: !<org.redisson.codec.SnappyCodec> {}\neventLoopGroup: null\n----\n\n4、 同样，实体类添加注解\n\n[source,java]\n----\n@Data\n@Cacheable // 缓存\n@Table(name = \"sys_log\")\n@Entity(name = \"sys_log\")\n@Where(clause = \"is_enable = 1\")\n@EqualsAndHashCode(callSuper = true)\n@Cache(region = \"sys_log\", usage = CacheConcurrencyStrategy.READ_WRITE ) // 缓存名字以及策略\npublic class SysLog extends BaseEntity {\n    // ...\n}\n----\n\n5、 测试即可\n\n不过在使用的时候发现 `redisson-hibernate-53` 比 `redisson-hibernate-52`\n少了一些包，其查看 jar 结构的时候会很奇怪\n\nimage::https://resources.echocow.cn/file/2019/4/13/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190413103247.png[redisson-hibernate-52]\n\nimage::https://resources.echocow.cn/file/2019/4/13/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190413103214.png[redisson-hibernate-53]\n\n使用的时候优势会出问题有时候不会，一开始提示找不到类，试了很多次，后来莫名其妙又可以了。。。。\n\n=== 更细致化配置\n\n使用 yaml 进行配置\n\n[source,yaml]\n----\nspring:\n  jpa:\n    show-sql: true\n    properties:\n      hibernate:\n        cache:\n          redisson:\n            config: redisson.yaml\n          region:\n            factory_class: org.redisson.hibernate.RedissonRegionFactory\n          region_prefix: gzmu_lesson_cloud_\n          use_query_cache: true\n          use_second_level_cache: true\n          use_structured_entries: true\n          provider_configuration_file_resource_path: classpath:conf/hibernate-redis.properties\n        format_sql: true\n        generate_statistics: false\n        javax:\n          cache:\n            missing_cache_strategy: create\n----\n\n添加 `hibernate-redis.properties`\n\n\n[source,properties]\n....\n##########################################################2\n#\n# properities for hibernate-redis 可以在这里进行更加细致化的 redis 配置\n#\n##########################################################\n\n# Redisson configuration file\nredisson-config=classpath:conf/redisson.yaml\n\n# Cache Expiry settings\n# 'hibernate' is second cache prefix\n# 'common', 'account' is actual region name\nredis.expiryInSeconds.default=120\nredis.expiryInSeconds.hibernate.common=0\nredis.expiryInSeconds.hibernate.account=1200\n....\n\n`redisson` 配置同上\n\n____\n值得注意的是，redis 同样不会缓存查询的列表，理由同上。\n____\n\n=== 总结\n\n搞这个搞了一天多才成功，集群还没尝试，不过应该不难了，还是需要多多熟悉才行啊。\n\n","fields":{"slug":"/articles/2019/04/13/1555159292055.html","birthTime":"2019-04-13T12:41:32.107Z","modifiedTime":"2019-04-13","year":2019},"document":{"title":"spring data rest 缓存/spring boot Jpa 二级缓存 ehcache 与 redis"}},{"content":"= Manjaro 安装 rabbitmq\n:page-description: Manjaro 安装 rabbitmq\n:page-category: linux\n:page-image: https://img.hacpai.com/bing/20180516.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2019/05/05/1557020097819.html\n:page-created: 1557020097956\n:page-modified: 1557717093123\n:toc:\n\n最近项目中使用了 https://www.rabbitmq.com/[rabbitmq] ，我是 manjaro\n系统，记录一下安装的过程。\n\n== pacman 安装\n\n作为 arch 衍生版，最大的好处就是他庞大的软件仓库了～安装是极其方便的\n\n\n[source,bash]\n....\n# 使用 pacman\nsudo pacman -S rabbitmq rabbitmqadmin\n# 使用 yarourt\nyarourt -S rabbitmq rabbitmqadmin\n# 或自己选择相应的版本\nyarourt rabbitmq\n....\n\n启动\n\n[source,bash]\n....\n# 开启管理模块\nsudo rabbitmq-plugins enable rabbitmq_management\n# 启动\nsudo rabbitmq-server\n....\n\n启动报错\n\n[source,none]\n....\n   args: []\n   format: \"Error when reading /var/lib/rabbitmq/.erlang.cookie: eacces\"\n   label: {error_logger,error_msg}\n   2019-05-05 09:16:40.312473 crash_report        #{label=>{proc_lib,crash},report=>[[{initial_call,{auth,init,['Argument__1']}},{pid,<0.59.0>},{registered_name,[]},{error_info,{error,\"Error w\nhen reading /var/lib/rabbitmq/.erlang.cookie: eacces\",[{auth,init_cookie,0,[{file,\"auth.erl\"},{line,286}]},{auth,init,1,[{file,\"auth.erl\"},{line,140}]},{gen_server,init_it,2,[{file,\"gen_ser\nver.erl\"},{line,374}]},{gen_server,init_it,6,[{file,\"gen_server.erl\"},{line,342}]},{proc_lib,init_p_do_apply,3,[{file,\"proc_lib.erl\"},{line,249}]}]}},{ancestors,[net_sup,kernel_sup,<0.46.0>\n]},{message_queue_len,0},{messages,[]},{links,[<0.57.0>]},{dictionary,[]},{trap_exit,true},{status,running},{heap_size,987},{stack_size,27},{reductions,937}],[]]}\n2019-05-05 09:16:40.312741 supervisor_report   #{label=>{supervisor,start_error},report=>[{supervisor,{local,net_sup}},{errorContext,start_error},{reason,{\"Error when reading /var/lib/rabbi\ntmq/.erlang.cookie: eacces\",[{auth,init_cookie,0,[{file,\"auth.erl\"},{line,286}]},{auth,init,1,[{file,\"auth.erl\"},{line,140}]},{gen_server,init_it,2,[{file,\"gen_server.erl\"},{line,374}]},{ge\nn_server,init_it,6,[{file,\"gen_server.erl\"},{line,342}]},{proc_lib,init_p_do_apply,3,[{file,\"proc_lib.erl\"},{line,249}]}]}},{offender,[{pid,undefined},{id,auth},{mfargs,{auth,start_link,[]}\n},{restart_type,permanent},{shutdown,2000},{child_type,worker}]}]}\n......\n....\n\n解决，问题在于\n`Error when reading /var/lib/rabbitmq/.erlang.cookie: eacces`，修改权限即可\n\n[source,bash]\n....\nsudo chown rabbitmq:rabbitmq /var/lib/rabbitmq/.erlang.cookie\nsudo chmod 600 /var/lib/rabbitmq/.erlang.cookie\n....\n\n启动\n\n[source,bash]\n....\nsudo rabbitmq-server\n....\n\n== docker 安装 —— 推荐\n\n安装\n\n[source,bash]\n....\ndocker pull rabbitmq:3.7-management\n....\n\n启动\n\n[source,bash]\n....\ndocker run -d --hostname localhost --name myrabbit -p 15672:15672 -p 5672:5672 rabbitmq:3.6.15-management\n....\n\n* -d 后台进程运行\n* hostname RabbitMQ主机名称\n* name 容器名称\n* -p port:port 本地端口:容器端口\n* -p 15672:15672 http访问端口\n* -p 5672:5672 amqp访问端口\n\n== 测试\n\n访问 http://127.0.0.1:15672 ，默认账号密码 guest。\n\n","fields":{"slug":"/articles/2019/05/05/1557020097819.html","birthTime":"2019-05-05T01:34:57.956Z","modifiedTime":"2019-05-13","year":2019},"document":{"title":"Manjaro 安装 rabbitmq"}},{"content":"= spring boot freemarker 制作专属代码生成器\n:page-description: spring boot freemarker 制作专属代码生成器\n:page-category: spring\n:page-image: https://img.hacpai.com/bing/20181008.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2019/05/10/1557456119712.html\n:page-created: 1557456119788\n:page-modified: 1557711427906\n:toc:\n\n最近在做学校的项目，自己从零开始一步一步搭建与设计，遇到了一堆的问题，不过也感觉到了自己在不断成长，只有在实践中才会发现会有那么多的问题存在。记录一下遇到的一个典型的问题，*代码生成*。因为项目使用的是\nspring data jpa 而不是 mybatis，所以并没有 mybatis-plus\n的代码生成器，就寻思自己写一个了。\n\n____\n实例地址：https://github.com/lizhongyue248/spring-boot-freemarker-generate[spring-boot-freemarker-generate]\n\n项目模块：https://github.com/gzmuSoft/lesson-cloud/tree/master/lesson-cloud-generate[lesson-cloud-generate]\n\n博客地址：https://echocow.cn[EchoCow]\n____\n\n== 这篇文章能够带给你什么\n\n[arabic]\n. spring boot 配置文件读取\n. spring boot 与 freemarker 的最佳实践\n. 如何从数据库中读取到有用的元数据和表信息\n. spring boot 事件监听机制\n. spring boot starter freemarker 的分析与探究\n\n期间遇到了很多问题，网上搜寻了半天，都没有使用 spring boot + freemarker\n来只做模板引擎的，我的思路其实来源于他的源码，具体后面会说。一开始准备单独写的，但是发现如果需要读取配置文件又要去找一堆库，还有一些工具类，为什么不直接用\nspring boot 呢？当然还有以下的一些原因\n\n[arabic]\n. 项目使用 spring boot 构建，父项目直接继承 spring\nboot，子项目用起来很方便。\n. spring boot 配置文件读取方便，比较熟悉他的使用。\n. 优秀的的依赖注入很方便。\n. 依赖很少，不需要再去麻烦的找一些库\n\n总结起来就是一个词，方便！\n\n== 在这之前\n\n你需要构建一个 spring boot 项目，并且将他作为你的依赖管理。\n\n同时需要一些必备的依赖，我们只用需要的，尽可能的简化，只有如下几个：\n\n[source,xml]\n----\n<!--FreeMarker模板引擎依赖-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-freemarker</artifactId>\n</dependency>\n<!--mysql 驱动-->\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <scope>runtime</scope>\n</dependency>\n<!--主要用来读取配置文件-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-configuration-processor</artifactId>\n    <optional>true</optional>\n</dependency>\n<!--lombok 工具-->\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <optional>true</optional>\n</dependency>\n<!--测试依赖-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-test</artifactId>\n    <scope>test</scope>\n</dependency>\n----\n\n如果使用的是 idea,那么依赖如下\nimage:https://resources.echocow.cn/file/2019/05/10/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190509235702.png[dependency]\n\n== 开始\n\n现在我们需要明确一下如何完成这么一个生成的过程,\n\n[arabic]\n. 配置数据库并读取，连接数据库\n. 书写模板\n. 生成文件\n\n== 数据库\n\n=== 配置\n\n直接通过 spring-boot-configuration-processor\n来读取即可，非常简单的一个过程，我们需要一个 `application.yml` 或者\n`application.properties` 文件，我选择 `yml`，配置如下：\n\n[source,yml]\n----\napplication:\n  generate:\n    # 驱动类\n    driver-class: com.mysql.cj.jdbc.Driver\n    # 用户名\n    username: root\n    # 密码\n    password: 123456\n    # 库名\n    catalog: generate\n    # 数据库地址\n    url: jdbc:mysql://127.0.0.1:3306/generate\n----\n\n你可以发现下面飘黄色警告，别急，慢慢来。\n\nimage::https://resources.echocow.cn/file/2019/05/10/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190510001047.png[yml]\n\n我们需要一个实体类来和他对应\n\n[source,java]\n----\n@Data   // lombok 自动生成必要的方法\n@Component\n// 和配置文件前缀进行对应\n@ConfigurationProperties(prefix = \"application.generate\")\npublic class GenConfig {\n    /**\n     * 数据库驱动类\n     */\n    private String driverClass;\n\n    /**\n     * 数据库用户名\n     */\n    private String username;\n\n    /**\n     * 密码\n     */\n    private String password;\n\n    /**\n     * 库名\n     */\n    private String catalog;\n\n    /**\n     * 链接地址\n     */\n    private String url;\n\n}\n----\n\n使用一个测试类进行读取测试\n\n[source,java]\n----\nimport static org.junit.Assert.*;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class GenDemoApplicationTests {\n\n    @Autowired\n    private GenConfig genConfig;\n\n    @Test\n    public void contextLoads() {\n        assertNotNull(genConfig);\n        assertEquals(genConfig.getUsername(), \"root\");\n    }\n\n}\n----\n\n测试用例通过，配置读取是没有问题的。运行一次以后，你回去看配置文件，会发现没有警告了。\n\n=== 连接\n\n使用最简单 jdbc 链接，也是最快捷的方式。\n\n==== 获取数据库元数据\n\n其实就是获取数据库链接后获取元数据，jdbc 基础\n\n[source,java]\n----\n// 自动注入\nprivate final GenConfig genConfig;\n\npublic GenDatabaseUtil(GenConfig genConfig) {\n    this.genConfig = genConfig;\n}\n\n/**\n * 获取数据库元数据\n *\n * @return 元数据\n * @throws Exception 异常\n */\nprivate DatabaseMetaData getMetaData() throws Exception {\n    Class.forName(genConfig.getDriverClass());\n    return DriverManager.getConnection(genConfig.getUrl(),\n            genConfig.getUsername(), genConfig.getPassword()).getMetaData();\n}\n----\n\n然后获取所有的表\n\n[source,java]\n----\n/**\n * 获取库的所有表\n *\n * @return 所有表\n */\npublic List<String> getTables() {\n    List<String> tables = new ArrayList<>();\n    try {\n        ResultSet resultSet = getMetaData().getTables(genConfig.getCatalog(), null,\n                \"%\", new String[]{\"TABLE\"});\n        while (resultSet.next()) {\n            String tableName = resultSet.getString(\"TABLE_NAME\");\n            tables.add(tableName);\n        }\n        resultSet.close();\n    } catch (Exception e) {\n        log.error(\"Please check your database conf! {}\", e.getMessage());\n        e.printStackTrace();\n    }\n    return tables;\n}\n----\n\n测试一下方法\n\n[source,java]\n----\n@Autowired\nprivate GenDatabaseUtil genDatabaseUtil;\n\n@Test\npublic void testTables() {\n    // 直接打印了\n    genDatabaseUtil.getTables().forEach(System.out::println);\n}\n----\n\n==== 获取列信息\n\n然后我们需要一个实体类来和列进行对应\n\n[source,java]\n----\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class ColumnClass {\n    /**\n     * 表名称\n     */\n    private String tableName;\n    /**\n     * 列名称\n     */\n    private String columnName;\n    /**\n     * 列大小\n     */\n    private Integer columnSize;\n    /**\n     * 列的类型\n     */\n    private String columnType;\n    /**\n     * 列的注释\n     */\n    private String columnComment;\n    /**\n     * 是否能为空值\n     */\n    private Boolean nullAble;\n}\n----\n\n接着我们就需要一个方法来获取一个表的所有列，里面有一个自己写得工具类，请查看\ngithub，这个工具类封装了一些方法进行使用。\n\n[source,java]\n----\n/**\n * 获取指定表的所有列\n *\n * @param tableName 表名\n * @return 所有列的集合\n */\npublic List<ColumnClass> getColumns(String tableName) {\n    try (ResultSet resultSet = getMetaData().getColumns(genConfig.getCatalog(), null, tableName, \"%\")) {\n        return getColumns(resultSet, tableName);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n\n/**\n * 获取某列的结果集抽取\n *\n * @param resultSet 结果集\n * @param tableName 表名\n * @throws SQLException 异常\n */\nprivate List<ColumnClass> getColumns(ResultSet resultSet, String tableName) throws SQLException {\n    List<ColumnClass> columns = new ArrayList<>();\n    while (resultSet.next()) {\n        String columnName = resultSet.getString(\"COLUMN_NAME\");\n        String remarks = resultSet.getString(\"REMARKS\");\n        Boolean nullAble = resultSet.getInt(\"NULLABLE\") == 1;\n        columns.add(new ColumnClass(\n            tableName,\n            GenUtil.underlineToHump(columnName),\n            resultSet.getInt(\"COLUMN_SIZE\"),\n            GenUtil.fieldConversion(resultSet.getString(\"TYPE_NAME\")),\n            remarks, nullAble\n        ));\n    }\n    return columns;\n}\n----\n\n同样，测试一下\n\n[source,java]\n----\n@Test\npublic void testColumns() {\n    genDatabaseUtil.getColumns(\"user\").forEach(System.out::println);\n}\n\n// 结果\n// ColumnClass(tableName=user, columnName=id, columnSize=10, columnType=java.lang.Integer, columnComment=, nullAble=false)\n// ColumnClass(tableName=user, columnName=name, columnSize=255, columnType=java.lang.String, columnComment=, nullAble=false)\n// ColumnClass(tableName=user, columnName=pwd, columnSize=255, columnType=java.lang.String, columnComment=, nullAble=false)\n----\n\n这样就没有问题了。\n\n== 书写模板\n\n在 `resource` 下创建 `templates` 文件夹，同时创建一个 `entity.ftl` 的\n`freemarker` 文件：\n\n....\npackage ${package_name};\n\nimport lombok.Data;\n\nimport javax.persistence.Entity;\nimport javax.persistence.Table;\nimport java.io.Serializable;\n\n/**\n* ${table_name}\n*\n* @author echo cow\n* @date ${.now?datetime}\n*/\n@Data\n@Table(name = \"${table_name}\")\n@Entity(name = \"${table_name}\")\npublic class ${class_name} implements Serializable {\n<#list columns as column>\n\n    /**\n    * ${column.columnComment}\n    */\n    private ${column.columnType} ${column.columnName};\n</#list>\n}\n....\n\n== 生成模板\n\n生成模板有很多种方式，本质都是对 spring\n的应用进行监听，当他启动的时候调用某个时间或者进行监听。这里我使用实现\n`ApplicationRunner` 的方式，他会需要实现一个 `run`\n方法，通过实现这个方法，会在应用启动完成后调用此方法。\n\n先上成品代码：\n\n\n[source,java]\n....\n@Slf4j\n@Component\npublic class GenEntity implements ApplicationRunner {\n\n    // 读取配置文件\n    private final GenDatabaseUtil genDatabaseUtil;\n    //  FreeMarker 配置工程\n    private final FreeMarkerConfigurationFactory freeMarkerConfigurationFactory;\n\n    public GenEntity(GenDatabaseUtil genDatabaseUtil, FreeMarkerConfigurationFactory freeMarkerConfigurationFactory) {\n        this.genDatabaseUtil = genDatabaseUtil;\n        this.freeMarkerConfigurationFactory = freeMarkerConfigurationFactory;\n    }\n\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        Configuration configuration = freeMarkerConfigurationFactory.createConfiguration();\n        // 他会自己寻找 resources 下的 templates 目录下的模板文件\n        Template entityTemplate = configuration.getTemplate(\"entity.ftl\");\n        // 获取数据库所有表\n        List<String> tables = genDatabaseUtil.getTables();\n        // 存放模板变量\n        Map<String, Object> data = new HashMap<>();\n        data.put(\"package_name\", \"cn.echocow.generate.entity\");\n        // 文件写入\n        FileWriter fileWriter;\n        for (String table : tables) {\n            // 工具类将下划线命名转化为驼峰\n            String entityClassName = GenUtil.underlineToHump(table, true);\n            data.put(\"table_name\", table);\n            data.put(\"class_name\", entityClassName);\n            // 获取当前表的所有列\n            data.put(\"columns\", genDatabaseUtil.getColumns(table));\n            // 文件创建\n            File file = new File(\"src/main/java/cn/echocow/gendemo/entity/\" + GenUtil.underlineToHump(table, true) + GenUtil.SUFFIX);\n            if (!file.exists()) {\n                if (!new File(\"src/main/java/cn/echocow/gendemo/entity\").mkdirs()) {\n                    log.error(\"创建文件夹失败\");\n                    return;\n                }\n                if (!file.createNewFile()) {\n                    log.error(\"{} 创建文件失败\", table);\n                    return;\n                }\n            }\n            fileWriter = new FileWriter(file);\n            entityTemplate.process(data, fileWriter);\n            log.info(\"Table {} generate succeed!\", table);\n        }\n    }\n}\n....\n\n=== 探究过程\n\n*其实对于一个生成的过程，就是一个 `模板 + 数据`\n组合的过程，对于任何模板引擎都是如此，需要获取到一个模板，然后讲数据带过去，模板引擎使用数据对页面进行渲染，就是这么一个过程。所以我们就需要很重要的两个东西*\n- 模板 —— template - 数据 —— 直接使用 map 携带过去\n\n所以我们在引入的 freemarker 依赖中，可以找到\n`freemarker.template.Template` 这么一个类，来看看他远吗的注释\n\nimage::https://resources.echocow.cn/file/2019/05/10/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190510093223.png[tempalte]\n\n所以他提供了两种方式来创建 template 1.\n`use Configuration#getTemplate(String) to create/get Template objects`\n=> 使用 Configuration 的 getTemplate 方法来进行创建。 2.\n`you can also construct a template from a Reader or a String that contains the template source code`\n=> 使用他的构造方法来进行创建。\n\n然后我去查询 Configuration\n类，里面有的只是如何使用，有兴趣的可以自己去看看，但是如何在 spring boot\n中使用呢？这个时候我就想到了我们引入的 `spring-boot-starter-freemarker`\n依赖，既然有 Starter\n依赖，那么必定就会有相应的自动配置，所以我们需要去找寻一下他自动装配的\nBean 在哪里。如果你了解 spring boot\n自动装配的话，应该能够找到，直接在在自动装配的文件中，直接搜索就可以找到如下地方：\n\nimage::https://resources.echocow.cn/file/2019/05/10/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190510094443.png[search]\n\n那么我们继续看看这个类\n\nimage::https://resources.echocow.cn/file/2019/05/10/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190510095002.png[FreeMarkerAutoConfiguration]\n\n他的核心就是条件装配，当我们没有引入 freemarker\n的时候，是不会进行自动配置的；同时他引入了三个配置，分别如下 -\n`FreeMarkerServletWebConfiguration` 对于 servlet web 环境下进行自动配置\n- `FreeMarkerReactiveWebConfiguration` 对于 reactive web\n环境下进行自动配置 - `FreeMarkerNonWebConfiguration` 对于 non web\n环境想进行自动配置\n\n我们现在是 non web 环境，我们只用看 `FreeMarkerNonWebConfiguration`\n即可，其他两个是不会进行自动装配的。里看看这个类\n\nimage::https://resources.echocow.cn/file/2019/05/10/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190510095915.png[FreeMarkerNonWebConfiguration]\n\n你会发现他就自动装配了一个 Bean，在我们没有配置\n`FreeMarkerConfigurationFactoryBean` 的时候，\n进行自动装配。所以他的核心就是\n`FreeMarkerConfigurationFactoryBean`，来看看这个类\n\nimage::https://resources.echocow.cn/file/2019/05/10/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190510100627.png[FreeMarkerConfigurationFactoryBean]\n\n他已经说的十分清楚了，我们直接来看\n`FreeMarkerConfigurationFactor`,上面的注释非常清楚，我们直接来看需要的方法\n\nimage::https://resources.echocow.cn/file/2019/05/10/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190510100912.png[FreeMarkerConfigurationFactor]\n\n通过这个类的 `createConfiguration` 方法我们可以创建一个 `Configuration`\n配置，然后通过他的 `getTemplate` 方法可以获取到 `Template`\n\nimage::https://resources.echocow.cn/file/2019/05/10/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190510101233.png[Configuration]\n\n他使用多态，创建一个默认的\n`Template`，对于我们来说够用了，所以在上面的生成的代码中，我们直接注入\n`FreeMarkerConfigurationFactory` 使用即可。\n\n[source,java]\n----\nConfiguration configuration = freeMarkerConfigurationFactory.createConfiguration();\nTemplate entityTemplate = configuration.getTemplate(\"entity.ftl\");\n----\n\n对于数据就是一个 map 而已，封装好后使用 `process` 方法生成即可，需要一个\n`Writer`\n的子类，可以自由选择。具体去查看下他的源码就知道了，都很好找到，主要调用的是\n`createProcessingEnvironment(Object dataModel, Writer out)` 这个方法。\n\n[source,java]\n----\nMap<String, Object> data = new HashMap<>(4);\nFileWriter fileWriter = new FileWriter(file);\nentityTemplate.process(data, fileWriter);\n----\n\n== 工具类\n\n[source,java]\n----\n@Slf4j\npublic class GenUtil {\n    private static final String UNDERLINE = \"_\";\n    private static final Map<String, String> MYSQL_TO_JAVA = new HashMap<>();\n    public static final String SUFFIX = \".java\";\n\n    static {\n        MYSQL_TO_JAVA.put(\"VARCHAR\", \"java.lang.String\");\n        MYSQL_TO_JAVA.put(\"BIGINT\", \"java.lang.Long\");\n        MYSQL_TO_JAVA.put(\"DATE\", \"java.time.LocalDate\");\n        MYSQL_TO_JAVA.put(\"FLOAT\", \"java.lang.Float\");\n        MYSQL_TO_JAVA.put(\"TINYINT\", \"java.lang.Integer\");\n        MYSQL_TO_JAVA.put(\"INT\", \"java.lang.Integer\");\n        MYSQL_TO_JAVA.put(\"BINARY\", \"java.lang.Byte\");\n        MYSQL_TO_JAVA.put(\"SMALLINT\", \"java.lang.Short\");\n        MYSQL_TO_JAVA.put(\"DATETIME\", \"java.time.LocalDateTime\");\n        MYSQL_TO_JAVA.put(\"BIT\", \"java.lang.Boolean\");\n    }\n\n\n    /**\n     * 下划线命名转驼峰式命名\n     *\n     * @param para 下划线命名\n     * @return 驼峰式命名\n     */\n    public static String underlineToHump(String para) {\n        StringBuilder result = new StringBuilder();\n        for (String s : para.split(UNDERLINE)) {\n            if (!para.contains(\"_\")) {\n                result.append(s);\n                continue;\n            }\n            if (result.length() == 0) {\n                result.append(s.toLowerCase());\n            } else {\n                result.append(s.substring(0, 1).toUpperCase());\n                result.append(s.substring(1).toLowerCase());\n            }\n        }\n        return result.toString();\n    }\n\n    /**\n     * 下划线命名转驼峰式命名\n     *\n     * @param para            下划线命名\n     * @param firstCharChange 首字母是否转换\n     * @return 驼峰式命名\n     */\n    public static String underlineToHump(String para, boolean firstCharChange) {\n        String result = underlineToHump(para);\n        return firstCharChange ? result.substring(0, 1).toUpperCase() + result.substring(1) : result;\n    }\n\n    /**\n     * 数据库字段转换\n     *\n     * @param mysqlDataType 数据库字段类型\n     * @return 转换结果\n     */\n    public static String fieldConversion(String mysqlDataType) {\n        return MYSQL_TO_JAVA.getOrDefault(mysqlDataType, \"Object\");\n    }\n\n\n}\n----\n\n== 总结\n\n其实还是很简单的，只要了解了 spring boot\n的自动装配机制，找到他对某个库是如何支持的，那么思路就会很畅通，然后就可以在他的基础上来做更多的事情。当然这个是简化版的代码生成，其实还可以做很多自定义化，比如在我们项目中就增加了下面的功能：\n\n[arabic]\n. 指定生成的模块\n. 自定义各种配置\n. 指定生成时排除某些表\n. 指定生成时排除某些列\n. 指定生成时按照条件添加某些注解\n. ……\n\n同样，如果你对于 `spring` 的事件熟悉的话，可以自定义生成顺序，比如\n`@Order` 注解，比如使用 `SpringApplicationBuilder`\n自己启动并添加事件监听都是可行的。\n\n不过如果有多个代码生成的话，就会有设计方面的问题，如何设计才能够更优雅而没有一堆重复的代码。我在当初就没考虑到这个问题，写出来的代码可维护性就很差，自己重构半天出现更多的问题=-=然后暂时放弃重构，后面再说吧～～\n\n","fields":{"slug":"/articles/2019/05/10/1557456119712.html","birthTime":"2019-05-10T02:41:59.788Z","modifiedTime":"2019-05-13","year":2019},"document":{"title":"spring boot freemarker 制作专属代码生成器"}},{"content":"= [阅读] 计算机网络 自顶向下方法 —— 计算机网络和因特网\n:page-description: [阅读] 计算机网络 自顶向下方法 —— 计算机网络和因特网\n:page-category: 阅读\n:page-image: https://img.hacpai.com/bing/20180311.jpg?imageView2/2/w/1280/format/jpg/interlace/1/q/100\n:page-href: /articles/2019/05/19/1558277640118.html\n:page-created: 1558277640169\n:page-modified: 1558277658989\n:toc:\n\n这次选择的读书任务是一本非常好的书 —— 计算机网络\n自顶向下方法。为什么选择这本书？缘由是因为自己的一个好朋友，有一次问我计算机网络的题目，这本身没有什么，事实上我也做出来了。但是后面给他讲题目的时候，他打破砂锅问到底，比如计算子网掩码需要主机号和网络号，就一定要问清楚什么时主机号什么是网络号，IP\n地址为什么叫 IP 地址，MAC 为什么叫\nMAC，子网掩码为什么叫子网掩码。问这些把我问的哑口无言，然后发现自己只是为了考试而学习，这本身以及脱离了我的学习的兴趣范畴，所以我决定重新学习一遍计算机网络，在我再次回顾谢希仁的计算机网络的时候发现，他许多概念也是突然就冒出来了，也就是没有经过任何解释突然冒出来的一个专业术语，让我对这本书好感突降。所以重新选择了一本，也就是现在的\n计算机网络 自顶向下方法，今天开始阅读第一章。\n\n== 因特网 Internet\n\n从两个方面来阐述因特网\n\n=== 具体构成描述\n\n*从构成因特网的基本硬件和软件组件定义：因特网将端系统彼此互联*\n\n* 主机/端系统 host/endsystem：正在与因特网相连的设备\n* 端系统通过 通信链路 和 分组交换机 连接在一起\n* 通信链路 communication\nlink：由不同类型的物理媒体组成，不同的链路能够以不同的速率传输数据。传输速率\n比特/秒(bit/s,或bps)\n* 分组 packet：发送端系统将数据分段，并为每段加上首部字节，形成信息包。\n* 分组交换机 packet\nswitch：从他的一条入通信链路接受到达的分组，并从他的一条出通信链路转发该分组。\n** 路由器 router —— 网络核心\n** 链路层交换机 link-layer switch —— 接入网\n* 路径\nroute/path：从发送端到接收端，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径\n* 因特网服务提供商 ISP：端系统接入因特网\n* 协议 protocol：控制因特网中信息的接受和发送\n* 请求评论\nRPC：因特网工程任务组（IETF）的标准文档，目的是解决因特网先驱者们面临的网络和协议问题。\n\nimage::https://resources.echocow.cn/file/2019/05/19/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190518125013.png[概念]\n\n=== 服务描述\n\n*从为应用程序提供服务的基础设施定义：因特网作为应用程序的平台*\n\n* 分布式应用 distributed\napplication：涉及多个相互交换数据的端系统的应用程序\n* 套接字接口 socket\ninterface：与因特网相连的端系统提供一个套接字接口，规定了运行在一个端系统上的程序请求因特网基础设施向另一个端系统上的特定目的地程序交付数据的方式。他是一套发送程序必须遵守的规则集合。\n\nimage::https://resources.echocow.cn/file/2019/05/19/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190518125350.png[套接字]\n\n== 协议 Protocol\n\n定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和/或接受一条报文或其他时间所采取的动作。\n\n== 网络边缘\n\n*即我们日常使用的计算机、智能手机和其他设备。*\n\n* 边缘路由器：端系统到任何其他远程端系统的路径上的第一台路由器。\n* 接入网：将端系统物理连接到 边缘路由器\n* 家庭接入：DSL、电缆、FTTH、拨号和卫星\n* 本地电话/公司的中心局：光纤线路端接器 OLT\n* 企业(和家庭)接入：以太网和 WIFI\n* 广域网接入：3G 和 LTE\n\n=== DSL：数字用户线\n\n* DSL 调制解调器\n* DSL 复用器 DSLAM\n\n=== 电缆：光纤/同轴电缆(混合光纤同轴HFC)\n\n* 电缆调制解调器\n* 电缆调制解调器端接系统 CMTS\n\n*主要特征：共享广播媒体*\n\n=== FTTH：光纤到户\n\n* 主动光纤网络 AON\n* 被动光纤网络 PON\n* 家庭：光纤网络端接器 ONT\n\n=== 物理媒体\n\n* 导引型媒体：电波随着固体媒体前行。如光缆、双绞铜线或同轴电缆。\n* 双绞铜线：最便宜、最常用\n* 同轴电缆：较高的传输速率\n* 光纤：细而柔软的、能够导引光脉冲的媒体。不受电磁干扰，很难窃听\n* 非导引型媒体：电波在空气或外层空间中传播，如无线局域网或数字卫星频道中。\n* 陆地无线电信通\n* 卫星无线电信通\n\n== 网络核心\n\n*即由互联因特网端系统的分组交换机和链路构成的网状网络*\n\n* 报文\nmessage：能够包含协议设计者需要的任何东西，称之为报文。端系统彼此交换报文\n* 分组 packet：源将长报文划分为较小的数据块，称之为分组\n* 分组交换 packet switching\n* 电路交换 circuit switching\n\n=== 分组交换\n\n* 存储转发传输：指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分存储转发传输组。\n* 端到端时延\n* 输出缓存/队列：用于存储路由器准备发往那条链路的分组\n* 排队时延：等待该链路分组传输\n* 分组丢失/丢包：到达的分组或者已经排队的分组之一将被丢弃\n* 转发表：由特殊的路由选择协议自动设置，用于将目的地址（IP地址）或目的地址的一部分映射为输出链路\n* 一台主机经过分组交换网络向另外一台足记发送分组，该分组经过一系列通信链路传输，被发送出网络后，不预留任何链路资源之类的东西。如果因为此时其他分组也需要经该链路进行传输而使链路之一出现拥塞，则该分组不得不在传输链路发送侧的缓存中等待而产生时延。因特网尽最大可能以实时方式交付分组，但他不做任何保证。\n\n=== 电路交换\n\n* 在端系统间通信会话期间，预留了端系统间沿路径通信所需要的资源\n* 创建一条专用的端到端连接，发送方和接收方之间路径的交换机都将为该连接维护连接状态，将之称为一条电路。他在连接期间在该网络链路上预留了恒定的传输速率\n* 链路中的电路 通过频分复用 FDM /时分复用 TDM 实现的\n** FDM：链路的频谱由跨越链路创建的所有连接共享。\n** TDM：时间被划分为固定期间的帧，并且每个帧又被划分为固定数量的时隙。\n* 带宽：连接期间链路为每条连接专用一个频段\n* 网络的网络\n* ISP 接入\n** 等级\n** 多宿 mullti-home\n** 对等 peer\n** 因特网交换点 IXP\n** 内容供应商网络\n\n== 分组交换网中的时延、丢包和吞吐量\n\n* 处理时延：检查分组首部和决定该分组导向何处所需要的时间是其中一部分，还有其他检查比特级别的差错所需要的时间\n* 排队时延：当分组在链路上等待传输时，他经受排队时延\n* 传输时延：将所有分组的比特推向链路（即传输、或者说发射）所需要的时间\n** 路由器退出分组所需要的时间，他是分组长度和链路传输速率的函数，与两台路由器之间的距离无关\n* 传播时延：一旦一个比特被推向链路，该比特需要向路由器B传播，从该链路的起点到路由器B传播所需要的时间。取决于该链路的物理媒体\n** 一个比特从一台路由器传播到另一台路由器所需要的时间，他是两台路由器之间距离的函数，而与分组长度或链路传输速率无关\n* 丢包：到达的分组发现一个满的队列，由于没有地方存储这个分组，路由器将丢弃该分组，即该分组将会丢失。一个节点的性能通常不仅根据时延来度量，而且根据丢包的概率来度量。\n* 端到端时延\n* traceroute 进行跟踪 三次往返时延\n\nimage::https://resources.echocow.cn/file/2019/05/19/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190519214722.png[traceroute]\n\n* 吞吐量\n** 瞬时吞吐量\n** 平均吞吐量\n\n== 协议层次及其服务模型\n\n* 分层的体系结构\n** 以分层的方式组织协议以及实现这些协议的网络硬件和软件\n** 某层向他的上一层提供 服务 ，即所谓一层的服务模型\n** 各层的所有协议被称为协议栈\n* 五层因特网协议栈\n** 应用层：分布在多个端系统上，而一个短系统中的应用程序使用协议与另一个端系统中的引用程序交换信息分组，位于应用层的信息分组称为报文\nmessage\n** 运输层：在应用程序端点之间传递应用层报文。运输层的分组称为报文段\nsegment\n** 网络层：负责将成为数据报 datagram\n的网络层分组从一台主机移动到另外一台主机\n** 链路层：通过源和目的地之间的一系列路由器路由数据报,将整个帧从一个网络元素移动到邻近的网络元素。链路层的分组称为\n帧 frame\n** 物理层：将该帧中的一个个比特从一个节点移动到一个节点\n* OSI 模型\n** 表示层：使通信的应用程序能够解释交换数据的含义\n** 会话层：提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法\n\nimage::https://resources.echocow.cn/file/2019/05/19/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190519220133.png[网络]\n\n* 封装 encapsulation\n\n== 面对攻击的网络\n\n* 有害程序\n** 僵尸网络 botnet\n** 自我复制 self-replicating\n** 病毒 virus\n** 蠕虫 worm\n* 攻击\n** 拒绝服务器攻击 Denial-of-Service dos\n* 嗅探\n** 分组嗅探器 packet sniffer\n* 伪装\n** IP 哄骗 IP spoofing\n\n== 历史\n\n* 分组交换的发展 1961-1972\n* 专用网络和网络互联 1972-1980\n* 网络的激增 1980-1990\n* 因特网爆炸 20 世纪 90 年代\n\n== 总结\n\n阅读一番下来真的太棒！所有的抽象概念都有具体的例子，不仅如此，还有贴近生活的一些例子来进行描述，所有的概念都能在脑子里面形成一个图，这本书不仅告诉概念的意思，还告诉他的由来，简直大爱！自己心里也渐渐的清楚了一些以前许多模棱两可的东西，不过总结的时候后面东西实在太多，一大段一大段的，就没有摘抄了。自己很久以前就买了\n第六版 一直没有看，现在回来看还算不是很迟！\n\n","fields":{"slug":"/articles/2019/05/19/1558277640118.html","birthTime":"2019-05-19T14:54:00.169Z","modifiedTime":"2019-05-19","year":2019},"document":{"title":"[阅读] 计算机网络 自顶向下方法 —— 计算机网络和因特网"}},{"content":"= Faas/Serverless 架构 —— 阿里云无服务器计算/函数式计算\n:page-description: Faas/Serverless 架构 —— 阿里云无服务器计算/函数式计算\n:page-category: 兴趣\n:page-image: https://img.hacpai.com/bing/20190402.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2019/05/26/1558880702189.html\n:page-created: 1558880702466\n:page-modified: 1561008446022\n:toc:\n\n很早以前就已经知道 Faas/Serverless 架构，当时自己还很菜，只会\nhtml/css/js 和 ssh\n的小白，随着自己不断的成长，越发的了解架构的重要性。最近开始考虑学习一下\nServerless\n架构，对于他的解释，网上已经有很多了，我是这样理解他的特点的：\n\n* 不需要去做**任何**运维操作，专注于业务的实现\n* *足够小、足够单一、能够快速启动、运行、卸载*\n* *真正的按需使用*，请求到来时才开始运行，即用即走，不会在服务器/虚拟机中常驻\n* 应用**严重依赖**于特定的云平台、第三方服务\n* 按运行**时间和内存**来算钱的\n* 服务器对用户来说是**透明的**\n\n按 AWS 官方对于 Serverless 的介绍是这样的：\n\n____\n服务器架构是基于互联网的系统，其中应用开发不使用常规的服务进程。相反，它们仅依赖于第三方服务（例如AWS\nLambda服务），客户端逻辑和服务托管远程过程调用的组合。\n____\n\n== Serverless\n\n对于 Serverless 的开发模式和运行模式，大概向如下这样：\n\n[arabic]\n. 编写业务逻辑代码\n. 上传到 Serverless 平台，设定触发规则\n. 触发规则，创建函数，运行\n\n当请求比较多的时候，他会进行自动的实例的扩展；当请求比较少，就会进行请求的收缩，当没有人访问的时候，就会自动卸载请求。这个函数足够小，他按需装载，自动伸缩，不用你苦逼地去规划硬件，安装软件，还可以按照使用情况付费，是不是有点心动了呢？但是必须要泼一盆冷水，他为了完成这些目标，牺牲了一个很重要的东西：*状态*。\n\n对于一个函数来说，他是没有状态的，这也就意味着他不能够进行状态的存储，因为每次他的启动可能是在另外一个完全不一样的环境下的。所以适合\nServerless 的应用大多都是无状态的应用。\n\n== 阿里云无服务器计算/函数式计算\n\n原本打算是使用 aws lambda\n的，但是发现注册账号的时候，需要绑定信用卡信息，可是我是一个学生并没有一张信用卡，所以不得已寻找其他的\nServerless 平台，后来找到了\nhttps://serverless.aliyun.com/?spm=5176.137990.1214002.bt1.6431224evGXX4i[阿里云无服务器计算]，研究半天，发现对于他来说，整个流程应该是这样的（开通服务等部分省略）：\n\n[arabic]\n. 新建服务：在 阿里云 平台上 *新建一个服务*\n. 新建函数：在 新建的服务之中 *创建一个函数*，设定\n*触发条件*，学习并查看他的 函数编写 API\n. 上传函数：编写好业务的函数代码，上传至 创建好的函数之中\n. 测试函数：对函数进行测试\n. 创建完成：可以通过你设定的触发条件来进行触发函数\n\n目前阿里云支持的环境如下：\n\n* nodejs 6/8 （可在线编辑）\n* python 2.7/3.6 （可在线编辑）\n* php 7.2 （可在线编辑）\n* java 8 （不可在线编辑）\n* C# dotnetcore2.1 （不可在线编辑）\n\n== 开通服务\n\n你需要开通 阿里云无服务器计算 才能使用，开通是免费的\n\nimage::https://resources.echocow.cn/file/2019/05/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190526222852.png[开通服务]\n\nimage::https://resources.echocow.cn/file/2019/05/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190526222814.png[开通服务]\n\n== 新建服务\n\nimage::https://resources.echocow.cn/file/2019/05/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190526223447.png[新建服务]\n\nimage::https://resources.echocow.cn/file/2019/05/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190526223701.png[新建服务]\n\n== 使用 node 环境\n\n=== 创建函数\n\nimage::https://resources.echocow.cn/file/2019/05/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190526224033.png[创建函数]\n\nimage:https://resources.echocow.cn/file/2019/05/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190526224551.png[image]\n\nimage:https://resources.echocow.cn/file/2019/05/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190526224636.png[image]\n\nimage:https://resources.echocow.cn/file/2019/05/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190526224731.png[image]\n\nimage:https://resources.echocow.cn/file/2019/05/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190526224806.png[image]\n\nimage:https://resources.echocow.cn/file/2019/05/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190526224821.png[image]\n\n=== 编写代码\n\nimage:https://resources.echocow.cn/file/2019/05/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190526225231.png[image]\n\n[source,javascript]\n----\nvar getRawBody = require('raw-body')\nmodule.exports.handler = function (request, response, context) {\n    // get requset header\n    var reqHeader = request.headers\n    var headerStr = ' '\n    for (var key in reqHeader) {\n        headerStr += key + ':' + reqHeader[key] + '  '\n    }\n    // get request info\n    var url = request.url\n    var path = request.path\n    var queries = request.queries\n    var queryStr = ''\n    for (var param in queries) {\n        queryStr += param + \"=\" + queries[param] + '  '\n    }\n    var method = request.method\n    var clientIP = request.clientIP\n    // get request body\n    getRawBody(request, function (err, data) {\n        var body = data\n        // you can deal with your own logic here\n        // set response\n        // var respBody = new Buffer('requestURI' + requestURI + ' path' + path +  ' method' + method + ' clientIP' + clientIP)\n        var respBody = new Buffer('requestHeader:' + headerStr + '\\n' + 'url: ' + url + '\\n' + 'path: ' + path + '\\n' + 'queries: ' + queryStr + '\\n' + 'method: ' + method + '\\n' + 'clientIP: ' + clientIP + '\\n' + 'body: ' + body + '\\n')\n        // var respBody = new Buffer( )\n        response.setStatusCode(200)\n        response.setHeader('content-type', 'application/json')\n        response.send(respBody)\n    })\n};\n----\n\n=== 测试代码\n\nimage:https://resources.echocow.cn/file/2019/05/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190526225548.png[image]\n\nimage:https://resources.echocow.cn/file/2019/05/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190526225701.png[image]\n\nnode 的就完成了～！python/php 等都是一样的\n\n== 使用 java 环境\n\n=== 创建函数\n\nimage:https://resources.echocow.cn/file/2019/05/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190526230006.png[image]\n\nimage:https://resources.echocow.cn/file/2019/05/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190526230349.png[image]\n\n=== 编写代码\n\n创建一个 maven 项目\n\nimage::https://resources.echocow.cn/file/2019/05/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190526230823.png[pom]\n\nimage::https://resources.echocow.cn/file/2019/05/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190526231436.png[Application]\n\n然后打包成 jar 包，可以使用 maven 插件或者直接 IDEA 打包，参见\nhttps://help.aliyun.com/document_detail/58887.html?utm_source=hacpai.com[函数计算\nJAVA] 我使用 IDEA 打包，点击 `File -> Project Structure`\n\nimage:https://resources.echocow.cn/file/2019/05/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190526231926.png[image]\n\nimage:https://resources.echocow.cn/file/2019/05/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190526231936.png[image]\n\nimage:https://resources.echocow.cn/file/2019/05/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190526231956.png[image]\n\n执行打包操作 `Build -> Build Artifacts -> build` 即可生成 `jar` 包\n\nimage:https://resources.echocow.cn/file/2019/05/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190526232240.png[image]\n\n右键 `Copy Path` 可以复制路径\n\n=== 测试代码\n\nimage:https://resources.echocow.cn/file/2019/05/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190526232439.png[image]\n\nimage:https://resources.echocow.cn/file/2019/05/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190526232620.png[image]\n\nimage:https://resources.echocow.cn/file/2019/05/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190526232734.png[image]\n\n使用 java 的创建就完成了，对于 java 来说还是麻烦了一点。。。\n\n== 总结\n\n感觉用着还是挺不错的，对于解释型语言，编译型语言确实麻烦了一点，不过也不是不能接受吧。后面再慢慢尝试如何让他更加安全的访问。Gateway\n的方式其实相比 http 应该会好很多，但是 http 确实是挺方便的\n\n____\n去年（2018年）年末 AWS 上线了基于 Lambda + API Gateway (+DynamoDB)\n可以构建 WebSocket 应用\n____\n\n不知道阿里云会不会有所动作，serverless\n还是我比较喜欢的，不过无状态确实局限了他太多。有利有弊，需要根据合适的业务场景去选择。\n\n","fields":{"slug":"/articles/2019/05/26/1558880702189.html","birthTime":"2019-05-26T14:25:02.466Z","modifiedTime":"2019-06-20","year":2019},"document":{"title":"Faas/Serverless 架构 —— 阿里云无服务器计算/函数式计算"}},{"content":"= Manjaro 安装 jdk 8 / docker / docker compose 等常用软件记录\n:page-description: Manjaro 安装 jdk 8 / docker / docker compose 等常用软件记录\n:page-category: linux\n:page-image: https://img.hacpai.com/bing/20171227.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2019/06/20/1561008381459.html\n:page-created: 1561008381605\n:page-modified: 1571842365332\n:toc:\n\n这几天都在折腾系统，无意义的折腾的那种。从manjaro kde 崩溃后换了 xfce\n原以为 xfce 占用内存会少一点，但是其实相差不到一个G，而且为了好看上了\ncompiz ，但是总是蜜汁卡死，昨天一天卡死其次，实在受不了，所以再次换回\nkde，，，真香！**不过发现 jdk 的安装方式和以前不同了，不能够通过\n`yaourt` 直接安装了，因为他下不下来 jdk\n了，所以需要绕一下。**另外记录一下自己安装的东西，不然每次都要一个一个去找真的太麻烦了。。。\n\n== 前提\n\n开机卡死每次都会遇到\n\n....\nsudo vi /ect/default/grub\n....\n\n在quiet后加上 nouveau.modeset=0，然后\n\n....\nsudo update-grub\n....\n\n确保你以及配置了 已经 源，并且能够使用 `yaourt` 进行搜索安装。\n\n== oracle jdk 安装\n\n=== 下载 jdk\n\n一种是去 https://www.oracle.com/technetwork/java/javase/downloads/[官网]\n下载，不过你会发现需要登录什么的很麻烦，我在七牛云上备份了一个\n\n* http://downloads.echocow.cn/jdk-8u212-linux-x64.tar.gz[七牛云链接\n8u212]\n* http://downloads.echocow.cn/jdk-8u221-linux-x64.tar.gz[七牛云链接\n8u221]\n\n*下载完成后存放在当前用户的家目录下的 `Downloads` 文件夹下，没有就使用\n`mkdir ~/Downloads` 创建一个*\n\n=== 安装 jdk\n\n使用命令进行查找安装\n\n[source,bash]\n....\n[echo@echo-pc ~]$ yaourt jdk\n# 找到大约 第 55 个如下\n# 55 aur/jdk8 8u212-1 (76) (2.48)\n#   Oracle Java 8 Development Kit\n==> 输入 n° 以安装需要的软件包（例如：1 2 3 或者是 1-3）\n==> ---------------------------------\n==> 55\n\n# ......\n\n==> 编辑 PKGBUILD ？ [Y/n] (\"A\" 忽略)\n==> ----------------------------\n==> n\n\n#......\n\n==> 编辑 jdk8.install ？ [Y/n] (\"A\" 忽略)\n==> --------------------------------\n==> n\n\n==> 继续构建 jdk8 ？[Y/n]\n==> ----------------\n==> y\n....\n\n设置默认 `jdk`\n\n[source,bash]\n....\n[echo@echo-pc ~]$ archlinux-java status\nAvailable Java environments:\n  java-8-jdk (default)\n# 如果默认不是 jdk8，就使用 sudo archlinux-java set java-8-jdk 进行修改\n....\n\n== Docker 安装\n\n[arabic]\n. 运行 `sudo pacman -S docker` 或 `yaourt -S docker` 安装\n. 运行 `sudo usermod -aG docker 当前用户名` 添加用户组\n. 注销用户，重启 docker 即可\n\n配置镜像 https://lug.ustc.edu.cn/wiki/mirrors/help/docker[USTC]\n\n== Docker-compose 安装\n\n[source,bash]\n....\n# 下载\n➜  ~ sudo curl -L https://github.com/docker/compose/releases/download/1.24.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose\n\n# 修改权限\n➜  ~ sudo chmod +x /usr/local/bin/docker-compose\n\n# 查看\n➜  ~ docker-compose -v\ndocker-compose version 1.24.0, build 0aa59064\n....\n\n== zsh\n\n[source,bash]\n....\nyaourt -S zsh\nsh -c \"$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\"\n....\n\n== gradle, vim ,git， peek\n\n[source,bash]\n....\nyaourt -S gradle vim git  peek\n....\n\n== 前端\n\n[source,bash]\n....\nyaourt -S nodejs npm  yarn npm-check-updates ts-node\n....\n\n== teamviewer\n\n[source,bash]\n....\nyaourt -S teamviewer\nteamviewer --daemon start\nteamviewer --daemon enable\n....\n\n====\n2019.10.1 更新\n====\n\n'''''\n\n这段时间不停的重装系统，自己记录得还是太少啦，下面全部写一下吧，免得以后麻烦死人啦=-=\n\n== 初始\n\n=== 切换源\n\n[source,bash]\n....\nsudo pacman-mirrors -i -c China -m rank\n....\n\n修改/etc/pacman.conf文件 在文件后添加如下语句\n\n[source,bash]\n....\n[archlinuxcn]\nSigLevel = Optional TrustedOnly\nServer = https://mirrors.ustc.edu.cn/archlinuxcn/$arch\n....\n\n导入GPG Key\n\n[source,bash]\n....\nsudo pacman -Syyu && sudo pacman -S archlinuxcn-keyring\n....\n\n等很久很久…\n\n== 中文乱码\n\nmanjaro 18 在更新后会出现中文字体缺失得情况，需要手动安装一下中文字体\n\n[source,bash]\n....\nsudo pacman -S wqy-bitmapfont\nsudo pacman -S wqy-microhei\nsudo pacman -S wqy-zenhei\n....\n\n三种字体总有一种可以使用\n\n== 搜狗输入法\n\n[source,bash]\n....\nsudo pacman -S fcitx-sogoupinyin fcitx-im fcitx-configtool # 图形化的配置工具\n....\n\n安装完毕还不可以使用，需要进行如下配置：\n\n[source,bash]\n....\nvim ~/.xprofile\n....\n\n添加如下语句\n\n[source,bash]\n....\nexport GTK_IM_MODULE=fcitx\nexport QT_IM_MODULE=fcitx\nexport XMODIFIERS=\"@im=fcitx\"\n....\n\n配置完毕之后，可以使用可视化界面调节输入法的设置\n\n[source,bash]\n....\nfcitx-configtool\n....\n\n注销后就可以使用啦\n\n== 科学上网\n\n[source,bash]\n....\nyaourt -S shadowsocks-qt5 electron-ssr\n....\n\n== pacman的彩蛋\n\n1. 打开 `/etc/pacman.conf` 文件。\n2. 在 `# Misc options` 部分，去掉  `Color` 前的 `#` 。\n3. 添加一行 `ILoveCandy`。\n4. 这样在使用 `pacman` 安装软件的时候，可以看到一个吃豆人233，因为pacman本身就是吃豆人的意思\n\n=== 截图\n\n除了上面说到得 peek 可以截图以外，深度截图工具很不错。\n\n[source,bash]\n....\nsudo pacman -S deepin-screenshot\n....\n\n=== 安装 qq\n\n`pacman -S deepin.com.qq.office` 或 `pacman -S deepin.com.qq.im`\n\n一个是qq，一个是tim，\n\n如果无法启动\n\n[arabic]\n. `yaourt -S gnome-settings-daemon`\n. 然后运行 `/usr/lib/gsd-xsettings`，或者后台运行\n`nohup /usr/lib/gsd-xsettings > /dev/null 2>&1 &`\n. 启动qq/tim\n. 通过 `sudo ln /usr/lib/gsd-xsettings ~/.config/autostart-scripts/gsd-xsettings`\n添加开机自启\n\n'''''\n\n2019-10-7 更新\n\n== tty 中文乱码\n\nmanjaro 的 tty 无法显示中文，一般下载东西的时候我会选择挂在 tty\n上下载而不是进桌面环境。找了 Fbterm 来显示中文，值得一提的是，Fbterm\n已经停止维护，目前 aur 上面的是来自于 git\n上的，测试后目前可用，不过无法使用其配套的输入法支持 fcitx-fbterm 了。\n\n[arabic]\n. `yaourt fbterm` 直接安装\n. `sudo gpasswd -a 用户名 video` 添加用户到指定组\n. `fbterm` 命令直接运行即可\n\n可以修改 `~/.fbtermrc` 进行自定义字体和大小配置，在运行第一次`fbterm`\n命令后会自动生成这个文件。可以设置颜色，大小等，例如我的部分配置\n\n[source,bash]\n....\nfont-names=wqy-microhei\nfont-size=18\n....\n\n'''''\n\n2019-10-23 更新\n\n== 快捷键备份\n\n自己的一些自定义快捷键\n\n* http://downloads.echocow.cn/manjaro/%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%87%E4%BB%BD[全局快捷键]\n* http://downloads.echocow.cn/manjaro/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%87%E4%BB%BD[自定义快捷键]\n\n快捷键沿用了部分 i3\n的快捷键习惯，感觉还是挺顺手的。有些快捷键也挺好玩的，不过有些需要注意\n\n* `META` 键就是我们说的 `WIN` 键，如图\nimage:https://resources.echocow.cn/file/2019/10/5/jianpan.png[META]\n* 数字键盘分为两种，一种就是普通的数字键盘，一种是小键盘，如图\nimage:https://resources.echocow.cn/file/2019/10/5/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20191023224136.png[数字键盘]\n在快捷键中 `NUM+5` 指的是小键盘上的，不是普通数字键。例如 将窗口推至上侧\n的快捷键是 `META+NUM+8`，其实就是两个键，`WIN+8`，此时 `8` 是小键盘的\n`8`。\n* 部分快捷键需要安装相关的应用\n\n=== 全局快捷键\n\n[cols=\",,\",options=\"header\",]\n|===\n|动作 |快捷键 |常用等级\n|deepin 截图 |`CTRL+ALT+D` |★★★★★\n|打开命令行 |`META+ENTER` |★★★★★\n|打开/缩回 Yakuake |`F10` |★★★★★\n|运行命令 |`ALT+空格` |★★★★★\n|用剪贴板内容运行命令 |`ALT+SHIFT+F2` |★★\n|遍历窗口 |`ALT+TAB` |★★★★★\n|遍历窗口(反向) |`ALT+TAB+BACKTAB` |★\n|遍历当前应用程序窗口 |`ALT+～` |★★★★\n|遍历当前应用程序窗口(反向) |`ALT+～` |★\n|窗口操作菜单 |`ALT+F3` |★★★★\n|窗口到桌面 1 |`META+SHIFT+F1` |★★★★\n|窗口到桌面 2 |`META+SHIFT+F2` |★★★★\n|窗口到桌面 3 |`META+SHIFT+F3` |★★★★\n|窗口到桌面 4 |`META+SHIFT+F4` |★★★★\n|窗口上移一个桌面 |`META+SHIFT+↑` |★★★\n|窗口下移一个桌面 |`META+SHIFT+↓` |★★★\n|窗口左移一个桌面 |`META+SHIFT+←` |★★★\n|窗口右移一个桌面 |`META+SHIFT+→` |★★★\n|放大 |`META+=` |★★★★☆\n|缩小 |`META+-` |★★★★☆\n|更改窗口大小 |`META+SHIFT+S` |★★★★\n|挂起混成器 |`ALT+SHIFT+F12` |禁特效\n|关闭窗口 |`META+SHIFT+Q` |★★★★★\n|激活请求注意的窗口 |`CTRL+ALT+X` |★★★★★\n|将窗口放到全部桌面 |`META+SHIFT+A` |★★★\n|将窗口放至全屏 |`META+NUM+5` |★★★\n|将窗口快速铺至上方 |`META+↑` |★★★★☆\n|将窗口快速铺至下方 |`META+↓` |★★★★☆\n|将窗口快速铺至左方 |`META+←` |★★★★☆\n|将窗口快速铺至右方 |`META+→` |★★★★☆\n|将窗口快速铺至右上方 |`META+NUM+9` |★★★★\n|将窗口快速铺至右下方 |`META+NUM+3` |★★★★\n|将窗口快速铺至左上方 |`META+NUM+7` |★★★★\n|将窗口快速铺至左下方 |`META+NUM+1` |★★★★\n|将窗口水平扩展 |`META+NUM++` |☆\n|将窗口水平收缩 |`META+NUM+-` |☆\n|将窗口推至上侧 |`META+NUM+8` |★★\n|将窗口推至下侧 |`META+NUM+2` |★★\n|将窗口推至左侧 |`META+NUM+4` |★★\n|将窗口推至右侧 |`META+NUM+6` |★★\n|切换当前窗口分类 |`CTRL+F7` |☆\n|切换到上方的窗口 |`META+ALT+↑` |★★★☆\n|切换到下方的窗口 |`META+ALT+↓` |★★★☆\n|切换到左方的窗口 |`META+ALT+←` |★★★☆\n|切换到右方的窗口 |`META+ALT+→` |★★★☆\n|切换到上面的桌面 |`META+CTRL+↑` |★★★★☆\n|切换到下面的桌面 |`META+CTRL+↓` |★★★★☆\n|切换到左面的桌面 |`META+CTRL+←` |★★★★☆\n|切换到右面的桌面 |`META+CTRL+→` |★★★★☆\n|切换到桌面 1 |`CTRL+F1` |★★★★★\n|切换到桌面 2 |`CTRL+F2` |★★★★★\n|切换到桌面 3 |`CTRL+F3` |★★★★★\n|切换到桌面 4 |`CTRL+F4` |★★★★★\n|切换鼠标点击效果 |`META+SHIFT+8` |★★★\n|切换显示窗口(对当前桌面) |`CTRL+F9` |★\n|切换显示窗口(对全部桌面) |`CTRL+F10` |★\n|清除全部鼠标标记 |`META+SHIFT+F11` |★★★★\n|清除上一个鼠标标记 |`META+SHIFT+F12` |★★★★\n|杀死窗口 |`CTRL+ALT+ESC` |★★★★\n|设置窗口快捷键 |`META+SHIFT+K` |★★★★\n|显示桌面网格 |`CTRL+F8` |★★★☆\n|移动窗口 |`META+SHIFT+M` |★★★★☆\n|移动鼠标到焦点 |`META+F5` |★★\n|移动鼠标到中央 |`META+F6` |★★\n|桌面立方 |`META+F10` |★★★★★\n|桌面球体 |`META+F11` |★★★\n|桌面圆柱 |`META+F12` |★★★\n|最大化窗口 |`META+PgUp` |★★★★\n|最小化窗口 |`META+PgDown` |★★★★\n|===\n\n=== 全局快捷键\n\n[cols=\",,\",options=\"header\",]\n|===\n|动作 |快捷键 |常用等级\n|TIM 截图 |`CTRL+ALT+A` |★★★★★\n|TIM 提取命令 |`CTRL+ALT+Z` |★★★★★\n|===\n\n","fields":{"slug":"/articles/2019/06/20/1561008381459.html","birthTime":"2019-06-20T05:26:21.605Z","modifiedTime":"2019-10-23","year":2019},"document":{"title":"Manjaro 安装 jdk 8 / docker / docker compose 等常用软件记录"}},{"content":"= Spring Security Oauth2 从零到一完整实践（一）\n:page-description: Spring Security Oauth2 从零到一完整实践（一）\n:page-category: spring\n:page-image: https://img.hacpai.com/bing/20180817.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2019/07/14/1563082088646.html\n:page-created: 1563082088733\n:page-modified: 1579503835576\n:toc:\n\n很久没有写一篇长文章了，自己说起来其实年初换成 solo\n到现在，写的让自己满意的技术性文章也就只有\nhttps://echocow.cn/articles/2019/01/05/1546684795983.html[spring boot\nrestful API 从零到一完整实践]\n这篇了，其他的其实都是只属于自己比较容易理解的笔记和记录而已。想想年中了，还是需要写上这么一篇实践性文章的。这段时间比较折磨自己的，莫过于就是\nhttps://spring.io/projects/spring-security-oauth[spirng security oauth2]\n了，自己折腾了很久，也算是学会了一些吧，按照原来的方式，写了一篇文章。前面也写过\nhttps://echocow.cn/articles/2019/01/22/1548148450889.html[spring boot\nsecurity oauth2 构建简单安全的 restful\napi]，但是太过于基础并且那时候自己也有很多不懂，现在实践了很多，有了更加深入的了解，记录一下顺便分享给大家。\n\n====\nGitHub 地址： https://github.com/lizhongyue248/spring-security-oauth2-demo[spring-security-oauth2-demo]\n\n博客地址： https://echocow.cn[echocow.cn]\n====\n\n== 系列文章\n\n[arabic]\n. 较为详细的学习 oauth2 的四种模式其中的两种授权模式\n. https://echocow.cn/articles/2019/07/14/1563082247386.html[spring boot\noauth2 自动配置实现]\n. https://echocow.cn/articles/2019/07/14/1563096109754.html[spring\nsecurity oauth2 授权服务器配置]\n. https://echocow.cn/articles/2019/07/20/1563611848587.html[spring\nsecurity oauth2 资源服务器配置]\n. https://echocow.cn/articles/2019/07/30/1564498598952.html[spring\nsecurity oauth2 自定义授权模式（手机、邮箱等）]\n. https://echocow.cn/articles/2020/01/20/1579503807596.html[spring\nsecurity oauth2 踩坑记录]\n\n原本打算全部写完一起发的，但是才写到第三点，就已经上万字了，所以还是觉得分系列发吧～\n\n== 预备知识\n\n具备以下基础知识能够方便你更好的阅读本篇文章\n\n* spring 基础\n* spring boot web 的使用与配置\n* spring security 的使用与配置\n* postman 的使用\n* idea、maven、lombok 的使用与配置\n\n== Oauth2\n\n学习一项新的东西之前，我们要先了解一下他为我们解决了哪些事，能够带来什么样的便利，而在\nIT\n行业，了解一个东西最简单的方式就是去他的官网了解，所以我们先去官网了解一下这个协议：https://oauth.net/[Oauth2]\n\n====\nAn *open protocol* to allow *secure authorization* in a *simple* and\n*standard* method from web, mobile and desktop applications.\n====\n\n一个允许从Web、移动和桌面应用程序简单和标准方法进行安全授权的开放协议。\n\n====\nThe OAuth 2.0 authorization framework enables third-party applications\nto obtain *limited* access to a web service.\n====\n\nOAuth 2.0 授权框架使第三方应用程序能够获得对 Web 服务的有限访问权限。\n\n从官网的解释就可以知道它可以完成如下两件事：\n\n[arabic]\n. 对你的应用站点进行安全授权\n. 使第三方应用程序能够获得对 Web 服务的有限访问权限\n\n我们这篇教程就是通过 spring security oauth2\n来完成这么两件事。我们来详细了解一下这个协议，首先了解什么要使用\noauth2。我们以 web 为例来进行了解。\n\n=== 传统应用\n\n在我们传统的 web\n应用中，我们的前端页面和后端的逻辑都是一起部署的，大概流程如下：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190708190354.png[传统模式]\n\n当我们发送一个请求的时候，直接先发给后端处理，后端处理完成后将数据发送给前端，然后前端渲染，再交给用户，所以有了模板引擎这个东西，例如\njsp、thymeleaf、freemarker\n这些，都是这样的流程。而这些个东西最为重要的就是\nsession，你可以通过存储在 session\n里面的东西对他进行授权/认证等操作，大概如下：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190708194101.png[授权]\n\n=== 现在的应用\n\n那么现在我们的应用是什么样的呢？现在的前端已经不再是只有\nhtml、css、javascript 了，也不再是 bootstrap 的天下，也没有 jquery\n一出，万人空巷了。前端项目组建工程化，已经能够完整的独立成为一个工程化的项目了。所以我们现在前后端是完全分离的，*前后端各司其职，前端完成前端的事，只做页面，后端完成后端的事，只做逻辑和数据库操作，完全两个独立的引用，通过接口进行交互*，那么我们的大概流程如下：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190708191537.png[前后端分离]\n\n用户通过浏览器请求前端应用的页面，然后页面里面加载请求到数据，再渲染页面。那么现在的授权没有\nsession\n了，前后端是完全独立的两个项目了，我们要怎么进行认证授权呢？对于一个受保护的应用来说，他的请求流程如下：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190708203251.png[现在]\n\n在这个流程中，我们后端应用其实变成了两个，一个是授权服务器一个是资源服务器，*当然你完全可以简爱嗯他们两个同时写在一个之中*。单独提出来的好处是什么呢？最主要的一点就是上面提到的\n*使第三方应用程序能够获得对 Web\n服务的有限访问权限*，简单的说就是能够更加方便的另外一个应用接入。当你写好一个授权服务器以后，其他应用就可以共用这个授权服务器，他们就作为资源服务器亦或是客户端即可。\n\n=== 角色\n\n在这个协议中，我们需要明确一个 *角色*\n的概念，在前面的和传统应用的对比中，我们提到了资源服务器和授权服务器，这就是其中两个角色，在\nOauth2 中，总共有四种角色：\n\n[width=\"100%\",cols=\"12%,19%,58%,11%\",options=\"header\",]\n|===\n|名称 |英文名 |描述 |web例子\n|资源所有者 |resource owner\n|能够授予对受保护资源的访问权的实体。当资源所有者是一个人时，它就是用户。\n|用户\n\n|资源服务器 |resource server\n|承载受保护资源的服务器，能够使用访问令牌接受和响应受保护资源请求。\n|后端资源数据\n\n|客户端 |client\n|代表资源所有者及其授权发出受保护资源请求的应用程序。``客户端''\n并不意味着任何特定的实现特征(例如，应用程序是否在服务器、桌面或其他设备上执行)。\n|前端应用\n\n|授权服务器 |authorization server\n|在成功认证资源所有者并获得授权后，服务器向客户端发出访问令牌。\n|后端授权\n|===\n\n而授权服务器可以是与资源服务器**相同的服务器**或**单独的服务器**。\n单个授权服务器可以发出由**多个资源服务器接受的访问令牌**。\n\n流程图大概如下：\n\n[source,none]\n----\n     +--------+                               +-----------------+\n     |        |--（A）------- 授权请求 -------->|                 |\n     |        |                               | 资源所有者（用户） |\n     |        |<-（B）------- 授权许可 ---------|                 |\n     |        |                               +-----------------+\n     |        |\n     |        |                               +-----------------+\n     |        |--（C）------- 授权许可 -------->|                 |\n     | 客户端  |                               |  授权服务器（1    |\n     |        |<-（D）----- Access Token ----）|                 |\n     |        |                               +-----------------+\n     |        |\n     |        |                               +-----------------+\n     |        |（-（E）---- Access Token ----->|                 |\n     |        |                               |   资源服务器（2   |\n     |        |<-（F）---- 获取受保护的资源 -----|                 |\n     +--------+                               +-----------------+\n----\n\n图中所示的 抽象 OAuth 2.0 流程描述了四个角色之间的交互，包括以下步骤：\n\n（A）客户机请求资源所有者（用户）的授权。授权请求可以直接发送给资源所有者(如图所示)，最好通过作为中介的授权服务器间接发送。*简单地说，用户点击登录，会转到登录页面显示给用户。*\n\n（B）客户端接收授权许可，这是表示资源所有者授权的凭据，使用 Oauth2\n规范中定义的四种授权类型之一或使用扩展授权类型表示。授权授予类型取决于客户机用于请求授权的方法和授权服务器支持的类型。*简单地说，选择\noauth2 中四种授权模式进行授权。*\n\n（C）客户端通过向授权服务器进行认证并呈现授权授权来请求访问令牌。*简单地说，客户端会向授权服务器使用前面选择的四种方式之一请求认证。*\n\n（D）授权服务器对客户端进行身份验证并验证授权授予，如果有效，则发出访问令牌。*简单地说，授权成功发放令牌。*\n\n（E）客户端从资源服务器请求受保护的资源，并通过呈现访问令牌进行身份验证。*简单地说，携带\n令牌 请求资源服务器。*\n\n（F）资源服务器验证访问令牌，如果有效，则为请求服务。*简单地说，如果令牌有效，就允许访问资源。*\n\n（1）授权服务器可以只有一台，一台授权可以发放多个资源服务器。\n\n（2）资源服务器需要关联一台授权服务器作为资源的保护和认证。\n\n最为重要的部分为 B 中的\n授权许可，它是代表资源所有者的授权（访问其受保护的资源）的**凭据**，客户端使用该授权来获得访问令牌。该规范定义了四种授权类型——*授权代码、隐式、资源所有者密码凭证和客户端凭证*——以及用于定义其他类型的可扩展性机制（自定义授权）。\n\n=== 四种授权模式\n\n客户端必须得到用户的授权（authorization grant），才能获得令牌（access\ntoken）。OAuth 2.0定义了四种授权方式如下：\n\n* 授权码模式（authorization code）\n* 密码模式（resource owner password credentials）\n* 简化模式（implicit）\n* 客户端模式（client credentials）\n* 扩展模式（extension）\n\n最为常用的为第一、二种，我们这篇文章也只会完成第一二种，四种具体请参考\nhttp://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html[阮一峰 理解OAuth\n2.0] ，请注意详细看文章的 *名词定义*\n模块。阮一峰老师的文章已经写的很清楚了，但是我依旧还是需要指明一下我们即将开始的第一二种的\napi 设计。\n\n____\n*注意：以下 api 设计为 spring security 提供实现，并不是 oauth2 的标准\napi 实现*\n____\n\n不过在那之前，我们先来了解一下 *客户端的加密*\n\n=== 客户端加密\n\n在 spring security oauth\n中，推荐加密我们的客户端信息，客户端和授权服务器建立适合授权服务器安全要求的客户端认证方法。授权服务器可以接受满足其安全要求的任何形式的客户端身份验证。一般来说我们使用的是\n*密码验证* 的方式加密我们的客户端信息。\n\n推荐的方式是使用 HTTP Basic\n，我们需要设置以下参数，当设置成功以后将客户端凭证加密存放在请求头中去请求授权信息，参数如下：\n\n[cols=\",,\",options=\"header\",]\n|===\n|参数名称 |是否必填 |描述\n|client_id |REQUIRED |客户端 id\n\n|client_secret |REQUIRED\n|客户端密码，如果客户机secret是空字符串，则客户机可以省略该参数\n|===\n\n当我们请求的时候，需要设置相应的客户端认证信息，并存放在请求头中，设置方法如下：\n\n[source,markup]\n....\n Authorization: Basic client_id：client_secret base64编码\n eg:\n client_id:web\n client_secret:secret\n 加密“web:secret” 得到 “QmFzaWMgd2ViOnNlY3JldA==”\n 授权请求头中需要携带如下键值对：\n Authorization: Basic QmFzaWMgd2ViOnNlY3JldA==\n....\n\n这是保证客户端安全十分重要的一环，强烈推荐对客户端进行加密！\n\n==== 授权码模式\n\n他是一种流程最为严密，安全性最高的授权模式，主要为以下几个步骤：\n\n[IMPORTANT]\n注意：以下所有请求都必须在请求头中携带上一点中的客户端加密信息！\n\n[arabic]\n. 用户进入应用，携带一个 _重定向应用地址_ 到 *授权服务器*\n进行登录，在登录成功并且用户同意授权以后，授权服务携带一个生成的\n*授权码* 重定向到指定的 _重定向应用地址_ 。\n. 应用携带接收到的 *授权码* 再次去请求\n*授权服务器*，在验证成功后，验证服务器下发 token。\n\n所以需要两个请求，在 spring security oauth2 中，api 如下，我们将这些 api\n称为 _端点_：\n\n==== 授权端点\n\n* /oauth/authorize：授权端点，通过此端点跳转到 *授权服务器*\n进行认证，完成第一个请求。携带如下参数：\n\n[width=\"100%\", cols=\"15%,15%,70%\",options=\"header\",]\n|===\n|参数名称 |是否必填 |描述\n|response_type |REQUIRED |必须为 code\n\n|client_id |REQUIRED |客户端的 id\n\n|redirect_uri |OPTIONAL |获取授权码后重定向地址\n\n|scope |OPTIONAL |申请的权限范围\n\n|state |RECOMMENDED\n|客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值，推荐。\n|===\n\n授权成功的情况，会携带以下两个参数重定向到到 *redirect_uri* 中：\n\n[width=\"100%\", cols=\"15%,15%,70%\",options=\"header\",]\n|===\n|参数名称 |是否必有 |描述\n|code |REQUIRED\n|授权服务器生成的授权代码。授权代码必须在发布后不久过期，以降低泄漏的风险。最大授权代码生命周期为10分钟\n\n|state |REQUIRED |如果上一步中提供 `state`\n参数，会原封不动地返回这个值。\n|===\n\n____\n注意：官网中给出的解释 code 有 RECOMMENDED\n推荐的情况，但是我没找到如何使用，所以没写。\n____\n\n授权失败的情况分为两种\n\n[arabic]\n. 如果请求由于重定向URI丢失、无效或不匹配而失败，或者如果客户端标识符丢失或无效，授权服务器应通知资源所有者错误，并且**不得自动将用户代理重定向到无效的重定向URI**。\n. 如果资源所有者拒绝访问请求，或者如果请求由于除了丢失或无效重定向URI以外的原因而失败，则授权服务器通过使用\n`application/x-www-form-urlencoded` 格式**向重定向 URI\n的查询组件添加以下参数来通知客户端**，参数如下：(对于 spring\n，目前没有遇到 error_uri 属性)\n\n[width=\"100%\",cols=\"17%,7%,22%,54%\",options=\"header\",]\n|===\n|参数名称 |是否必有 |值 |描述\n|error |REQUIRED |invalid_request\n|请求缺少必需的参数，包括无效的参数值，不止一次地包含参数，或者存在其他形式的异常。\n\n| | |unauthorized_client |未授权客户端使用此方法请求授权代码。\n\n| | |access_denied |资源所有者或授权服务器拒绝了该请求。\n\n| | |unsupported_response_type |授权服务器不支持使用此方法获取授权代码。\n\n| | |invalid_scope |请求的作用域无效、未知或格式不正确。\n\n| | |server_error\n|授权服务器遇到意外情况，无法满足请求。(此错误代码是必需的，因为500内部服务器错误HTTP状态代码不能通过HTTP重定向返回给客户端。)\n\n| | |temporarily_unavailable\n|由于服务器暂时过载或维护，授权服务器当前无法处理该请求。(此错误代码是必需的，因为503服务不可用的HTTP状态代码不能通过HTTP重定向返回给客户端。)\n\n|error_description |OPTIONAL |- |提供附加信息的人类可读ASCII\n[USASCII]文本，用于帮助客户端开发人员理解所发生的错误。\n\n|error_uri |OPTIONAL |\n|一种带有错误信息的可读网页的URI标识，用于向客户端开发人员提供有关错误的附加信息。\n|===\n\n==== 令牌端点\n\n* /oauth/token：令牌端点，通过上一步获取到的 *授权码*\n验证与生成令牌，完成第二个请求，携带如下参数：\n\n[cols=\",,\",options=\"header\",]\n|===\n|参数名称 |是否必填 |描述\n|grant_type |REQUIRED |使用的授权模式，值固定为``authorization_code''\n|code |REQUIRED |上一步获得的授权码\n|redirect_uri |REQUIRED |重定向URI，必须与上一步中的该参数值保持一致\n|client_id |REQUIRED |客户端的 id\n|scope |RECOMMENDED |授权范围，必须与第一步相同\n|===\n\n如果访问令牌请求有效且经过授权，授权服务器将发出访问令牌和可选的刷新令牌，可以得到如下响应参数：\n\n[cols=\",,,\",options=\"header\",]\n|===\n|参数名称 |是否必有 |描述 |是否有实现\n|access_token |REQUIRED |授权服务器颁发的访问令牌 |是\n\n|token_type |REQUIRED\n|令牌类型，该值大小写不敏感，可以是bearer类型或mac类型 |是\n\n|expires_in |RECOMMENDED |过期时间，单位为秒 |是\n\n|refresh_token |OPTIONAL |表示更新令牌，用来获取下一次的访问令牌\n|是，需要设置\n\n|scope |OPTIONAL |权限范围，如果有，则与客户端申请的范围一致 |是\n|===\n\n如果请求客户端身份验证失败或无效，授权服务器将返回错误响应，授权服务器使用HTTP\n400（错误请求）状态代码进行响应（除非另有说明），并在响应中包含以下参数：\n\n[width=\"99%\",cols=\"17%,7%,20%,56%\",options=\"header\",]\n|===\n|参数名称 |是否必有 |值 |描述\n|error |REQUIRED |invalid_request\n|请求缺少必需的参数，包含不受支持的参数值(授权类型除外)，重复参数，包含多个凭据，使用多个机制来验证客户端，或者格式不正确。\n\n| | |invalid_client\n|客户端身份验证失败(例如，未知客户端、不包含客户端身份验证或不支持的身份验证方法)。授权服务器可以返回一个超文本传输协议401(未授权)状态码，以指示支持哪些超文本传输协议认证方案。如果客户端试图通过``授权''请求头字段进行身份验证，授权服务器必须用一个HTTP401(未授权)状态代码进行响应，并包括与客户端使用的身份验证方案相匹配的``WWW-Authenticate''响应头字段。\n\n| | |invalid_grant\n|所提供的授权授予(例如，授权代码、资源所有者凭证)或刷新令牌无效、过期、已撤销、不匹配授权请求中使用的重定向URI，或已向其他客户机发出。\n\n| | |unauthorized_client |经过身份验证的客户端无权使用此授权授权类型。\n\n| | |unsupported_grant_type |授权服务器不支持授权授权类型。\n\n| | |invalid_scope\n|请求的范围无效、未知、格式错误或超出了资源所有者授予的范围。\n\n|error_description |OPTIONAL |- |提供附加信息的人类可读ASCII\n[USASCII]文本，用于帮助客户端开发人员理解所发生的错误。\n\n|error_uri |OPTIONAL |-\n|一种带有错误信息的可读网页的URI标识，用于向客户端开发人员提供有关错误的附加信息。\n|===\n\n=== 密码模式\n\n这种模式可以理解成我们普通应用的用户名密码登录，在第三方接入的时候不建议使用这种模式，但是如果是自己的应用，那么这种模式是最为简单方便快捷的了。步骤只有一个：\n\n[IMPORTANT]\n注意：以下所有请求都必须在请求头中携带上面所说的客户端加密信息！\n\n* 用户携带用户名密码请求授权服务器，验证通过后下发令牌\n\n他只需要一个请求，所以她只有一个令牌端点：\n\n==== 令牌端点\n\n* /oauth/token：令牌端点，携带如下参数请求即可：\n\n[cols=\",,\",options=\"header\",]\n|===\n|请求参数 |是否必填 |描述\n|grant_type |REQUIRED |使用的密码模式，值固定为``password''\n|username |REQUIRED |用户名\n|password |REQUIRED |密码\n|scope |OPTIONAL |请求权限范围\n|===\n\n请求成功和失败的响应同授权码模式。\n\n=== 安全考虑\n\n[IMPORTANT]\n注意：以下所有请求都必须在请求头中携带上面所说的客户端加密信息！\n\n作为一个灵活且可扩展的框架，OAuth 的安全考虑取决于许多因素。spring\nsecurity oauth 为我们提供了一些默认的端点如下：\n\n* /oauth/authorize：授权端点\n* /oauth/token：令牌端点\n* /oauth/token：令牌端点也同时拥有刷新用户的功能，请求参数如下：\n\n[cols=\",,\",options=\"header\",]\n|===\n|参数名称 |是否必填 |描述\n|grant_type |REQUIRED |固定值为``refresh_token''\n|refresh_token |REQUIRED |请求到 token 时传过来的 refresh_token\n|===\n\n* /oauth/confirm_access：用户确认授权提交端点\n* /oauth/error：授权服务错误信息端点\n* /oauth/check_token：用于资源服务访问的令牌解析端点，请求参数如下：\n\n[cols=\",,\",options=\"header\",]\n|===\n|参数名称 |是否必填 |描述\n|token |REQUIRED |得到的有效的令牌\n|===\n\n* /oauth/token_key：提供公有密匙的端点，如果你使用JWT令牌的话\n\n== 技术选型\n\n* 核心框架：spring boot\n* 构建工具：maven\n* 应用框架：spring boot data jpa\n* 数据库：mysql\n* web： spring boot web\n* 测试框架：junit5、spring boot test\n* 开发工具：idea\n* 安全框架：spring security oauth2\n\n== 在这之前\n\n我们需要对项目的基本初始化，也就是使用 idea 创建我们 spring boot 项目\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190709093428.png[1]\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709093631.png[2]\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709094513.png[3]\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709095136.png[4]\n\n父项目忘记添加 web 依赖了，如下：\n\n[source,xml]\n----\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n----\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709100047.png[5]\n\nimage:https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190709101728.png[image]\n\n可选，配置阿里云国内源仓库\n\n[source,xml]\n----\n<repositories>\n    <!--阿里云主仓库，代理了maven central和jcenter仓库-->\n    <repository>\n        <id>aliyun</id>\n        <name>aliyun</name>\n        <url>https://maven.aliyun.com/repository/public</url>\n        <releases>\n            <enabled>true</enabled>\n        </releases>\n        <snapshots>\n            <enabled>false</enabled>\n        </snapshots>\n    </repository>\n    <!--阿里云代理Spring 官方仓库-->\n    <repository>\n        <id>spring-milestones</id>\n        <name>Spring Milestones</name>\n        <url>https://maven.aliyun.com/repository/spring</url>\n        <releases>\n            <enabled>true</enabled>\n        </releases>\n        <snapshots>\n            <enabled>false</enabled>\n        </snapshots>\n    </repository>\n</repositories>\n<!--远程插件库-->\n<pluginRepositories>\n    <!--阿里云代理Spring 插件仓库-->\n    <pluginRepository>\n        <id>spring-plugin</id>\n        <name>spring-plugin</name>\n        <url>https://maven.aliyun.com/repository/spring-plugin</url>\n        <releases>\n            <enabled>true</enabled>\n        </releases>\n        <snapshots>\n            <enabled>false</enabled>\n        </snapshots>\n    </pluginRepository>\n</pluginRepositories>\n----\n\n[IMPORTANT]\n注意：请自行配置 lombok 支持！！！\n\n这样，我们的父项目基本就构建完成了\n\n我们下一篇回来完成第二件事，spring security oauth2 自动配置实现。\n\n","fields":{"slug":"/articles/2019/07/14/1563082088646.html","birthTime":"2019-07-14T05:28:08.733Z","modifiedTime":"2020-01-20","year":2019},"document":{"title":"Spring Security Oauth2 从零到一完整实践（一）"}},{"content":"= Spring Security Oauth2 从零到一完整实践（三）授权服务器\n:page-description: Spring Security Oauth2 从零到一完整实践（三）授权服务器\n:page-category: spring\n:page-image: https://img.hacpai.com/bing/20180702.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2019/07/14/1563096109753.html\n:page-created: 1563096109805\n:page-modified: 1587796069182\n:toc:\n\n____\n*注意注意：本文章适用于5.3以前的spring security以及spring boot 2.3.x\n以前的 oauth，以下内容应该为过时！spring 提供新的 oauth2\n授权服务器，目前正在https://spring.io/blog/2019/11/14/spring-security-oauth-2-0-roadmap-update[实验性阶段]，同时资源服务器由\noauth 模块迁移到 spring security 之内。*\n____\n\n前面说了自动配置，现在就是来说自定义配置啦，这个是十分重要的一节，可以说\noauth2\n的核心就是授权服务器了，所有的角色都是围绕着授权服务器而运作的，这里基本包含了资源服务器的所有配置。\n\n*注意：spring security oauth2 模块已经过期，见\nhttps://github.com/spring-projects/spring-security-oauth#-deprecation-notice-[github]。*\n\n====\nGitHub 地址： https://github.com/lizhongyue248/spring-security-oauth2-demo[spring-security-oauth2-demo]\n\n博客地址： https://echocow.cn[echocow.cn]\n====\n\n== 系列文章\n\n[arabic]\n. https://echocow.cn/articles/2019/07/14/1563082088646.html[较为详细的学习\noauth2 的四种模式其中的两种授权模式]\n. https://echocow.cn/articles/2019/07/14/1563082247386.html[spring boot\noauth2 自动配置实现]\n. spring security oauth2 授权服务器配置\n. https://echocow.cn/articles/2019/07/20/1563611848587.html[spring\nsecurity oauth2 资源服务器配置]\n. https://echocow.cn/articles/2019/07/30/1564498598952.html[spring\nsecurity oauth2 自定义授权模式（手机、邮箱等）]\n. https://echocow.cn/articles/2020/01/20/1579503807596.html[spring\nsecurity oauth2 踩坑记录]\n\n== spring security oauth2 授权服务器\n\n我们首先再次回顾下授权服务器的详细作用：\n\n[arabic]\n. 客户端的验证与授权\n. 令牌的生成与发放\n. 令牌的校验与更新\n\n所以我们以下的操作都会围绕 *客户端* 与 *令牌* 来完成。\n\n____\n*注意：以下授权服务器全默认在 8000 端口运行！！！*\n____\n\n现在我们需要进行的就是授权服务器配置实现，我们完成项目的初始化，和之前创建完全一样，创建完成后，*我们把\n8080 端口修改为 8000 端口*，然后项目结构如下：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709212205.png[new]\n\n同时添加一下如下依赖\n\n[source,xml]\n----\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-security</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.security.oauth.boot</groupId>\n        <artifactId>spring-security-oauth2-autoconfigure</artifactId>\n        <version>${spring.boot.version}</version>\n    </dependency>\n</dependencies>\n----\n\n既然是授权服务器，那么我们也就不用把它注册为资源服务器了，因为我们不对外暴露任何资源，仅仅只是为了令牌的下发，不需要做资源保护。\n\n在我们配置授权服务器之前，需要先进行我们前面遇到过的配置 spring security\nweb 安全，复制一下上一次的配置，就不截图了，如下：\n\n[source,java]\n----\npackage cn.echocow.oauth.authorization.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.core.userdetails.User;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.security.provisioning.InMemoryUserDetailsManager;\n\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    /**\n     * 密码加密方式，spring 5 后必须对密码进行加密\n     *\n     * @return BCryptPasswordEncoder\n     */\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n\n    /**\n     * 创建两个内存用户\n     * 用户名 user 密码 123456 角色 ROLE_USER\n     * 用户名 admin 密码 admin 角色 ROLE_ADMIN\n     *\n     * @return InMemoryUserDetailsManager\n     */\n    @Bean\n    @Override\n    public UserDetailsService userDetailsService() {\n        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();\n        manager.createUser(User.withUsername(\"user\")\n                .password(passwordEncoder().encode(\"123456\"))\n                .authorities(\"ROLE_USER\").build());\n        manager.createUser(User.withUsername(\"admin\")\n                .password(passwordEncoder().encode(\"admin\"))\n                .authorities(\"ROLE_ADMIN\").build());\n        return manager;\n    }\n\n}\n----\n\n上一部分我们知道 `spring-security-oauth2-autoconfigure`\n是自动配置的包，通过陪配置文件就可以完成一个授权服务器和资源服务器，现在我们需要来自定义他的授权服务器该怎么做呢？我们需要做的就是配置属于我们自己的\n`AuthorizationServerConfigurer`了，当 spring\n扫描到我们实现的配置以后，他就不回去自动配置 oauth2\n了。为什么这么说呢？可以通过查看他的自动配置的源码你就会发现为什么，如下：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713151107.png[bean]\n\n所以，如果我们配置了 `AuthorizationServerConfigurer`\n的bean，它是不会执行自动配置的。我们现在需要自定义，所以就要来实现一下这个接口。当然，spring\n提供了相应的适配器来供我们实现这个接口的，他就是\n`AuthorizationServerConfigurerAdapter`，我们只要继承这个类即可。我们来看看里面的三个配置方法：\n\n[width=\"100%\",cols=\"34%,33%,33%\",options=\"header\",]\n|===\n|方法名 |参数 |描述\n|configure |AuthorizationServerSecurityConfigurer\n|配置授权服务器的安全信息，比如 ssl 配置、checktoken\n是否允许访问，是否允许客户端的表单身份验证等。\n\n|configure |ClientDetailsServiceConfigurer |配置客户端的\nservice，也就是应用怎么获取到客户端的信息，一般来说是从内存或者数据库中获取，已经提供了他们的默认实现，你也可以自定义。\n\n|configure |AuthorizationServerEndpointsConfigurer\n|配置授权服务器各个端点的非安全功能，如令牌存储，令牌自定义，用户批准和授权类型。如果需要密码授权模式，需要提供\n`AuthenticationManager` 的 bean。\n|===\n\n所以为了方便，我们先在我们的 `SecurityConfig` 配置中创建一个\n`AuthenticationManager` Bean，直接调用父类的方法获取即可，如下：\n\n[source,java]\n----\n/**\n * 认证管理\n *\n * @return 认证管理对象\n * @throws Exception 认证异常信息\n */\n@Override\n@Bean  // 重点是这行，父类并没有将它注册为一个 Bean\npublic AuthenticationManager authenticationManagerBean() throws Exception {\n    return super.authenticationManagerBean();\n}\n----\n\n接下来就是我们配置我们自己的授权服务器了，我们要完成如下的几种授权服务器配置\n\n* 基于内存的客户端信息与令牌存储\n* 基于 mysql 的客户端信息与令牌存储\n* 基于 redis 的令牌存储\n* 基于 jwt 的令牌生成与配置\n* 授权服务器小扩展\n\n____\n*以上可以自由组合，例如 mysql 客户端配合 redis 令牌存储等。*\n\n*由于内容过多，防止由于依赖的问题导致不好运行查看效果，我每一种方式，都将它放在新的模块之中，模块的创建将会省略不写。分别为\n内存、mysql、redis、jwt 四个模块*\n____\n\n不过在那之前，我们需要准备一个已经继承\n`AuthorizationServerConfigurerAdapter`\n的配置类，同时上面提到过，如果需要密码模式，我们要提供\n`AuthenticationManager` 的\nbean，所以我们在这里提前进行配置下，后面就不再进行赘述，如下：\n\n[source,java]\n----\n@Configuration\n@RequiredArgsConstructor\n@EnableAuthorizationServer\npublic class Oauth2AuthorizationServerConfig\n    extends AuthorizationServerConfigurerAdapter {\n\n    private final @NonNull AuthenticationManager authenticationManager;\n\n    @Override\n    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {\n        endpoints.authenticationManager(this.authenticationManager);\n    }\n}\n----\n\n现在的项目结构如下：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713164716.png[authconfig]\n\n____\n注意，为了方便，后面的测试均使用密码模式进行测试！\n____\n\n=== 基于内存的客户端信息与令牌存储\n\n____\n代码参见项目模块 spring-security-oauth2-authorization\n____\n\n我们将在内存中存储和读取客户端信息以及下发的令牌信息：\n\n* *优点*：速度快，读取速度和写入速度都很快，配置也极其方便。\n* *缺点*：扩展性差，需要在代码中配置，重启应用后已经下发的令牌失效。\n* *适用场景*：小型不易改变的应用，授权服务器和资源服务器一体的应用。\n\n==== 客户端信息\n\n对于客户端信息的配置，你完全可以通过\n`org.springframework.boot.autoconfigure.security.oauth2.authserver.OAuth2AuthorizationServerConfiguration`\n这个类学习到，对于客户端的配置我们主要实现对参数为\n`ClientDetailsServiceConfigurer` 的方法配置，我们分来两个方式来学习：\n\n[arabic]\n. 直接代码写死配置客户端信息\n. 读取配置文件中的客户端信息\n\n===== 代码配置\n\n我们需要以下几步完成配置\n\n[arabic]\n. 构建内存存储的 `ClientDetailsService` 实现类（spring security oauth\n已经提供）。\n. 利用构建出来的进行配置客户端。\n\n所以我们先进行第一步，我们获取他的建造者：\n\n[source,java]\n----\nInMemoryClientDetailsServiceBuilder builder = clients.inMemory();\n----\n\n然后通过他构建一个内存客户端：\n\n[source,java]\n----\nbuilder\n        // 构建一个 id 为 oauth2 的客户端\n        .withClient(\"oauth2\")\n        // 设置她的密钥，加密后的\n        .secret(\"$2a$10$wlgcx61faSJ8O5I4nLiovO9T36HBQgh4RhOQAYNORCzvANlInVlw2\")\n        // 设置允许访问的资源 id\n        .resourceIds(\"oauth2\")\n        // 授权的类型\n        .authorizedGrantTypes(\"password\", \"authorization_code\", \"refresh_token\")\n        // 可以授权的角色\n        .authorities(\"ROLE_ADMIN\", \"ROLE_USER\")\n        // 授权的范围\n        .scopes(\"all\")\n        // token 有效期\n        .accessTokenValiditySeconds(Math.toIntExact(Duration.ofHours(1).getSeconds()))\n        // 刷新 token 的有效期\n        .refreshTokenValiditySeconds(Math.toIntExact(Duration.ofHours(1).getSeconds()))\n        // 授权码模式的重定向地址\n        .redirectUris(\"http://example.com\");\n----\n\n看起来她配置的东西和我们在配置文件中写的东西是基本一致的，不过密码现在是加密后的了，如何获取呢？我是写了一个测试类如下：\n\n[source,java]\n----\npackage cn.echocow.oauth.authorization;\n\nimport org.junit.Test;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\n\n/**\n * 获取加密后的密码\n *\n * @author <a href=\"https://echocow.cn\">EchoCow</a>\n * @date 19-7-13 下午4:36\n */\npublic class PasswordTest {\n\n    @Test\n    public void password() {\n        // 每次打印的结果都不一样，不影响\n        System.out.println(new BCryptPasswordEncoder().encode(\"oauth2\"));\n    }\n\n}\n----\n\n然后将打印的密码填入即可，*不过值得注意的是，她每次的加密结果都是不一样的*。现在的文件如下：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713164857.png[file]\n\n我们启动然后测试一下：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713165430.png[test]\n\n这个就从内存中存存储和读取客户端信息了，如果多个客户端呢？复制一遍就好啦\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713165639.png[more]\n\n亦或者完全使用链式结构如下：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713170359.png[all]\n\n===== 配置文件配置\n\n对于配置文件配置其实他已经有了默认的实现了，但是只能对一个客户端进行配置，我们需要多个的时候怎么办呢？就需要我们来扩展了，这个实现其实很简单，就是一个配置类和一个循环的实现，我们来捋一下步骤。\n\n[arabic]\n. 读取配置文件，多个客户端信息\n. 逐个配置客户端信息\n\n先来书写配置类，使用 lombok 自动生成 get/set 等方法：\n\n[source,java]\n----\n@Data\n@Configuration\n@ConfigurationProperties(\"application.security.oauth\")\npublic class ClientDetails {\n    private List<BaseClientDetails> client;\n}\n----\n\n书写配置文件：\n\n[source,yml]\n----\napplication:\n  security:\n    oauth:\n      client[0]:\n        registered-redirect-uri: http://example.com\n        # 客户端 id\n        client-id: client1\n        # 客户端密钥\n        client-secret: $2a$10$wlgcx61faSJ8O5I4nLiovO9T36HBQgh4RhOQAYNORCzvANlInVlw2\n        # 授权范围\n        scope: all\n        # token 有效期\n        access-token-validity-seconds: 6000\n        # 刷新 token 的有效期\n        refresh-token-validity-seconds: 6000\n        # 允许的授权类型\n        grant-type: authorization_code,password,refresh_token\n        # 可以访问的资源 id\n        resource-ids: oauth2\n      client[1]:\n        registered-redirect-uri: http://example.com\n        # 客户端 id\n        client-id: client2\n        # 客户端密钥\n        client-secret: $2a$10$wlgcx61faSJ8O5I4nLiovO9T36HBQgh4RhOQAYNORCzvANlInVlw2\n        # 授权范围\n        scope: all\n        # token 有效期\n        access-token-validity-seconds: 6000\n        # 刷新 token 的有效期\n        refresh-token-validity-seconds: 6000\n        # 允许的授权类型\n        grant-type: authorization_code,password,refresh_token\n        # 可以访问的资源 id\n        resource-ids: oauth2\n----\n\n为了防止混淆，我单独写了一个方法来配置，如下：\n\n[source,java]\n----\nprivate void configClient(ClientDetailsServiceConfigurer clients) throws Exception {\n        InMemoryClientDetailsServiceBuilder builder = clients.inMemory();\n        for (BaseClientDetails client : clientDetails.getClient()) {\n            ClientDetailsServiceBuilder<InMemoryClientDetailsServiceBuilder>.ClientBuilder clientBuilder =\n                    builder.withClient(client.getClientId());\n            clientBuilder\n                    .secret(client.getClientSecret())\n                    .resourceIds(client.getResourceIds().toArray(new String[0]))\n                    .authorizedGrantTypes(client.getAuthorizedGrantTypes().toArray(new String[0]))\n                    .authorities(\n                            AuthorityUtils.authorityListToSet(client.getAuthorities())\n                                    .toArray(new String[0]))\n                    .scopes(client.getScope().toArray(new String[0]));\n            if (client.getAutoApproveScopes() != null) {\n                clientBuilder.autoApprove(\n                        client.getAutoApproveScopes().toArray(new String[0]));\n            }\n            if (client.getAccessTokenValiditySeconds() != null) {\n                clientBuilder.accessTokenValiditySeconds(\n                        client.getAccessTokenValiditySeconds());\n            }\n            if (client.getRefreshTokenValiditySeconds() != null) {\n                clientBuilder.refreshTokenValiditySeconds(\n                        client.getRefreshTokenValiditySeconds());\n            }\n            if (client.getRegisteredRedirectUri() != null) {\n                clientBuilder.redirectUris(\n                        client.getRegisteredRedirectUri().toArray(new String[0]));\n            }\n        }\n    }\n----\n\n最终如下：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713174017.png[result]\n\n然后运行测试一下两个客户端\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713174157.png[2]\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713174105.png[1]\n\n这样也实现了效果\n\n==== 令牌存储\n\n其实他默认的令牌存储就是使用到内存存储，所以我们无需配置～何以见得呢？我们来简单分析一下。\n\n在前面我们说过 `AuthorizationServerConfigurer`\n的三个配置方法，其中就有一个参数为\n`AuthorizationServerEndpointsConfigurer`\n类型的配置方法，它可以配置我们令牌信息，所以我们就要把目标放在他的上面看看，去找一找他是如何配置的。\n\n他的核心配置类是\n`org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerEndpointsConfiguration`，这个类内容很多，我们只关注他是默认配置的为什么是内存的，首先找到一个工厂类：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713175120.png[factory]\n\n我们跟进去看看：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713175259.png[default]\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713175517.png[再进去看看]\n\nimage:https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713175828.png[image]\n\n这样我们就找到她是如何默认创建的了。\n\n=== 基于 mysql 的客户端信息与令牌存储\n\n____\n代码参见项目模块 spring-security-oauth2-authorization-mysql\n\n模块创建步骤省略\n____\n\n我们将在 mysql 中存储和读取客户端信息以及下发的令牌信息：\n\n* *优点*：扩展性极高，不用修改代码与重启就可以完成客户端管理，安全性高。\n* *缺点*：使用数据库速度过慢，多客户端高并发情况下可能会造成性能瓶颈\n* *适用场景*：中大型项目，独立且完整的授权服务器。\n\n在这之前你要添加如下的 mysql 和 jdbc 依赖\n\n[source,xml]\n----\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency>\n----\n\n配置文件如下，我的 mysql 版本为 8.0 ，url 参数请自行修改\n\n[source,yml]\n----\nserver:\n  port: 8000\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://127.0.0.1:3306/auth?useUnicode=true&characterEncoding=UTF-8&useOldAliasMetadataBehavior=true&autoReconnect=true&serverTimezone=UTC\n    username: root\n    password: 123456\n    # 用来初始化数据库的，如果不存在表就自动创建\n    initialization-mode: ALWAYS\n    schema: classpath:ddl.sql\n----\n\n导入\nhttps://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/test/resources/schema.sql[官方提供]\n的 h2 的表，由于官方使用的是 h2 的数据库，有些字段类型不对，我修改成\nmysql 的后如下：\n\n[source,sql]\n----\n-- used in tests that use MYSQL\ncreate table if not exists oauth_client_details (\n  client_id VARCHAR(256) PRIMARY KEY,\n  resource_ids VARCHAR(256),\n  client_secret VARCHAR(256),\n  scope VARCHAR(256),\n  authorized_grant_types VARCHAR(256),\n  web_server_redirect_uri VARCHAR(256),\n  authorities VARCHAR(256),\n  access_token_validity INTEGER,\n  refresh_token_validity INTEGER,\n  additional_information VARCHAR(4096),\n  autoapprove VARCHAR(256)\n);\n\ncreate table if not exists oauth_client_token (\n  token_id VARCHAR(256),\n  token BLOB,\n  authentication_id VARCHAR(256) PRIMARY KEY,\n  user_name VARCHAR(256),\n  client_id VARCHAR(256)\n);\n\ncreate table if not exists oauth_access_token (\n  token_id VARCHAR(256),\n  token BLOB,\n  authentication_id VARCHAR(256) PRIMARY KEY,\n  user_name VARCHAR(256),\n  client_id VARCHAR(256),\n  authentication BLOB,\n  refresh_token VARCHAR(256)\n);\n\ncreate table if not exists oauth_refresh_token (\n  token_id VARCHAR(256),\n  token BLOB,\n  authentication BLOB\n);\n\ncreate table if not exists oauth_code (\n  code VARCHAR(256), authentication BLOB\n);\n\ncreate table if not exists oauth_approvals (\n    userId VARCHAR(256),\n    clientId VARCHAR(256),\n    scope VARCHAR(256),\n    status VARCHAR(10),\n    expiresAt TIMESTAMP,\n    lastModifiedAt TIMESTAMP\n);\n\n\n-- customized oauth_client_details table\ncreate table if not exists ClientDetails (\n  appId VARCHAR(256) PRIMARY KEY,\n  resourceIds VARCHAR(256),\n  appSecret VARCHAR(256),\n  scope VARCHAR(256),\n  grantTypes VARCHAR(256),\n  redirectUrl VARCHAR(256),\n  authorities VARCHAR(256),\n  access_token_validity INTEGER,\n  refresh_token_validity INTEGER,\n  additionalInformation VARCHAR(4096),\n  autoApproveScopes VARCHAR(256)\n);\n----\n\n先给大家介绍一下几张表的具体意思和结构：\n\noauth_client_details ===> 客户端信息\n\n[width=\"100%\",cols=\"34%,33%,33%\",options=\"header\",]\n|===\n|列名 |类型 |描述\n|client_id（主键） |VARCHAR(256) |主键,必须唯一,不能为空.\n用于唯一标识每一个客户端(client);\n在注册时必须填写(也可由服务端自动生成).\n对于不同的grant_type,该字段都是必须的.\n在实际应用中的另一个名称叫appKey,与client_id是同一个概念.\n\n|resource_ids |VARCHAR(256)\n|客户端所能访问的资源id集合,多个资源时用逗号(,)分隔\n\n|client_secret |VARCHAR(256) |用于指定客户端(client)的访问密匙;\n在注册时必须填写(也可由服务端自动生成).\n对于不同的grant_type,该字段都是必须的.\n在实际应用中的另一个名称叫appSecret,与client_secret是同一个概念.\n\n|scope |VARCHAR(256)\n|指定客户端申请的权限范围,可选值包括read,write,trust;若有多个权限范围用逗号(,)分隔,如:\n``read,write''.\n\n|authorized_grant_types |VARCHAR(256)\n|指定客户端支持的grant_type,可选值包括authorization_code,password,refresh_token,implicit,client_credentials,若支持多个grant_type用逗号(,)分隔,如:\n``authorization_code,password''.\n在实际应用中,当注册时,该字段是一般由服务器端指定的,而不是由申请者去选择的,\n\n|web_server_redirect_uri |VARCHAR(256) |客户端的重定向URI,可为空,\n当grant_type为authorization_code或implicit时,\n在Oauth的流程中会使用并检查与注册时填写的redirect_uri是否一致.\n\n|authorities |VARCHAR(256) |指定客户端所拥有的Spring\nSecurity的权限值,可选, 若有多个权限值,用逗号(,)分隔, 如: ``ROLE_ADMIN''\n\n|access_token_validity |INTEGER\n|设定客户端的access_token的有效时间值(单位:秒),可选,\n若不设定值则使用默认的有效时间值(60 * 60 * 12, 12小时).\n\n|refresh_token_validity |INTEGER\n|设定客户端的refresh_token的有效时间值(单位:秒),可选,\n若不设定值则使用默认的有效时间值(60 * 60 * 12, 12小时).\n\n|additional_information |VARCHAR(4096)\n|这是一个预留的字段,在Oauth的流程中没有实际的使用,可选,但若设置值,必须是JSON格式的数据,在实际应用中,\n可以用该字段来存储关于客户端的一些其他信息\n\n|autoapprove |VARCHAR(256) |设置用户是否自动Approval操作, 默认值为\n`false', 可选值包括 `true',`false',\n`read',`write'.该字段只适用于grant_type=``authorization_code''的情况,当用户登录成功后,若该值为’true’或支持的scope值,则会跳过用户Approve的页面,直接授权.\n|===\n\noauth_client_token ===> 客户端系统中存储从服务端获取的 token 数据\n\n[width=\"100%\",cols=\"15%,15%,70%\",options=\"header\",]\n|===\n|字段名 |字段类型 |描述\n|token_id |VARCHAR(256) |从服务器端获取到的access_token的值.\n\n|token |BLOB |这是一个二进制的字段,\n存储的数据是OAuth2AccessToken.java对象序列化后的二进制数据.\n\n|authentication_id |VARCHAR(256) |该字段具有唯一性,\n是根据当前的username(如果有),client_id与scope通过MD5加密生成的.\n具体实现请参考DefaultClientKeyGenerator.java类.\n\n|user_name |VARCHAR(256) |登录时的用户名\n\n|client_id |VARCHAR(256) |客户端 id\n|===\n\noauth_access_token ===> 生成的 token 数据\n\n[width=\"100%\",cols=\"15%,15%,70%\",options=\"header\",]\n|===\n|字段名 |字段类型 |描述\n|token_id |VARCHAR(256) |从服务器端获取到的access_token的值.\n\n|token |BLOB |存储将OAuth2AccessToken.java对象序列化后的二进制数据,\n是真实的AccessToken的数据值.\n\n|authentication_id |VARCHAR(256) |该字段具有唯一性,\n其值是根据当前的username(如果有),client_id与scope通过MD5加密生成的.\n\n|user_name |VARCHAR(256) |登录时的用户名,\n若客户端没有用户名(如grant_type=``client_credentials''),则该值等于client_id\n\n|client_id |VARCHAR(256) |客户端 id\n\n|authentication |BLOB |存储将 OAuth2Authentication\n对象序列化后的二进制数据.\n\n|refresh_token |VARCHAR(256)\n|该字段的值是将refresh_token的值通过MD5加密后存储的.\n|===\n\noauth_refresh_token ===> 刷新 token\n\n[width=\"100%\",cols=\"15%,15%,70%\",options=\"header\"]\n|===\n|字段名 |字段类型 |描述\n|token_id |VARCHAR(256)\n|该字段的值是将refresh_token的值通过MD5加密后存储的.\n\n|token |BLOB |存储将OAuth2RefreshToken.java对象序列化后的二进制数据.\n\n|authentication |BLOB\n|存储将OAuth2Authentication.java对象序列化后的二进制数据.\n|===\n\noauth_code ===> 服务端生成的 code 值\n\n[cols=\",,\",options=\"header\",]\n|===\n|字段名 |字段类型 |描述\n|code |VARCHAR(256) |存储服务端系统生成的code的值(未加密).\n|===\n\noauth_approvals ===> 授权同意信息\n\n[cols=\",,\",options=\"header\",]\n|===\n|字段名 |字段类型 |描述\n|userId |VARCHAR(256) |用户 id\n|clientId |VARCHAR(256) |客户端 id\n|scope |VARCHAR(256) |请求的范围\n|status |VARCHAR(10) |授权的状态\n|expiresAt |TIMESTAMP |时间\n|lastModifiedAt |TIMESTAMP |最后修改的时间\n|===\n\n最后一张 ClientDetails 是我们要自定义他的 表\n的情况，在我们需要自定义的时候使用，但是目前我们暂时不去自定义，所以无用。\n\n所以你现在的项目结构应该如下\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713182417.png[mysql]\n\n记得启动测试一下，确定不报错。\n\n接下来我们就是来进行配置了，同样的，分为客户端信息配置和令牌配置\n\n==== 客户端信息\n\n同样，对于客户端的配置我们主要实现对参数为\n`ClientDetailsServiceConfigurer` 的方法进行配置，我们需要完成以下两步：\n\n[arabic]\n. 构建一个 jdbc 的 `ClientDetailsService`，通过他来链接数据库。\n. 将它配置进 `ClientDetailsServiceConfigurer` 之中。\n\n我们首先先来配置一个 jdbc 的 `ClientDetailsService`\n，非常简单，因为他已经提供了默认的实现了的，构建方式如下：\n\n[source,java]\n----\n// 数据源\nprivate final @NonNull DataSource dataSource;\n\n/**\n * 声明 ClientDetails实现\n *\n * @return ClientDetailsService\n */\n@Bean\npublic ClientDetailsService clientDetails() {\n    return new JdbcClientDetailsService(dataSource);\n}\n----\n\n然后将他配置进 `ClientDetailsServiceConfigurer` 之中，如下：\n\n[source,java]\n----\n@Override\npublic void configure(ClientDetailsServiceConfigurer clients) throws Exception {\n    clients.withClientDetails(clientDetails());\n}\n----\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713194015.png[config]\n\n然后我们启动并添加一条客户端信息\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713193812.png[添加一条数据]\n\n用密码模式测试一下\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713194118.png[test]\n\n然后我们用授权码模式测试一下，访问地址\nhttp://localhost:8000/oauth/authorize?response_type=code&client_id=oauth2&redirect_uri=http://example.com&scope=all\n然后登录\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713194247.png[login]\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713194303.png[code]\n\n这样就获取到授权码了，这样就完成了客户端的 mysql 存储，但是现在 token\n还是存在内存中的，下面我们将它存在数据库中。\n\n==== 令牌存储\n\n我们使用 mysql\n对令牌进行存储有个最大的好处，就是在授权服务器重启后，以前下发的令牌依旧有效，不用让用户重复登录。和客户端一样配置十分简单，它主要配置参数为\n`AuthorizationServerEndpointsConfigurer 的`配置方法。同样也只需要两步：\n\n[arabic]\n. 构建一个 jdbc 的 `TokenStore`，通过他来链接数据库。\n. 将它配置进 `AuthorizationServerEndpointsConfigurer` 之中。\n\n我们先来完成第一步，如下：\n\n[source,java]\n----\n/**\n * 声明 jdbc TokenStore实现\n *\n * @return JdbcTokenStore\n */\n@Bean\npublic TokenStore jdbcTokenStore() {\n    return new JdbcTokenStore(dataSource);\n}\n----\n\n然后完成第二步，如下：\n\n[source,java]\n----\n@Override\npublic void configure(AuthorizationServerEndpointsConfigurer endpoints) {\n    endpoints.authenticationManager(this.authenticationManager)\n        .tokenStore(jdbcTokenStore());\n}\n----\n\n所以现在应该是这样的\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713195102.png[now]\n\n运行测试一下，先请求下 token\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190713195157.png[token]\n\n看一下表有没有 token 存进去\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190713195304.png[data]\n\n会发现两张表的数据存进去了，来看看授权码呢？\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713195501.png[code]\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713195644.png[get]\n\n这就完成使用 mysql 存储令牌的配置。\n\n=== 基于 redis 的令牌存储\n\n____\n代码参见项目模块 spring-security-oauth2-authorization-redis\n\n模块创建步骤省略\n____\n\n我们将在**内存中存储和读取客户端信息**以及**在 redis 中存储令牌信息**：\n\n* *优点*：速度快，项目重启 token 依旧有效且适用于分布式场景。\n* *缺点*：想不到。。。\n* *适用场景*：通用。\n\n在这之前你要添加如下的 redis 依赖\n\n[source,xml]\n----\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n----\n\n同时修改你的配置文件：\n\n[source,yml]\n----\nserver:\n  port: 8000\n\n#如果有密码记得设置，没有就不管\n#spring:\n  #redis:\n    #password: 123456\n----\n\n然后复制一下第一个模块的内存客户端，现在的项目结构如下：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713200959.png[next]\n\n同样我们只需要两步，配置token store，让他生效即可\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713210312.png[config]\n\n运行测试一下\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713210045.png[请求]\n\n查看下 redis\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713210107.png[redis]\n\n这样我们就将 token 存粗进 redis 内了！\n\n=== 基于 jwt 的令牌生成与配置\n\n____\n代码参见项目模块 spring-security-oauth2-authorization-jwt\n\n模块创建步骤省略\n____\n\n我们将在**内存中存储和读取客户端信息**与**存储令牌信息**，使用 jwt\n规范化 token：\n\n* *优点*：jwt 可以加密，可以携带更多的信息。\n* *缺点*：token 会变得比较长\n* *适用场景*：通用。\n\n具体什么是 jwt，可以参考 https://www.jianshu.com/p/576dbf44b2ae[什么是\nJWT – JSON WEB TOKEN] 这篇文章，很不错。我们要实现的就是将现在的\n`access_token` 和 `refresh_token` 两个字段使用 jwt 代替。jwt的第三部分\n`signature` 是一个签证信息，这个签证信息由三部分组成：\n\n* header (base64后的)\n* payload (base64后的)\n* secret\n\n这个部分需要base64加密后的header和base64加密后的payload使用\n`.`连接组成的字符串，然后通过header中声明的加密方式进行加盐 `secret`\n组合加密，然后就构成了jwt的第三部分。而 `secret`\n进行组合加密就涉及到两种加密方式：\n\n* 对称加密：又称私钥加密，即信息的发送方和接收方用一个密钥去加密和解密数据。它的最大优势是加/解密速度快，适合于对大数据量进行加密，对称加密的一大缺点是密钥的管理与分配，换句话说，如何把密钥发送到需要解密你的消息的人的手里是一个问题。在发送密钥的过程中，密钥有很大的风险会被黑客们拦截。现实中通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的人。而在\nspring security 之中的相应的实现类是\n`org.springframework.security.jwt.crypto.sign.MacSigner`\n+\n[source,java]\n----\nSigner  jwtSigner = new MacSigner(\"hand\");//默认HMACSHA256 算法加密\nSigner  jwtSigner = new MacSigner(\"HMACSHA256\",\"hand\");//手动设置算法\n----\n* 非对称加密：又称公钥密钥加密。非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public\nkey）和私钥（private\nkey）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。在\nspring security 之中的相应实现是\n`org.springframework.security.jwt.crypto.sign.RsaSigner`\n+\n[source,java]\n----\nKeyStoreKeyFactory keyStoreKeyFactory = new KeyStoreKeyFactory(new ClassPathResource(\"mytool.jks\"), \"mypass\".toCharArray());\nKeyPair demo = keyStoreKeyFactory.getKeyPair(\"mytool\");\nSigner jwtSigner = new RsaSigner((RSAPrivateKey)demo.getPrivate());\n----\n\n我们从三个方面学习：\n\n[arabic]\n. 使用对称密钥生成 jwt 令牌\n. 使用非对称密钥生成 jwt 令牌\n. 为 jwt 添加更多的信息\n\n在现在的模块中添加如下依赖：\n\n[source,xml]\n----\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-security</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.security.oauth.boot</groupId>\n        <artifactId>spring-security-oauth2-autoconfigure</artifactId>\n        <version>${spring.boot.version}</version>\n    </dependency>\n</dependencies>\n----\n\n配置文件如下：\n\n[source,yml]\n----\nserver:\n  port: 8000\n----\n\n初始化的结构应该如下：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713213749.png[client]\n\n==== 使用对称密钥生成 jwt 令牌\n\n从前面几次经验来看，应该知道要配置一个令牌的存储，最为核心的就是配置相应的\n`TokenStore` 了。配置 jwt 也是一样需要配置一个 `JwtTokenStore`，前面的\n`JdbcTokenStore` 需要的是数据源，那现在的 jwt\n需要的是什么呢？他需要一个叫做 *令牌转换器* 的东西，有了他我们才能够生成\njwt 格式的 token，所以我们需要如下几步：\n\n[arabic]\n. 创建 *令牌转换器*\n. 创建 `JwtTokenStore`\n. 配置进 `AuthorizationServerEndpointsConfigurer`\n\n我们先来第一步，配置令牌转换器。令牌转换器就是帮助程序在 JWT\n编码的令牌和 OAuth\n身份验证信息之间进行转换，既然我们选择对称密钥，那么我们就直接设置即可，如下：\n\n[source,java]\n----\n@Override\npublic void configure(AuthorizationServerEndpointsConfigurer endpoints) {\n    // 3. 配置进 AuthorizationServerEndpointsConfigurer\n    endpoints.authenticationManager(this.authenticationManager)\n        .tokenStore(tokenStore())\n        .accessTokenConverter(jwtAccessTokenConverter());\n}\n\n/**\n * 1. 令牌转换器，对称密钥加密\n *\n * @return JwtAccessTokenConverter\n */\n@Bean\npublic JwtAccessTokenConverter jwtAccessTokenConverter() {\n    JwtAccessTokenConverter converter = new JwtAccessTokenConverter();\n    converter.setSigningKey(\"oauth2\");\n    return converter;\n}\n\n/**\n * 2. token store 实现\n *\n * @return JwtTokenStore\n */\n@Bean\npublic TokenStore tokenStore() {\n    return new JwtTokenStore(jwtAccessTokenConverter());\n}\n----\n\n截图如下：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713221159.png[show]\n\n前面说了要用的是\n`MacSigner`，那么这里为什么没用呢？原因自然是已经为我们实现了，我们来看看他怎么实现的：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713221421.png[see]\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713221459.png[see]\n\n然后我么启动测试一下！\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713221619.png[test]\n\n我们去检验一下，检验网址：jwt.io\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713222003.png[jwt]\n\n这样就完成了对称加密的 jwt 生成\n\n==== 使用非对称密钥生成 jwt 令牌\n\n大多时候，我们更加需要的是一个安全的授权服务器，所以更加愿意选择\n非对称加密 来生成 jwt 令牌，现在我们来完成这件事，需要如下步骤：\n\n[arabic]\n. 生成密钥对\n. 创建 *令牌转换器*\n. 创建 `JwtTokenStore`\n. 配置进 `AuthorizationServerEndpointsConfigurer`\n\n我们首先利用 keytool 进行密钥对的生成\n\n[source,shell]\n----\n➜  resources git:(master) ✗ pwd\n/home/echo/IdeaProjects/spring-security-oauth2-demo/spring-security-oauth2-authorization-jwt/src/main/resources\n➜  resources git:(master) ✗ keytool -genkey -alias oauth2 -keyalg RSA -keystore oauth2.jks -keysize 2048\n输入密钥库口令:\n再次输入新口令:\n您的名字与姓氏是什么?\n  [Unknown]:  oauth2\n您的组织单位名称是什么?\n  [Unknown]:  oauth2\n您的组织名称是什么?\n  [Unknown]:  oauth2\n您所在的城市或区域名称是什么?\n  [Unknown]:  oauth2\n您所在的省/市/自治区名称是什么?\n  [Unknown]:  oauth2\n该单位的双字母国家/地区代码是什么?\n  [Unknown]:  oauth2\nCN=oauth2, OU=oauth2, O=oauth2, L=oauth2, ST=oauth2, C=oauth2是否正确?\n  [否]:  y\n\n输入 <oauth2> 的密钥口令\n        (如果和密钥库口令相同, 按回车):\n再次输入新口令:\n\nWarning:\nJKS 密钥库使用专用格式。建议使用 \"keytool -importkeystore -srckeystore oauth2.jks -destkeystore oauth2.jks -deststoretype pkcs12\" 迁移到行业标准格式 PKCS12。\n➜  resources git:(master) ✗ keytool -importkeystore -srckeystore oauth2.jks -destkeystore oauth2.jks -deststoretype pkcs12\n输入源密钥库口令:\n已成功导入别名 oauth2 的条目。\n已完成导入命令: 1 个条目成功导入, 0 个条目失败或取消\n\nWarning:\n已将 \"oauth2.jks\" 迁移到 Non JKS/JCEKS。将 JKS 密钥库作为 \"oauth2.jks.old\" 进行了备份。\n----\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713223524.png[keytool]\n\n下面就是生成公钥：\n\n[source,shell]\n----\nkeytool -list -rfc --keystore oauth2.jks | openssl x509 -inform pem -pubkey\n----\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713223957.png[public]\n\n现在应该有如下两个文件\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713224200.png[files]\n\n接下来配置增强器这些\n\n[source,java]\n----\n@Override\npublic void configure(AuthorizationServerEndpointsConfigurer endpoints) {\n    endpoints.authenticationManager(this.authenticationManager)\n        .tokenStore(tokenStore())\n        .accessTokenConverter(jwtAccessTokenConverter());\n}\n\n/**\n * 令牌转换器，非/对称密钥加密\n *\n * @return JwtAccessTokenConverter\n */\n@Bean\npublic JwtAccessTokenConverter jwtAccessTokenConverter() {\n    JwtAccessTokenConverter converter = new JwtAccessTokenConverter();\n    //  对称密钥加密\n    //  converter.setSigningKey(\"oauth2\");\n    KeyStoreKeyFactory keyStoreKeyFactory = new KeyStoreKeyFactory(\n        new ClassPathResource(\"oauth2.jks\"), \"123456\".toCharArray());\n    converter.setKeyPair(keyStoreKeyFactory.getKeyPair(\"oauth2\"));\n    return converter;\n}\n\n/**\n * token store 实现\n *\n * @return JwtTokenStore\n */\n@Bean\npublic TokenStore tokenStore() {\n    return new JwtTokenStore(jwtAccessTokenConverter());\n}\n----\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713224547.png[config]\n\n然后接下来我们进行测试，请求数据：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713225046.png[res]\n\n进行校验\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713225329.png[v]\n\n请注意提示框内的提示信息\n\n____\nPublic Key or Certificate. Enter it in plain text only if you want to\nverify a token\n\n公钥或证书。仅当您想验证令牌时，才以纯文本形式输入它\n\nPrivate Key. Enter it in plain text only if you want to generate a new\ntoken. The key never leaves your browser.\n\n私钥。只有在希望生成新令牌时，才以纯文本形式输入它。密钥永远不会离开浏览器。\n____\n\n所以我们只需要去复制公钥给他即可！～\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713230009.png[get]\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713230056.png[ok]\n\n这样 jwt\n的非对称加密其实就完成了！～这样如果资源服务器要请求我们资源，必须要有授权服务器的公钥才能够成功通过认证得到用户信息～！\n\n==== 为 jwt 添加更多的信息\n\n前面我们提到的一个优点就是能够添加许多自定义信息，我们就来添加一下这个自定义信息。这个时候我们就需要一个\n*令牌增强器*（前面的粗心打错了，，，图片改不了不好意思凑合看啦～）我们需要一个类来实现\n`TokenEnhancer` 接口，我们分为如下几步：\n\n[arabic]\n. 实现 `TokenEnhancer` 接口\n. 使用一个复合令牌增强器\n`TokenEnhancerChain`，循环遍历将其委托给增强器。\n. 配置进 `AuthorizationServerEndpointsConfigurer`\n\n[source,java]\n----\n@Component\npublic class InfoTokenEnhancer implements TokenEnhancer {\n    @Override\n    public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {\n        // 创建一个自定义信息\n        Map<String, Object> additionalInfo = new HashMap<>(1);\n        // 设置值\n        additionalInfo.put(\"organization\", authentication.getName());\n        // 存进去\n        ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(additionalInfo);\n        // 返回\n        return accessToken;\n    }\n}\n----\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713232921.png[impl]\n\n对于不是很复杂的逻辑，我更加喜欢使用 lambda 来写一个匿名内部类的方式：\n\n[source,java]\n----\n@Bean\npublic TokenEnhancer tokenEnhancer() {\n    return (accessToken, authentication) -> {\n        Map<String, Object> additionalInfo = new HashMap<>(1);\n        additionalInfo.put(\"organization\", authentication.getName());\n        ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(additionalInfo);\n        return accessToken;\n    };\n}\n----\n\n然后需要配置使用一个复合令牌增强器\n`TokenEnhancerChain`，循环遍历将其委托给增强器：\n\n[source,java]\n----\nTokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain();\ntokenEnhancerChain.setTokenEnhancers(\n    Arrays.asList(tokenEnhancer(), jwtAccessTokenConverter()));\n\nendpoints.tokenStore(tokenStore())\n    .tokenEnhancer(tokenEnhancerChain)\n    .authenticationManager(authenticationManager);\n----\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713233524.png[security]\n\n我们启动来测试一下：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190713233802.png[test]\n\n这样就完成了增强器！\n\n*这就是 jwt 的所有内容啦～他完全可以和 redis 令牌存储、mysql\n令牌存储一起使用！*\n\n=== 授权服务器小扩展\n\n____\n代码参见项目模块 spring-security-oauth2-authorization-expansion\n\n模块创建步骤省略\n____\n\n之前我们一直都是 *配置如何获取客户端信息* 和\n*令牌的生成与存储*，但其实我们还有些小的问题没有解决：\n\n[arabic]\n. /oauth/check_token 端点的开放\n. refresh_token 授权类型\n. 授权码模式登录页面的自定义\n. 授权码模式授权页面的自定义\n\n____\n为什么叫做小扩展，因为这些问题都是不需要太多的代码就能够实现的。\n____\n\n在这之前我们完成模块的初始化，添加如下依赖：\n\n[source,xml]\n----\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-security</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.security.oauth.boot</groupId>\n        <artifactId>spring-security-oauth2-autoconfigure</artifactId>\n        <version>${spring.boot.version}</version>\n    </dependency>\n</dependencies>\n----\n\n配置文件如下：\n\n[source,yml]\n----\nserver:\n  port: 8000\n----\n\n复制第一个项目的配置如下：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190714001850.png[next]\n\n确保能够启动成功且在 8000 端口\n\n==== /oauth/check_token 端点的开放\n\n这个端点的开放就要用到我们前面一直没有用的第三个方法了，参数为\n`AuthorizationServerSecurityConfigurer` 的方法，只要一句话就可以了：\n\n[source,java]\n----\n@Override\npublic void configure(AuthorizationServerSecurityConfigurer security) {\n    security\n        .checkTokenAccess(\"isAuthenticated()\");\n}\n----\n\n利用权限表达式放行即可，测试：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190714003016.png[check]\n\n==== refresh_token 授权类型\n\n如果我们直接去尝试，我们看看回报什么错\n\nimage:https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190714003147.png[image]\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190714003202.png[token]\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190714003224.png[refresh]\n\n我们明明已经把它注册为组件了，但是还是找不到。主要原因是因为授权服务器的这里的安全需要我们自己手动注入一次，我简单看啦一波源码，发现他放在\n`SharedObject` 里面的 `UserDetailsService`\n并不是我们自己构建的，可以尝试 debug\n`org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerSecurityConfiguration`\n第 83\n行，尝试几次不再授权服务器中修改都不行，只有在授权服务器中的配置修改：\n\n[source,java]\n----\n@Override\npublic void configure(AuthorizationServerEndpointsConfigurer endpoints) {\n    endpoints.authenticationManager(this.authenticationManager)\n        .userDetailsService(userDetailsService);\n}\n----\n\n修改后请求刷新：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190714010710.png[refresh]\n\n这样才能成功\n\n==== 授权码模式登录页面的自定义\n\n其实这一部分就是和 spring security\n配置自定义登录页面是一样的，如果以前使用过 spring security\n应该很快就能明白。\n\n对于授权码模式，我们重定向过去以后会有一个默认的登录页面\n\nimage::https://resources.echocow.cn/file/2019/07/14/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190714134901.png[login]\n\n但是这个登录页面有时候我们想去自定义，其实有两种方式来完成修改：\n\n* 直接使用静态文件\n* 使用模板引擎\n\n不过我们这里只说静态文件，使用模板引擎放在下面和自定义授权页面一起说。\n\n===== 自定义表单登录\n\n我们分为两步完成：\n\n[arabic]\n. 配置路径与请求\n. 填充页面与修改\n\n我们如何配置呢？其实这里使用的就是 spring security 的知识了，spring\nsecurity\n如何配置，这里就如何配置所以应该配置的类是我们之前一直复制下来的\n`SecurityConfig`：\n\n[source,java]\n----\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n    http.formLogin()\n        // 登录页面名称，他会去寻找 resources 下的 resources 和 static 目录\n        .loginPage(\"/login.html\")\n        // 登录表单提交的路径\n        .loginProcessingUrl(\"/authorization/form\")\n        .and()\n        // 关闭 csrf 防护，因为对于我们的所有请求来说，都是需要携带身份信息的\n        .csrf().disable();\n}\n----\n\n这里要关闭 csrf 防护，关于 csrf 防护请看\nhttps://blog.csdn.net/xiaoxinshuaiga/article/details/80766369[这篇文章]，在里面提到有效防护\ncsrf 的一种方式是 *在请求地址中添加 token\n并验证*，我们的类似，请求地址中添加了客户端名称和回调地址进行了验证，所以可以不用单行\ncsrf 攻击问题。\n\n然后我们需要创建一个静态的登录页面，我从网上随便下了一个模板，存放到\n`resources/static` 目录（也可以是\n`resources/resources`目录，但是路径里面两个 `resources`\n很是奇怪，所以使用 `static`），如下：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190714150345.png[html]\n\n然后我们运行试一下，请求授权码模式的地址如下：\n\n....\nhttp://localhost:8000/oauth/authorize?response_type=code&client_id=oauth2&redirect_uri=http://example.com≻ope=all\n....\n\nimage::https://resources.echocow.cn/file/2019/07/14/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190714150816.png[login]\n\n就跳转到了我们自定义的登录页面。登录尝试：\n\nimage::https://resources.echocow.cn/file/2019/07/14/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190714150928.png[success]\n\n登录成功了，但是又是丑得一的授权页面，这个我们，现在我们换一个方式，使用\n模板引擎 的方式自定义。同时如何修改授权页面\n\n===== 其他的登录方式\n\nspring security 一样，除了表单处理，还会有其他的方式，比如\nbasic，也就是对话框登录。只需要配置一步即可：\n\n[source,java]\n----\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n    http.httpBasic();\n}\n----\n\nimage::https://resources.echocow.cn/file/2019/07/14/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190714170733.png[basic]\n\n==== 授权码模式授权页面的自定义\n\n对于授权码模式的授权页面，我们必须使用模板引擎，因为他的基础还是 spring\nsecurity，所以摆脱不论 session\n的安全管理机制，使用模板引擎的方式有什么好处呢？\n\n[arabic]\n. 可以传递模板变量自定义很多地方\n. 可以自定义认证逻辑\n\n我们使用模板引擎完成两件事\n\n[arabic]\n. 自定义登录页面\n. 自定义授权页面\n\n在这之前我们要选择一个模板引擎，我选择 `thymeleaf`，其他的如\n`freemarker` 同理，添加依赖如下：\n\n[source,xml]\n----\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-thymeleaf</artifactId>\n</dependency>\n----\n\n添加唉 templates 目录\n\n===== 登录页面\n\n我们前面说到模板引擎的一个好处就是可以配置模板变量，那么我们就来试一试自定义登录的路径。我们创建一个配置类\n`SecurityProperties`，读取配置文件：\n\n[source,java]\n----\n@Data\n@Configuration\n@ConfigurationProperties(\"application.security.oauth\")\npublic class SecurityProperties {\n\n    /**\n     * 登录请求的路径，默认值 /authorization/form\n     */\n    private String loginProcessingUrl = \"/authorization/form\";\n\n}\n----\n\n把配置类放在安全配置之中，然后配置上去，如下：\n\n[source,java]\n----\nprivate final @NonNull SecurityProperties securityProperties;\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n\n    //        静态登录页面的配置\n    http.formLogin()\n        // 登录页面名称，他会去寻找 resources 下的 resources 和 static 目录\n        // 静态页面\n        //.loginPage(\"/login.html\")\n        // 模板引擎\n        .loginPage(\"/oauth/login\")\n        // 登录表单提交的路径\n        // 静态页面\n        // .loginProcessingUrl(\"/authorization/form\")\n        // 模板引擎\n        .loginProcessingUrl(securityProperties.getLoginProcessingUrl());\n    //                .and()\n    // 关闭 csrf 防护，因为对于我们的所有请求来说，都是需要携带身份信息的\n    //                .csrf().disable();\n\n}\n----\n\n这次我们选择开启 csrf\n防护，因为我们现在可以有效的控制她，当然，不开启其实影响也不大。\n\n然后我们需要一个 `OauthController` 用来接收请求以及渲染模板\n\n[source,java]\n----\n@Controller\n@RequestMapping(\"/oauth\")\n@RequiredArgsConstructor\npublic class OauthController {\n\n    private final @NonNull SecurityProperties securityProperties;\n\n    @GetMapping(\"login\")\n    public String loginView(Model model) {\n        model.addAttribute(\"action\", securityProperties.getLoginProcessingUrl());\n        return \"form-login\";\n    }\n\n}\n----\n\n添加登录页面，这里就要用到模板引擎的知识了，这个就靠大家自己下去查查资料什么的了，我的如下：\n\nimage::https://resources.echocow.cn/file/2019/07/14/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190714161400.png[login]\n\n这样其实就配置完成登录页面了，我们配置完授权页面一起测试把\n\n===== 授权页面\n\n我们需要自定义授权的控制器。我们要做的就是写一个相同的端点\n`/oauth/confirm_access` 进行覆盖，所以就需要另外一个\n`controller`，如下：\n\n[source,java]\n----\n@Controller\n@SessionAttributes(\"authorizationRequest\")  // 重要！\npublic class AuthorizationController {\n    @RequestMapping(\"/oauth/confirm_access\")\n    public ModelAndView getAccessConfirmation(Map<String, Object> model, HttpServletRequest request) throws Exception {\n        AuthorizationRequest authorizationRequest = (AuthorizationRequest) model.get(\"authorizationRequest\");\n        ModelAndView view = new ModelAndView();\n        view.setViewName(\"authorization\");\n        view.addObject(\"clientId\", authorizationRequest.getClientId());\n        return view;\n    }\n}\n----\n\nimage::https://resources.echocow.cn/file/2019/07/14/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190714162324.png[controller]\n\n添加页面\n\nimage::https://resources.echocow.cn/file/2019/07/14/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190714162555.png[page]\n\n当然你也可以让他使用选择的方式，选择是否授权，我的这里没有提供拒绝的选项，\n\n===== 测试\n\n我们运行测试一下，访问路径：\n\n[source,shell]\n----\nhttp://localhost:8000/oauth/authorize?response_type=code&client_id=oauth2&redirect_uri=http://example.com≻ope=all\n----\n\nimage:https://resources.echocow.cn/file/2019/07/14/Peek+2019-07-14+16-48.gif[image]\n\n发现上面报错，转化 json 后如下：\n\n[source,json]\n----\n{\n    \"error\" :\"access_denied\",\n    \"error_description\" : \"User denied access\"\n}\n----\n\n用户拒绝访问，也就是用户没有同意授权，但是明明是确定授权，问题出来哪儿呢？\n\n===== 解决问题\n\n对于授权控制器，它提供了一套默认的实现，具体参见\n`org.springframework.security.oauth2.provider.endpoint.AuthorizationEndpoint#authorize`，有兴趣的小伙伴可以\ndebug\n一下。问题也就是在这里，我们传递的参数过去，但是却没有声明她同意的范围，也就是\n`scope` 字段，那么现在就需要传递一个 scope 同意授权的字段过去了，如下：\n\n[source,java]\n----\n@Controller\n@SessionAttributes(\"authorizationRequest\")\npublic class AuthorizationController {\n    @RequestMapping(\"/oauth/confirm_access\")\n    public ModelAndView getAccessConfirmation(Map<String, Object> model, HttpServletRequest request) throws Exception {\n        AuthorizationRequest authorizationRequest = (AuthorizationRequest) model.get(\"authorizationRequest\");\n        ModelAndView view = new ModelAndView();\n        view.setViewName(\"authorization\");\n        view.addObject(\"clientId\", authorizationRequest.getClientId());\n        // 传递 scope 过去,Set 集合\n        view.addObject(\"scopes\", authorizationRequest.getScope());\n        // 拼接一下名字\n        view.addObject(\"scopeName\", String.join(\",\", authorizationRequest.getScope()));\n        return view;\n    }\n}\n----\n\n表单添加\n\n[source,html]\n----\n<div class=\"wrap-input100 validate-input m-b-23\">\n    <input type=\"hidden\" name=\"user_oauth_approval\" value=\"true\">\n    <div style=\"display: none\" th:each=\"scope : ${scopes}\">\n        <input type=\"hidden\" th:name=\"'scope.' + ${scope}\" value=\"true\">\n    </div>\n    <input type=\"hidden\" name=\"_csrf\" th:value=\"${_csrf.token}\"/>\n</div>\n----\n\nimage::https://resources.echocow.cn/file/2019/07/14/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190714170307.png[add]\n\n然后再来测试一下\n\nimage:https://resources.echocow.cn/file/2019/07/14/Peek+2019-07-14+17-05.gif[image]\n\n这样就完成啦～！\n\n== 总结\n\n这基本就是授权服务器的所有配置了，当然，只是实践性阶段，并没有涉及太多源码，后面会考虑要不要写一篇源码的说明的，但是担心自己能力不够，所以还是没敢写上去。不过这一节内容挺多的，基本上适合各种场景了，我们需要做的就是按照自己的要求来配置，其实配置文件不多不是很复杂，熟悉了就好。下面一节我们就要进入资源服务器的配置啦～！相比来说会简单一点，但是资源服务器是离不开授权服务器的，所以两者是有关系的，慢慢来吧，估计要三天左右才能写完，存货已经没啦～\n\n== 参考资料\n\n* http://andaily.com/spring-oauth-server/db_table_description.html[spring\nsecurity oauth2 数据表结构]\n* http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html[JSON\nWeb Token 入门教程 阮一峰]\n* https://www.jianshu.com/p/576dbf44b2ae[什么是 JWT – JSON WEB TOKEN]\n* https://blog.csdn.net/xiaoxinshuaiga/article/details/80766369[CSRF攻击与防御]\n\n","fields":{"slug":"/articles/2019/07/14/1563096109753.html","birthTime":"2019-07-14T09:21:49.805Z","modifiedTime":"2020-04-25","year":2019},"document":{"title":"Spring Security Oauth2 从零到一完整实践（三）授权服务器"}},{"content":"= Spring Security Oauth2 从零到一完整实践（二）自动配置实现\n:page-description: Spring Security Oauth2 从零到一完整实践（二）自动配置实现\n:page-category: spring\n:page-image: https://img.hacpai.com/bing/20181219.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2019/07/14/1563082247386.html\n:page-created: 1563082247487\n:page-modified: 1587796102996\n:toc:\n\n____\n*注意注意：本文章适用于5.3以前的spring security以及spring boot 2.3.x\n以前的 oauth，以下内容应该为过时！spring 提供新的 oauth2\n授权服务器，目前正在https://spring.io/blog/2019/11/14/spring-security-oauth-2-0-roadmap-update[实验性阶段]，同时资源服务器由\noauth 模块迁移到 spring security 之内。*\n____\n\n前面我们学习了四种授权模式的两种，因为那两种分别满足了方便和安全，已经能够胜任大多数情况，我们从简开始，先来用最简单的方式开始。\n\n====\nGitHub 地址： https://github.com/lizhongyue248/spring-security-oauth2-demo[spring-security-oauth2-demo]\n\n博客地址： https://echocow.cn[echocow.cn]\n====\n\n== 系列文章\n\n[arabic]\n. https://echocow.cn/articles/2019/07/14/1563082088646.html[较为详细的学习\noauth2 的四种模式其中的两种授权模式]\n. spring boot oauth2 自动配置实现\n. https://echocow.cn/articles/2019/07/14/1563096109754.html[spring\nsecurity oauth2 授权服务器配置]\n. https://echocow.cn/articles/2019/07/20/1563611848587.html[spring\nsecurity oauth2 资源服务器配置]\n. https://echocow.cn/articles/2019/07/30/1564498598952.html[spring\nsecurity oauth2 自定义授权模式（手机、邮箱等）]\n. https://echocow.cn/articles/2020/01/20/1579503807596.html[spring\nsecurity oauth2 踩坑记录]\n\n== spring boot oauth2 自动配置实现\n\nspring boot 最大一个特点就是 *约定大于配置，去繁就简*\n。既然如此，他自然也提供了一套 oauth2\n的自动化配置，我们先来实验他完成的自动化配置看看效果。\n\n首先创建我们的 module 如下：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709100748.png[1]\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709100931.png[2]\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709100948.png[3]\n\n____\n注意：这个过程以后不再截图演示。\n____\n\n在 `pom.xml` 中添加如下依赖\n\n[source,xml]\n----\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-security</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.security.oauth.boot</groupId>\n        <artifactId>spring-security-oauth2-autoconfigure</artifactId>\n        <version>${spring.boot.version}</version>\n    </dependency>\n</dependencies>\n----\n\n=== spring security 保护的资源\n\n默认情况下，我们加入了 spring security\n的依赖，他会保护我们的资源。现在添加启动类如下：\n\n[source,java]\n----\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n----\n\nimage:https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709145302.png[image]\n\n直接启动，控制台如下\n\nimage:https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709145618.png[image]\n\n然后访问 http://127.0.0.1:8080 ，如下\n\nimage:https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190709145514.png[image]\n\n使用用户名 `user` 密码为控制台打印的那一串登录即可，成功后如下：\n\nimage:https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709145819.png[image]\n\n但是现在默认的是 spring security，我们接下来来实验一下 oauth2\n保护我们的资源\n\n=== spring security oauth2 保护资源\n\n我们在前面提到过 oauth2\n的几种角色，我们现在一步一步的来。在下面的授权服务器与资源服务器，我们将他们存在同一个应用之中使用，先以最快速的方式学习与了解，后面再来考虑分离的问题。\n\n=== 授权服务器\n\n首先第一步是授权服务器，因为它是我们获取与请求凭证的地方，我们需要他来给我们下发令牌凭证，如何开启呢？需要一个启动注解`@EnableAuthorizationServer`\n添加在启动类上即可。\n\n同时为了方便测试，我们添加一个 `ResourceController`\n来设置一个资源访问路径如下：\n\nimage:https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709153904.png[image]\n\n这个时候我们再启动，然后去访问就会发现不需要登录了\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_20190709154353.png[测试]\n\n因为现在 spring security\n已经不再去管理你的应用了，**然而现在你只配置了授权服务器，他不会保护你的应用程序的，所以不需要登录了。**我们暂时不管，现在授权服务器的任务是*验证身份并下发令牌，我们来测试一下。*\n\n为了方便查看路径，我们开启 debug 日志，以便更好的理解整个过程；添加\n`application.yml` 以及内容如下：\n\n[source,yml]\n----\nlogging:\n  level:\n    org:\n      springframework:\n        security: DEBUG\n----\n\n然后运行，你会看到如下画面：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709154809.png[run]\n\n在我们启动的时候为我们自动生成的了一些东西：\n\n* 用户密码\n* 客户端 id\n* 客户端密码\n* 添加了七个路径\n* 使用权限表达式设置访问权限\n\n==== 授权码模式\n\nspring security oauth\n授权服务器默认开启授权码模式。那么按照我们前面说的，*授权码模式是在授权端点\n/oauth/authorize 请求授权码*，路径应该如下：\n\n....\nhttp://localhost:8080/oauth/authorize?response_type=code&client_id=73ec1533-f25a-4fb0-9332-552d864bebbc&redirect_uri=http://example.com&scope=all\n....\n\n____\n为什么回调地址是\nhttp://example.com？因为我们现在没有任何应用，需要一个页面来接收回调厚的授权码，所以随便找了一个。\n____\n\n访问后会出现如下错误\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709155136.png[error]\n\n这是因为我们没有配置 spring security\n造成的，所以需要回去配置一下，使用默认配置即可，添加一个配置类如下：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709155545.png[spring\nsecurity config]\n\n重启启动后，你会发现，现在的网页又不能访问了，全都提示需要登录了，暂时不管。\n\n*我们使用新的 client id 去请求授权*，他会自动跳转到登录页面了，如下：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709155707.png[login]\n\n这里的步骤是在授权服务器上面的，就像我们点击第三方登录的 qq\n的时候，是跳转到 腾讯 自己的登录页面的。用户名 user\n，密码为控制台生成的，登录后如下：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709155929.png[error]\n\n它提示我们 *至少为客户端注册一个回调地址*\n，我们请求授权的时候传递了一个回调地址了，这里为什么还需要一个呢？这个很容易理解，**因为你传递过来的回调地址授权服务器不知道是否合法，可能会在传输的中途被篡改，所以在授权服务器里面需要你注册一个回调地址，与你传递过来的进行对比，如果匹配才会携带授权码进行回调。**这样就有效避免中途被篡改的问题了，所以现在我们需要去注册一个回调地址，在\n`application.yml` 中配置：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709160558.png[注册一个回调地址]\n\n然后重新启动，再次携带新的客户端id进行访问：\n\nimage:https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709160848.png[确认授权]当我们确认授权了以后，这个授权流程也就完毕了，也就相当于前面\n*角色中的抽象流图的 AB 完成了* ，我们看看得到的授权码\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709160920.png[授权授权码]\n\n*接下来我们需要使用此授权码去完成请求令牌的操作也就是前面说到的第二个请求*，我们需要\npostman 接口测试工具：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709161310.png[postman]\n\n当我们设置好授权信息以后他会为我们自动添加一个请求头\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709161337.png[请求头]\n\n请求头的添加方式就是前面提到的 *客户端加密*\n的那一部分，不再赘述。然后我们设置 *第二个请求的请求参数* 如下：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709161407.png[设置参数]\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709161423.png[请求令牌]\n\n这样我们就获取到令牌了，到这一步，也就相当于前面 *角色中的抽象流图的 CD\n也完成了* 。这就是授权码模式获取令牌的两个请求的过程。\n\n==== 密码模式\n\n接下来我们来试一下 *密码模式*\n来获取令牌，就像前面所说，他只有一个请求即可，所以我们只要用 postman\n携带参数请求一下就好了。\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709163358.png[密码模式]\n\n相比起来，密码模式就简单太多啦！但是用户名密码是在客户端那里的，而不是在授权服务器这边的，所以只能是完全信得过的应用才能够使用！\n\n==== 快速自定义\n\n**所谓快速自定义，就是我们不需要写代码，通过配置文件即可完成自定义。**对于\noauth2 客户端，提供了如下配置让我们快速自定义：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709170045.png[oauth]\n\n当然，只能提供一个客户端使用。我们后面再来详细学习如何自定义\n\n==== 配置用户\n\n其实用户就是用的 spring security\n的用户，但是由于不能够直接在配置文件中指定用户的密码了，所以我们需要建一个\n`UserService`\n的实现类。不过在那之前，我们需要配置一个密码加密器，让我们的密码得到保障，而不是明文传输，spring\n5 以后这个是必须指定的。\n\n[source,java]\n----\n@Bean\npublic PasswordEncoder passwordEncoder() {\n    return new BCryptPasswordEncoder();\n}\n----\n\nBCrypt\n不可逆的加密算法，无法通过解密密文得到明文，和其他对称或非对称加密方式不同的是，不是直接解密得到明文，也不是二次加密比较密文，而是把明文和存储的密文一块运算得到另一个密文，如果这两个密文相同则验证成功。对于同一个密码，每次加密出来是完全不同的，所以安全性很可靠。\n\n下面的用户我们用最快捷的方式来进行创建，创建两个内存用户：\n\n[source,java]\n----\n@Bean\n@Override\nprotected UserDetailsService userDetailsService() {\n    InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();\n    manager.createUser(User.withUsername(\"user\")\n                   .password(passwordEncoder().encode(\"123456\"))\n                   .authorities(\"ROLE_USER\").build());\n    manager.createUser(User.withUsername(\"admin\")\n                   .password(passwordEncoder().encode(\"admin\"))\n                   .authorities(\"ROLE_ADMIN\").build());\n    return manager;\n}\n----\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709185310.png[配置用户]\n\n获取令牌看看\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709190023.png[token]\n\n=== 资源服务器\n\n现在我们取到了 token，我们来尝试访问一下被保护的资源，使用浏览器访问：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709191331.png[资源服务器]\n\n你会发现同样需要你登录，因为现在是由 spring security\n进行资源保护的。那么我们看看携带 token 使用 postman 测试一下会怎样呢？\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709191618.png[请求]\n\n会发现是 401，也就是令牌是无效的，*原因就是因为现在资源的保护是由传统的\nspring security 来进行保护的。接下来我们就要配置我们的资源服务器。*\n\n同授权服务器一样，资源服务器的启动也只需要一个注解就可以了：`@EnableResourceServer`，启动类添加此注解如下\n\n[source,java]\n----\n@SpringBootApplication\n@EnableAuthorizationServer\n@EnableResourceServer\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n----\n\n启动下应用，通过浏览器看看\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709192751.png[浏览器]\n\n你会发现已经不能够登录了。现在重新用密码模式请求下\ntoken，截图省略，然后获取 token 后去请求我们受保护的资源试一试：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709193118.png[受保护]\n\n现在携带正确的 token 就可以请求到数据了，这就是已经由 spring security\noauth 来进行资源保护了。\n\n对于资源服务器的自定义配置，目前只有一个地方，就是资源的 id ，如下：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709193650.png[id]\n\n如果两者不相同会抛出如下异常：\n\n[source,json]\n----\n{\n    \"error\": \"access_denied\",\n    \"error_description\": \"Invalid token does not contain resource id (resource-id)\"\n}\n----\n\n其他的配置我们后面再说，因为他主要涉及到与授权服务器的分离的情况。\n\n=== 其他\n\n除了获取 token 和请求以外，她还可以配置一些默认的实现。\n\n==== 解析 token\n\n我们需要在配置文件中添加如下配置：\n\n[source,yml]\n----\nsecurity:\n  oauth2:\n    authorization:\n      # 允许使用 /oauth/check_token 端点\n      check-token-access: isAuthenticated()\n----\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709194944.png[配置]\n\n熟悉 SqEL 表达式的同学应该知道 `isAuthenticated()`\n的意思，它允许此端点的访问，重启后获取新的\ntoken，来访问试一试，参数前面已经说过不再赘述：\n\nimage::https://resources.echocow.cn/file/2019/07/08/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190709195113.png[解析]\n\n这样就成功解析了我们的 token 信息！\n\n____\n使用默认配置的情况下且不增加类的情况下，我们是没有办法刷新 token 的。\n____\n\n=== 总结\n\n这个部分是我们最基础的部分，也是最为简单的部分，使用 spring boot oauth\n的自动配置完成了简单的授权服务器和资源服务器的配置，\n通过这两个服务器的配置就可以快速搭建起来 oauth2\n的授权流程，为我们省掉了很多麻烦事儿，当然，自动配置有好处也有坏处，由于他自动帮我们配置好了很多，能满足很多的小型应用的需求了。但是要求总是在变化的，所以有些不符合我们要求的地方我们需要去自己自定义的，下面我们就要进入\nspring security oauth2\n完整自定义配置环节，分为两个部分，一个授权服务器，一个资源服务器的配置。\n\n","fields":{"slug":"/articles/2019/07/14/1563082247386.html","birthTime":"2019-07-14T05:30:47.487Z","modifiedTime":"2020-04-25","year":2019},"document":{"title":"Spring Security Oauth2 从零到一完整实践（二）自动配置实现"}},{"content":"= manjaro 诡异错误：键盘失灵\n:page-description: manjaro 诡异错误：键盘失灵\n:page-category: linux\n:page-image: https://img.hacpai.com/bing/20190507.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2019/07/21/1563700292254.html\n:page-created: 1563700292306\n:page-modified: 1563700292306\n:toc:\n\n在使用 manjaro\n的时候遇到一个非常诡异的错误：键盘失灵。说起来这个问题其实在我第一次使\n用manjaro\n的时候就遇到了，但是不知道怎么处理，所以只有。。。换键盘。于是暂时买了一个键盘用着，原来的失灵键盘是这款，买了两年多了，只有\nmanjaro 会失灵：\n\nimage::https://resources.echocow.cn/file/2019/07/21/-66361bb61e703b18.jpg[达尔]\n\n但是最近因为用的键盘借给同学了，所以自己只能够换回这个键盘了，但是这个键盘时灵时不灵，一直很无奈，有时候重启就可以用了，具体失灵状况如下：\n\n在正常的时候灯光流动变换是没有问题的，但是一摁，灯光就会卡住，键盘输入也无效，最近又没钱买不了新的键盘，然后就寻思解决办法。又是安驱动又是检查键盘中断，然后一次突发奇想就解决了。。。\n\n== 解决办法\n\n其实很简单，就是在开机的过程中保持键盘键入即可。也就是说在以下的两个界面都要有键入：\n\nimage::https://resources.echocow.cn/file/2019/07/21/IMG_20190721_165251.jpg[one]\n\n这个界面就上下移动移回来换行确认第一个就可以了。\n\nimage::https://resources.echocow.cn/file/2019/07/21/IMG_20190721_165304.jpg[two]\n\n这个界面就随便键入一些字母就可以了\n\n然后启动以后就不会出现键盘失灵的情况了，去年因为这个问题又是重装又是买键盘，今年找到很快就找到了”解决办法“，哈哈哈运气真的很重要～！\n\n","fields":{"slug":"/articles/2019/07/21/1563700292254.html","birthTime":"2019-07-21T09:11:32.306Z","modifiedTime":"2019-07-21","year":2019},"document":{"title":"manjaro 诡异错误：键盘失灵"}},{"content":"= Spring Security Oauth2 从零到一完整实践（四）资源服务器\n:page-description: Spring Security Oauth2 从零到一完整实践（四）资源服务器\n:page-category: spring\n:page-image: https://img.hacpai.com/bing/20180622.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2019/07/20/1563611848587.html\n:page-created: 1577676880995\n:page-modified: 1587795981289\n:toc:\n\n____\n*注意注意：本文章适用于5.3以前的spring security以及spring boot 2.3.x\n以前的 oauth，以下内容应该为过时！spring 提供新的 oauth2\n授权服务器，目前正在https://spring.io/blog/2019/11/14/spring-security-oauth-2-0-roadmap-update[实验性阶段]，同时资源服务器由\noauth 模块迁移到 spring security 之内。*\n____\n\n我们使用安全框架的最大意义就在于保护我们的资源，让我们的资源能够在我们希望他被访问到的时候才能够被访问，而存放我们资源的地方就是资源服务器。前面已经说过，资源服务器是围绕着授权服务器进行的，在\noauth2\n中当有了授权服务器以后，才会有资源服务器，这样说虽然有点绝对，但是如果没有授权服务器，资源服务器其实也就没有太大的存在意义的了，那么还不如就作为一个普通的\nWeb\n应用即可。我们现在的任务就是来学习如何自定义配置我们的资源服务器，同以前一样，我们通过实践的方式来了解他。\n\n====\nGitHub 地址： https://github.com/lizhongyue248/spring-security-oauth2-demo[spring-security-oauth2-demo]\n\n博客地址： https://echocow.cn[echocow.cn]\n====\n\n== 系列文章\n\n[arabic]\n. https://echocow.cn/articles/2019/07/14/1563082088646.html[较为详细的学习\noauth2 的四种模式其中的两种授权模式]\n. https://echocow.cn/articles/2019/07/14/1563082247386.html[spring boot\noauth2 自动配置实现]\n. https://echocow.cn/articles/2019/07/14/1563096109754.html[spring\nsecurity oauth2 授权服务器配置]\n. spring security oauth2 资源服务器配置\n. https://echocow.cn/articles/2019/07/30/1564498598952.html[spring\nsecurity oauth2 自定义授权模式（手机、邮箱等）]~~~~\n. https://echocow.cn/articles/2020/01/20/1579503807596.html[spring\nsecurity oauth2 踩坑记录]\n\n== Spring security oauth2 资源服务器\n\n一般来说资源服务器同时也是我们的客户端，为什么这么说呢？因为客户端存在的前提就是需要有资源服务器提供资源，这个关系往往都是一对一的，对于\nWeb 应用，他们之间应该有如下关系：\n\n* 客户端：前端应用，携带 client id 去请求授权服务器获取授权码。\n* 资源服务器：后端应用，一般会在这里存放 client\nsecret，这样用户就不会得到 client 相关的密钥或者凭证，使用 client id 和\nclient secret\n向授权服务器对凭证进行验证和解析，所以通常来说资源服务器也是作为客户端的存在。\n\n专门的资源服务器为客户端提供受保护的资源。而且在请求令牌凭证的时候，就已经指定了当前客户端信息，但是对于前端应用，为了安全不会存放\nclient\nsecret，因为前端基本是全部暴露在用户面前的，所以资源服务器也充当客户端，用来存放相应的客户端信息。在请求资源的时候也需要说明客户端信息，这个时候的客户端信息为了安全，都是存放在授权服务器之中的，所以可以理解成如下图：\n\nimage::https://resources.echocow.cn/file/2019/07/14/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190718170329.png[授权码模式]\n\n所以这就是为什么授权码模式安全性最高的原因之一，一方面他拥有严密的流程，另一方面他的授权是在授权服务器上完成，客户端只需要提供\nclient id 就可以而不需要其他的，用户也就只知道 client id 而不知 client\nsecret\n了；所以更加安全。如果是密码模式，*你需要自定义自己的一套登录流程然后向授权服务器请求授权才可以*，不能够直接让用户从前端应用向授权服务器请求授权，因为完全可以从请求头中截取你的客户端信息。密码模式如下：\n\nimage::https://resources.echocow.cn/file/2019/07/18/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190718174912.png[不安全的密码模式]\n\nimage::https://resources.echocow.cn/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190718175533.png[密码模式]\n\n*所以我们在配置资源服务器的时候需要同时配置一个客户端*。我们来再次看看资源服务器的详细步骤：\n\n[arabic]\n. 向授权服务器请求获取 token（即凭证）\n. 向授权服务器验证并解析 token 获取用户信息\n. 资源服务器验证用户是否有权限访问此资源\n\n这一切都是以一台授权服务器为前提的，所以我们需要先为他准备一台授权服务器。我们可以直接使用我们上篇文章说到的那些授权服务器，不过有些许改变。\n\n=== 在这之前\n\n在这之前我们需要为已经有的授权服务器添加一个非常主要的端点：*check_token*\n\n在所有的授权模块中（如： `spring-security-oauth2-authorization` ）的\n`Oauth2AuthorizationServerConfig`\n授权服务器配置添加如下方法，具体作用参见上一篇文章的最后一部分。\n\n[source,java]\n----\n@Override\npublic void configure(AuthorizationServerSecurityConfigurer security) {\n    security\n        .checkTokenAccess(\"isAuthenticated()\");\n}\n----\n\n这样我们就能够访问 `check_token`\n端点，*资源服务器就能够向授权服务器验证并解析 token 获取用户信息*。\n\n接下来我们来创建我们资源服务器模块，创建方式和授权服务器中是一样的，不再赘述。模块名称为\n`spring-security-oauth2-resource`\n，同授权服务器一样，资源服务器的关键接口为 `ResourceServerConfigurer`\n，而他的适配器为 `ResourceServerConfigurerAdapter`\n，我们只需要继承他的适配器即可，他有如下两个方法：\n\n[width=\"100%\",cols=\"10%,15%,75%\",options=\"header\",]\n|===\n|方法名 |参数类型 |描述\n|configure |ResourceServerSecurityConfigurer\n|资源服务器的属性配置，默认值应该适用于许多应用程序，但可能至少要更改资源\nID。\n\n|configure |HttpSecurity\n|使用此项配置安全资源的访问规则。默认情况下，不在 `“/oauth/**”`\n中的所有资源是受保护的。这个其实就是和 ``spring security`\n的配置方式是一样的。\n|===\n\n相比起授权服务器好理解许多。同时需要明白的一点是，对于资源服务器，提供了两种验证与解析令牌的方式：\n\n[width=\"100%\",cols=\"10%,10%,25%,55%\",options=\"header\",]\n|===\n|解析方式 |实现类 |优点 |缺点\n|本地解析 |`DefaultTokenServices`\n|解析快速，不需要发送任何请求，可以配置令牌存储等。\n|一旦授权服务器令牌解析方式发生调整，本地也要进行调整。向资源服务器/客户端提供令牌解析方式是极其不安全的行为。\n\n|远程解析 |`RemoteTokenServices`\n|资源服务器配置大大减少，方便快捷，自适应授权服务器变化。\n|受网络的影响，一旦两个服务器不再一个局域网内，效率会大大降低。\n|===\n\n然而在实际的授权服务器中，我们将会采用的是第二种 远程解析\n的方式，最主要的原因是因为他足够安全。所以我们主要分为两个部分来学习资源服务器：\n\n[arabic]\n. 基于普通加密的资源服务器\n. 基于 jwt 加密的资源服务器\n\n== 基于普通加密的资源服务器\n\n____\n对应的授权服务器模块为：spring-security-oauth2-authorization\n\n对应的资源服务器模块为：spring-security-oauth2-resource\n____\n\n授权服务器需添加 check_token 端点支持。\n\n资源服务器依赖如下：\n\n[source,xml]\n----\n<dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-security</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.security.oauth.boot</groupId>\n            <artifactId>spring-security-oauth2-autoconfigure</artifactId>\n            <version>${spring.boot.version}</version>\n        </dependency>\n    </dependencies>\n----\n\n我们先创建一个启动类如下：\n\n[source,java]\n----\n@SpringBootApplication\npublic class ResourceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ResourceApplication.class, args);\n    }\n}\n----\n\n而作为资源服务器，我们肯定是需要准备一个受保护的资源的，所以我们创建一个\n`controller` 如下：\n\n[source,java]\n----\n@RestController\n@RequestMapping(\"/auth\")\npublic class OauthController {\n\n    /**\n     * 获取当前登录的用户信息\n     *\n     * @param principal 用户信息\n     * @return http 响应\n     */\n    @GetMapping(\"/me\")\n    public HttpEntity<?> oauthMe(Principal principal) {\n        return ResponseEntity.ok(principal);\n    }\n\n}\n----\n\n同授权服务器一样，资源服务器的关键接口为 `ResourceServerConfigurer`\n，而他的适配器为 `ResourceServerConfigurerAdapter`\n，我们只需要继承他的适配器即可，如下：\n\n[source,java]\n----\n@Configuration\n@EnableResourceServer\npublic class Oauth2ResourceServerConfig extends ResourceServerConfigurerAdapter {\n\n    @Override\n    public void configure(ResourceServerSecurityConfigurer resources) throws Exception {\n        // 设置资源服务器的 id\n        resources.resourceId(\"oauth2\");\n    }\n\n}\n----\n\n最后来添加我们的配置文件 `application.yml` ，分别指定了如下参数：\n\n* 资源服务器的启动端口在 `9000`\n* 资源服务器检查和解析用户信息的路径在\n`http://localhost:8000/oauth/check_token`\n* 客户端获取令牌的位置 `http://localhost:8000/oauth/token`\n* 客户端信息\n\n如下：\n\n[source,yml]\n----\nserver:\n  port: 9000\n\nsecurity:\n  oauth2:\n    resource:\n      token-info-uri: http://localhost:8000/oauth/check_token\n    client:\n      access-token-uri: http://localhost:8000/oauth/token\n      client-id: oauth2\n      client-secret: oauth2 # 这里必须是加密前的密钥\n      grant-type: authorization_code,password,refresh_token\n      scope: all\n----\n\n____\n*Q：在授权服务器中，我们继承了`AuthorizationServerConfigurerAdapter`\n并注入之后，在配置文件中的配置就不会自动生效了，在授权服务器之中同理，那么我们为什么还要配置\n`token-info-uri` 呢？*\n\nA：主要原因是因为 `token-info-uri`\n不仅是在资源服务器中使用的。我们资源服务器在向授权服务器发送请求的时候需要一个\n`RestTemplate` (具体作用请自行百度)，而 `spring oauth2` 将创建的这个\n`RestTemplate` 存放在了\n`org.springframework.security.oauth2.provider.token.RemoteTokenServices`\n内，在这里又使用了 `token-info-uri` ，具体源码见\n`org.springframework.boot.autoconfigure.security.oauth2.resource.ResourceServerTokenServicesConfiguration`\n如下：\n\n可以看到他创建的时候又使用了我们的 `token-info-uri`\n，所以这里我们配置出来的是为了配置这个自动的远程服务，我们用来发送的请求都是它来完成的。\n____\n\n____\n*Q：上一步的源码中看到了给他设置了 客户端 id 和\n客户端密钥，但是在资源服务器的配置中我们并没有配置，而是配置的是 client\n客户端的配置，他怎么设置进去的呢？*\n\nA：我们还是从源码说起，直接上图：\n\n可以看到是有这两个属性的，但是使用 `@JsonIgnore` 进行忽视了，同时没有\n`set`\n方法，所以我们无法设置，那么它是来自于哪里呢？那就只有构造函数了，在哪儿设置的呢？源码如下：\n\n可以看到注入了 `client` 的配置文件然后直接把 `id` 和 `secret`\n使用构造方法放进去了，所以我们配置 `client` 就可以了 ～！\n____\n\n所以我们现在的目录结构应该如下：\n\nimage::https://resources.echocow.cn/file/2019/07/18/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190720135426.png[files]\n\n我们启动测试一下，启动两个项目，\n\n我们直接访问一下受保护的资源看看：\n\nimage::https://resources.echocow.cn/file/2019/07/18/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190720140745.png[get]\n\n401 未授权，我们需要提供相应的授权凭证。\n\n我们现在要获取凭证，也就是\ntoken，第一步要先去获取授权码，获取授权码的过程是在授权服务器中完成的，访问如下路径：localhost:8000/oauth/authorize?response_type=code&client_id=oauth2&redirect_uri=http://example.com&scope=all\n\n然后登录授权流程就不截图啦，和授权服务器是一样的，这个过程你应该要注意的是\nurl ，他一直在的是 `8000` 端口的服务器上，最后取到授权码：\n\nimage::https://resources.echocow.cn/file/2019/07/18/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190720140224.png[code]\n\n携带授权码去获取 token\n\n____\n*注意：在实际应用中，回调地址应该自动接收获取到授权码然后发送给资源服务器，资源服务器请求授权服务器获取\ntoken，这个过程应该要在资源服务器完成，对用户不可见*。\n____\n\nimage::https://resources.echocow.cn/file/2019/07/18/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190720140237.png[token]\n\n然后携带 token 去请求我们的资源服务器资源\n\nimage::https://resources.echocow.cn/file/2019/07/18/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190720140334.png[token]\n\n这样我们就请求到了具体的数据啦，这就是使用了远程的方式，变得非常简单！不需要配置任何\ntoken 相关的东西 ～\n\n== 基于 Jwt 加密的资源服务器\n\n____\n对应的授权服务器模块为：spring-security-oauth2-authorization-jwt\n\n对应的资源服务器模块为：spring-security-oauth2-resource-jwt\n____\n\n*同样，在授权服务器中我们要添加 check_token 端点的访问权限。*\n\n我们先来初始化我们的项目，其实就是把上一个的复制过来即可 =-=\n不过对于资源的 id 改成了从配置文件读取，配置文件如下：\n\n[source,yml]\n----\nserver:\n  port: 9000\n\nsecurity:\n  oauth2:\n    resource:\n      token-info-uri: http://localhost:8000/oauth/check_token\n      id: oauth2\n    client:\n      access-token-uri: http://localhost:8000/oauth/token\n      client-id: oauth2\n      client-secret: oauth2\n      grant-type: authorization_code,password,refresh_token\n      scope: all\n----\n\n最终项目结构如下：\n\nimage::https://resources.echocow.cn/file/2019/07/18/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190720150340.png[config]\n\n而同样，对于 jwt\n有两种，分别是对称密钥加密以及非对称密钥加密，我们也要一个一个来。\n\n=== 对称密钥\n\n我们首先改一下授权服务器使用对称密钥加密，\n`Oauth2AuthorizationServerConfig` 如下：\n\n[source,java]\n----\n/**\n * 令牌转换器，非/对称密钥加密\n *\n * @return JwtAccessTokenConverter\n */\n@Bean\npublic JwtAccessTokenConverter jwtAccessTokenConverter() {\n    JwtAccessTokenConverter converter = new JwtAccessTokenConverter();\n    //  对称密钥加密\n    converter.setSigningKey(\"oauth2\");\n    //  非对称密钥加密\n    //  KeyStoreKeyFactory keyStoreKeyFactory = new KeyStoreKeyFactory(\n    //          new ClassPathResource(\"oauth2.jks\"), \"123456\".toCharArray());\n    //  converter.setKeyPair(keyStoreKeyFactory.getKeyPair(\"oauth2\"));\n    return converter;\n}\n----\n\n对于 jwt 有两种配置方式\n\n[arabic]\n. 自动配置\n. 手动配置\n\n自动配置很简单，配置文件添加：\n\n[source,yml]\n----\nsecurity:\n  oauth2:\n    resource:\n      jwt:\n        key-value: oauth2\n----\n\n就可以了。\n\n对于手动配置，也很简单，添加如下 bean 然后配置进去即可\n\n配置一个本地的令牌转化器，如下：\n\n[source,java]\n----\n@Bean\npublic JwtAccessTokenConverter jwtAccessTokenConverter() {\n    JwtAccessTokenConverter converter = new JwtAccessTokenConverter();\n    converter.setSigningKey(\"oauth2\");\n    return converter;\n}\n----\n\n然后将它配置进去\n\n[source,java]\n----\n/**\n * 远程服务\n */\nprivate @NonNull RemoteTokenServices remoteTokenServices;\n\n/**\n * 配置文件\n */\nprivate @NonNull ResourceServerProperties resourceServerProperties;\n\n@Override\npublic void configure(ResourceServerSecurityConfigurer resources) throws Exception {\n    remoteTokenServices.setAccessTokenConverter(jwtAccessTokenConverter());\n    // 设置资源服务器的 id,从配置文件中读取\n    resources.resourceId(resourceServerProperties.getResourceId())\n        .tokenServices(remoteTokenServices);\n}\n----\n\n截图如下：\n\nimage::https://resources.echocow.cn/file/2019/07/18/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190720152104.png[next]\n\n然后我们测试一下，使用密码模式请求 token：\n\nimage::https://resources.echocow.cn/file/2019/07/18/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190720152151.png[get]\n\nimage::https://resources.echocow.cn/file/2019/07/18/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190720152156.png[get]\n\n这样就成功了。\n\n=== 非对称密钥\n\n我们首先改一下授权服务器使用非对称密钥加密，\n`Oauth2AuthorizationServerConfig` 如下：\n\n[source,java]\n----\n/**\n * 令牌转换器，非/对称密钥加密\n *\n * @return JwtAccessTokenConverter\n */\n@Bean\npublic JwtAccessTokenConverter jwtAccessTokenConverter() {\n    JwtAccessTokenConverter converter = new JwtAccessTokenConverter();\n    //  对称密钥加密\n    //  converter.setSigningKey(\"oauth2\");\n    //  非对称密钥加密\n    KeyStoreKeyFactory keyStoreKeyFactory = new KeyStoreKeyFactory(\n        new ClassPathResource(\"oauth2.jks\"), \"123456\".toCharArray());\n    converter.setKeyPair(keyStoreKeyFactory.getKeyPair(\"oauth2\"));\n    return converter;\n}\n\n/**\n * 资源服务器所需，后面会讲\n * 具体作用见本系列的第二篇文章授权服务器最后一部分\n * 具体原因见本系列的第三篇文章资源服务器\n *\n * @param security security\n */\n@Override\npublic void configure(AuthorizationServerSecurityConfigurer security) {\n    security\n        // 能够验证和解析 token\n        .checkTokenAccess(\"isAuthenticated()\")\n        // 能够访问我们的公钥\n        .tokenKeyAccess(\"isAuthenticated()\");\n}\n----\n\n这里我们需要 `tokenKeyAccess(\"isAuthenticated()\")` 能够访问\n`/oauth/token_key` 端点，启动授权服务器可以直接通过浏览器访问\nhttp://localhost:8000/oauth/token_key\n\nimage::https://resources.echocow.cn/file/2019/07/18/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190720154348.png[key]\n\n对于资源服务器，我们需要授权服务器提供给我们公钥，我们能够通过请求获取到授权服务器的\n公钥了，有两种方式获取公钥：\n\n[arabic]\n. 授权服务器下发，本地存储，本地读取\n. 直接从授权服务器请求获取\n\n当然，我们也有两种方式\n\n[arabic]\n. 自动配置\n. 手动配置\n\n自动配置就是添加配置文件即可：\n\n[source,yml]\n----\nserver:\n  port: 9000\n\nsecurity:\n  oauth2:\n    resource:\n      token-info-uri: http://localhost:8000/oauth/check_token\n      id: oauth2\n      jwt:\n        key-uri: http://localhost:8000/oauth/token_key\n        # 如果没有配置这项，会自动联网获取\n        key-value: |\n          -----BEGIN PUBLIC KEY-----\n          MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAiNMiywFLjao8P86kkhwu\n          49Ycys35RRZaKgqZ6JNtbgFq5dCA2kBtdArhm2GS2zplOyPGDlog3r9Ka2jA33Pf\n          A9vl60zq1oI1AAAd8CLnyTvIekCnpwaGeBfYFv++LwhWPPT617XVhmF46c25F29t\n          tMnGuzHzqKprysgdfBaIXUKZkMeVudGSLPgR0RjZvcM8MMs1cZ1rAISRgIT/D1RL\n          Do/HhQkKOvhW2IrQgrqrgu+R/V+7AqS6dz/YAdroYpcBoXKSai+HtZ6yTDxrWdxh\n          pbaTCvW2M/IObYVZaHpdOYNTufOzR6+w4SXagT++OopWEQ8w1vLKQzHk+uTrBfzQ\n          kQIDAQAB\n          -----END PUBLIC KEY-----\n    client:\n      access-token-uri: http://localhost:8000/oauth/token\n      client-id: oauth2\n      client-secret: oauth2\n      grant-type: authorization_code,password,refresh_token\n      scope: all\n----\n\n手动配置比较麻烦。。。配置如下：\n\n[source,java]\n----\n@Override\n    public void configure(ResourceServerSecurityConfigurer resources) {\n        resources.resourceId(resourceServerProperties.getResourceId())\n                .tokenServices(tokenServices());\n    }\n\n    @Bean\n    public TokenStore tokenStore() {\n        return new JwtTokenStore(jwtAccessTokenConverter());\n    }\n\n    @Bean\n    public JwtAccessTokenConverter jwtAccessTokenConverter() {\n        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();\n        converter.setVerifierKey(getPubKey());\n        return converter;\n    }\n\n    @Bean\n    @Primary\n    public DefaultTokenServices tokenServices() {\n        DefaultTokenServices defaultTokenServices = new DefaultTokenServices();\n        defaultTokenServices.setTokenStore(tokenStore());\n        return defaultTokenServices;\n    }\n\n    private String getPubKey() {\n       return StringUtils.isEmpty(resourceServerProperties.getJwt().getKeyValue())\n               ? getKeyFromAuthorizationServer()\n               : resourceServerProperties.getJwt().getKeyValue();\n    }\n\n    private String getKeyFromAuthorizationServer() {\n        ObjectMapper objectMapper = new ObjectMapper();\n        HttpHeaders httpHeaders = new HttpHeaders();\n        httpHeaders.add(\"Authorization\", encodeClient());\n        HttpEntity<String> requestEntity = new HttpEntity<>(null, httpHeaders);\n        String pubKey = new RestTemplate()\n                .getForObject(resourceServerProperties.getJwt().getKeyUri(), String.class, requestEntity);\n        try {\n            Map map = objectMapper.readValue(pubKey, Map.class);\n            System.out.println(\"联网公钥\");\n            return map.get(\"value\").toString();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    private String encodeClient() {\n        return \"Basic \" + Base64.getEncoder().encodeToString((resourceServerProperties.getClientId()\n                + \":\" + resourceServerProperties.getClientSecret()).getBytes());\n    }\n----\n\n示例里面没有写，我写在了另外一个示例项目里面，参见\nhttps://github.com/gzmuSoft/resource-server[资源服务器示例]。\n\n测试就不测试了。。。效果一样的。。好累了的说。\n\n== 总结\n\n资源服务器简单太多拉，因为需要做的复杂操作都在授权服务器上去做了，所以资源服务器其实事情没多少，但是里面的自动配置还是帮我们完成了很多事情。简单太多了，接下来就涉及到源码的一些东西了，这次拖了一周才写完，主要是要写开题报告，而且云顶之亦真香哈哈哈。\n\n","fields":{"slug":"/articles/2019/07/20/1563611848587.html","birthTime":"2019-12-30T03:34:40.995Z","modifiedTime":"2020-04-25","year":2019},"document":{"title":"Spring Security Oauth2 从零到一完整实践（四）资源服务器"}},{"content":"= 2019，最后的轻狂\n:page-description: 2019，最后的轻狂\n:page-category: 感想\n:page-image: https://resources.echocow.cn/file/2019/12/31/bg5.jpg?imageView2/2/w/1280/format/jpg/interlace/1/q/100\n:page-href: /articles/2019/12/31/1577769144050.html\n:page-created: 1577769144107\n:page-modified: 1577781536188\n:toc:\n\n2019\n就这样过去了，总会感时伤怀，不觉之间心里有点小失落。在这一年有太多的遗憾，也成为了我在校的最后一年。有时候会很害怕走出校园，我喜欢校园的自由与恬静，那种平淡且没有压力的日子真的很让人迷恋与迷失。但我最为深信的一点就是，世间没有永恒，时间能够证明一切。所以我要不断的学习，为自己的下一程做准备。\n\n事实上这一年大多数时间都是浑浑噩噩的，刚尝试走出校园的看到外面的繁华和灯红酒绿，心性不免有些动摇。但是自己依旧保持那份”轻狂“，希望的是挑战自己，挑战未来。\n\n== 1-3\n\n2019 年 1 月 1 日，博客正式入住\nsolo，加入黑客派这个社区，一个为未来构建的开发者社区。在这里总会发现一些不一样的东西，现在有事没事就会打开来看看，已经成为一种习惯。\n\n在年初的时候，也定下了一些目标，假期写完``小明同学''，学会 Spring\nsecurity\noauth2。但是都因为各种各样的原因没有继续下去。小明同学已经烂尾，Spring\nsecurity oauth2\n也是在年中的时候完成。自己有时就在想，计划这种东西，对我而言是否有用。总会因为一些莫名其妙的事情让计划变的一团糟。在大学几年的生活里面，深刻体会到了这一点，但大多的时候自己还是不愿意面对这种``深奥''的问题。该做计划就做，至于能不能完成，谁知道呢？\n\n所以自己不再轻易的给自己立\nflag，因为自己不想为自己挖太多的坑以至于留下太多的遗憾。遗憾这种东西，往往会降低太多幸福感。但是幸福感却不是这样来保持的，我常常做的，就是追求更新的技术来满足自己的幸福感，即使老的技术并不是完全的精通，但是不代表我没有权利去追求新的事物。所以在年初的时候自己接触到了\nmaterial design 的设计理念，自己非常喜欢这种设计理念，虽然不是专门的 ui\n设计师，但是自己的前端一直不断向他靠拢。而后又是 vaadin，一个可以使用\nJava 来写 Web\n前端的库，一开始是有眼前一亮的感觉，自己去动手实践了他，但是发现似乎并没有想象的那么好。而后又实践了很多东西，但是进步总是感觉不大。\n\n贵州的春节依旧是那么冷，大家普遍的感觉就是没有以前过年热闹，也许是因为人民要求的提高，也或许是因为自己是这样觉得的。幸运的是还有压岁钱可以拿，即使自己总是不知道自己钱花在了哪里。但是我依旧喜欢放鞭炮，喜欢烟花一时的绚丽多彩，也喜欢周围小孩子的欢声笑语，事实上自己就是一个小孩子。\n\n开学后的日子依旧那么平淡，很享受。\n\n== 4-6\n\n今年是我人生的转折点，也就是在 4-6\n月的期间。可以说这三个月已经算是大部分决定了我的人生。因为在这段期间有个很重要的决定：考研。\n\n事实上对于是否考研，自己一直从未想过。从开始到现在，都是家里希望我去考，所以我要考。但是为什么要考？考哪里？考了对我来说意味着什么？我从来没想过。以至于到\n4-6 月了，我依旧还是迷茫自己如何考？\n\n而这个时候有两个选择摆在我面前：\n\n[arabic]\n. 好好复习，开始考研。\n. 学校项目，自主开发。\n\n这个选择题我选了很久，问过家里的意见，问过老师的意见，也问过同学的意见。但是其实没有人能够帮你，他们的意见或是说笑，或是鼓励、或是随意。但对我自己而言，我完全分析不出来利弊。那时的我真的很迷茫很痛苦，选择第一条会怎样？选择第二条又会怎样？人最怕的就是迷茫，迷茫的时候就会花费大量的时间做无用功，但是我不想做无用功。所以我选择找事情做，然而我能做什么呢？无非就是学习和写代码。我自然而然的开始写起了代码，因此我也自然而然的选择了第二条。\n\n说实话，那个时候真的希望一个我尊敬的人来指点我。\n\n但是我就放弃考研了吗？家里还对我寄托予以希望，所以我在接手学校项目的同时，还要去复习考研。但是我发现自主开发学习的时间和考研时间的比却是\n9 : 1。而在后来的开发中，自己遇到很多很多很多问题，比如：\n\n[arabic]\n. 前后端完全分离的授权方案\n. oauth2 授权协议\n. Spring security 对 oauth2 的支持\n. RBAC 模型在 Spring security oauth2 应用中动态鉴权\n. vue 前端动态路由和动态权限认证\n. ……\n\n等等等等很多问题。那时候没有人教，没有人带我。自己一个人去找资料，中文资料大多复制粘贴或者太基础无营养，去\ngoogle、stackoverflow、GitHub、Twitter、官网\n等等地方一个一个的找。对于一个四级都没过的人来说，自己都不知道哪儿来的毅力。因为我们大四没有任何课程，所以大三的课程白天全程满课，只有晚上的时间研究研究。就这样过了两个月，自己才堪堪的把\nSpring security OAuth 的一些东西明白、理解，也啃过 oauth2 的\nRFC，也学习了 vertx 的 oauth2 相关的点。\n\n这是这一年最大的收获。也许在未来的某天，自己会很感谢这段时间的自己吧。\n\n在那一段时间自己真的很寂寞，我们玩得好的有八个人，每次我在学的时候，都可以听到他们打游戏、聊女孩子的笑声。但是自己必须要把一股子的冲动压下去，好好的学。这个时候我也终于知道伴侣是多么的重要，如果那个时候我有一个伴侣，可能就是另外一种体会把。但可惜我是``渣男''。\n\n同时非常遗憾的是，项目进展非常不顺利。整个项目组我完全叫不动任何人，只有自己一个人做，试想又如何做得好呢？他们总说我很厉害，我只不过把他们玩儿的时间花在了敲代码上而已。甚至我还给他们讲过一段时间的课，效果不假。最后又是烂尾。\n\n不过自己终于把考了三年的驾照拿到手了，高中毕业的时候报名的，现在才拿到。不得不说自己没有什么开车的天赋，但是努力终会有结果的。\n\n== 7-9\n\n最好的一件事是：自己搭建了我们项目组的授权中心，\n\n最坏的一件事是：自己依旧还没有在进行考研的复习。\n\n我总会在想，其实很多时候，自己心里早就已经做了一个决定？只是自己不愿意承担这种抉择，或者说不愿意承认自己心里的这种选择。但是事实就在眼前，自己不能与事实相违。\n\n我一步一步的分离项目的授权部分，然后搭建了属于我们学校自己的 oauth2\n授权中心，在某一刻，一种自豪会油然而生。但是这种自豪升起的那一科，又有一种心慌将它压下去，时刻提醒着自己。\n\n自己在七月的时候，开始尝试准备考研，学习了半个月时间的数学，再次回到了代码里面。现在想想，如果当初先复习的是专业课，可能体会就会有很大的不同，带来的效果和坚持，可能就不一样的把。但也仅仅是想想而已，\n\n7\n月依旧待在学校上课，自己一个人做着学校的项目，有股倔强，也有一股害怕。自己不太适合作为一个团队的领导人，或许是因为和他们关系好了，很多时候我说的话并不管用。很多东西都是看一看就明白了，但是他们总是以太难为借口，不去学习。这或许就是惰性的一种吧，但我也无能为力，改变不了他们，我只有改变自己。\n\n放假回家以后，自己搭建了相关的资源服务器，学习了不少东西。并且也接触到了\nkotlin，买了书来看。通过 kotlin + vert.x 也搭建了一个资源服务器使用。在\n8\n月里面，督促学弟们进行项目代码的书写，才发现他们的差距和我那么大，写的代码在我看来真的不太行，姑且不说\njdk8\n的特性从不使用，光是一些非常简单减少嵌套的办法都不去采用，甚至有一个方法里面嵌套了五个\nif\n这种代码，或者是永远只会一条一条数据的操作。每次都要重构半天，我也就比他们大一届而已啊。\n\n随后按照专业要求，七月上完小学期的课程后，开学必须去北京实习，考研的可以留校半年。我周围的同学都去了，然而我以考研的名义留校了。宿舍只有我一个人，我选择搬到了和几个考研的同学一起住，这也是决定我后面决定的一个非常重大的因素吧。\n\n系主任答应开学不再给我任何任务，事实上他也做到了。九月开学后，自己完全不太接触关于项目的任何事。突然发现，自己闲下来了，除了考研，自己似乎没有什么事是比较重要的了。\n\n这个时候的我似乎进入了一种”贪``的状态，因为在开学第一周，自己完全是玩儿过来的，没有写任何代码，也没有看书，就是打游戏看电视吃饭睡觉。由于没有任何课程，变的无比''轻松“。自己贪恋这种感觉，更是一种__贪得无厌__的状态，希望就这样生活下去。一个月的时间就是这样混过去了，似乎回到了大一只会打游戏的时候，还没有挂课、上课的烦恼。\n\n回想起来，自从小学期放假以后，原来宿舍的室友至今都没有见过面，自己似乎完全没有和外人接触，除了室友和家人还有食堂阿姨。不再有任何人和我接触，更多的就是和电脑待在一起。时间久了，越发的话少了，变得更加沉默了，这可能是学这个专业带给我的最大诟病把。\n\n== 10-12\n\n十月的时候，一起准备考研的一个室友和我都觉得考研无望，正好遇到了一个人工智能协同应用开发大赛。于是一起报名参加了，也就是那个时候开始，到十二月，一直都在写这个项目。断断续续，但是感觉进步并不是很大。五个人参加比赛的，但是两个学弟只是挂个名字，实际上还是我们三个学长在做，三个人做起来任务还是挺多的。\n\n然而比较幸运的是，这段时间自己正好从一个入党积极分子转发展对象和预备党员。这是这三个月最大的收获，虽然说自己总是抱怨又要去上党课，又要去培训，又要去讨论学习，但是自己真的在党课中收获到了很多。自己以前两耳不稳窗外事，但是党课的学习真的让我为自己是一个中国人感到自豪，一些伟大的人物，还有应该铭记的历史，都让我觉得加入中国共产党是对的。党课的时候有几位老师的讲座真的是让我明白了很多人生的方向和追求，对于老师来说可能就是一场普通的讲座或者分享，但是对我而言，就是非常宝贵的人生建议。有时候就是这样，在某一刻你会突然明白一些东西。也就是这样，人生才变的十分有趣。\n\n这期间也认识了很多优秀的人，他们都很优秀，都非常值得我去学习。和优秀的人交朋友，简直会是一种享受，再次感叹入党真的是一个非常正确的决定。\n\n我转为了一名预备党员后，正好是比赛的决赛阶段。这个比赛的奖金十分丰厚的，一等奖五万元，二等奖三万元，三等奖一万元，优秀奖两千元。只要进入决赛，就必定得奖。在复赛阶段我们是以第二的成绩进入的决赛，我们团队开发的三个人都很努力，即使有时候我说他们，但是我知道，大家都很尽力。这也许是我们大学期间最后一次的一起出现在一个\nppt 上了：\n\nimage::https://resources.echocow.cn/file/2019/12/31/TIM%E6%88%AA%E5%9B%BE20191231121638.png[ppt]\n\n我可以很负责的说，所有比赛团队中，我们项目技术是最好的，也是最先进且完善的。从运维，到前端，到后端，再到安全，都是非常完善的。但是第一名却不是我们，以第二名告终，未免有些许可惜。但是三个人分三万元，倒也乐意。路演的时候准备的四个备选方案都没用到，导致效果不理想，有这个结果倒也知足了。\n\n自己原本没有打算找公司，后来我同学说可以把我推进他们公司，环境好，离家不远，就去试一试，得了\noffer，试用期工资 6k\n一月，考虑毕业后去看看，环境不错。不过我们比赛完毕，前三名是有一个去戴尔公司面试的机会的，到时候希望能够拿到\noffer，然后在做对比吧。\n\n随后就是考研了，考研那几天压力特别大，不知道怎么和父母交代，在考场上看着空白的卷子，自己很是无助，但是我自己乐于接受这种结果。后来自己给父母说，自己的父母意外的开明，没有说任何怪我的话，叫我好好找工作，好好去北京实习。那一科真的很感动，自己心里也放下了一块大石头，不管怎么说我都是他们的孩子，是他们的骄傲啊。自己的父母真的很好，我最庆幸的就是自己有一个幸福美满的家庭，没有多灾多难，也没有什么生离死别。但是他们身体越发的虚弱了，父亲身体不适已经一周没有上班了，请假输液，母亲也感冒很严重还坚持去开店赚钱，心疼他们，我也只能好好学习以后好好的赚钱生活。\n\n原打算考完研回家的，谁知又是连续一周的党课培训，自己非常抱怨。但是赛翁失马，焉知非福？他反而改掉了我晚睡晚起的坏习惯。现在回家后的生活很有规律，作息也很正常，每天就是学习，带带我侄女，听听父母唠叨，聊聊天，自己很享受。\n\n就在昨天，老家一个亲属过世了，我爸妈去帮忙，我帮我妈看了半天的店铺，整个人都忙得不可开交，\n\n那一刻自己都快被忙哭了。我真的不知道我母亲一个那么瘦小的人，怎么在那么高强度的工作下坚持下来的，整个店铺不到十平米，却挤满了十多个人，门口还有很多人排队。我一个人也是忙了近两个小时才忙完，算了一下，一天\n500\n块。那么高强度的工作值收获了五百块。那时候我真的心疼我的母亲，她那么小的身躯是要有多大的能力和毅力才能够一个人撑起那个店铺，撑起这个家的，而且一撑就是二十多年，如果没有母亲，我父亲只靠国家的固定工资绝对没有今天的我家和我的。父母真的是世界上最伟大的人。也怪不得父亲总是在下班后去店里帮忙，他们每天八点才回家吃饭了。而我以前总是抱怨他们回家晚饿肚子，那个时候的我是多么幼稚。如果不是生活所迫谁又愿意让自己的孩子在家饿着肚子呢？\n\n== 年少轻狂\n\n22\n岁的我，在很多人眼里都是小孩，长不大的孩子。我有很多的好朋友，在贵州的，在福建的，在山东的，在北京的，在沈阳的，在上海的。他们每一个都是我的好朋友，每次和他们聊天都是那么轻松愉快，我再怎么幼稚他们都不会嫌弃我，再怎么耍赖他们都会惯着我，觉得自己真的很幸福。但是自己要一直不断向前，一直不断的努力，因为他们每一个人都很优秀。有的考上研了，有的有各种技能，还有的要出国。这些的一些，又一些，都是我必须前进的动力。\n\n这一年除了家里给的钱，得了很多钱，来源大概有如下：\n\n* 压岁钱\n* 国家奖学金\n* 校一等奖学金\n* 比赛奖金\n* 项目经费\n* 一些外快\n\n总的加起来也有几万了，比往年多了很多。也参加了一些比赛：\n\n* 我校的程序设计大赛 —— 一等奖\n* 互联网 + —— 银奖\n* 人工智能技能应用大赛 —— 二等奖\n* ICPC 贵州赛区 —— 银奖\n* ICPC 贵州邀请赛 —— 银奖\n* 蓝桥杯 —— 省一\n\n拒绝了 ICPC 中国邀请赛\n，也拒绝了蓝桥杯的国赛，转而去考了软考。竞赛相比去年少了很多，也少了国奖。想想能够拿得出来的认证也就是\nRHCE 和 中级软件设计师了。\n\n但是却是迎来了一个有难度的挑战：毕业设计。\n\n我的毕业设计是由系主任指定的：毕业设计指导系统。包括毕业选题、论文管理、指导记录、毕业答辩评分等等功能，这是我最后的一次的轻狂，我要尽力的把它做好！努力的完成我大学的最后一个项目，希望他称为留给学校的最后一笔财富，是第一届软件工程专业的学长留给后面的学弟学妹的最后一个项目。所以我为他立了很多指标，希望能够一一达到，也许是我狂妄，但我觉得我有狂妄的资本。\n\n也许在以后，自己再也没有机会去全心全意的去完成这么一件有意义的事情了。\n\n非常喜欢党课的时候老师说的习主席说的一句话：”*功成不必在我，功成必定有我*。“\n\n自己非常乐意为学校和专业作出一份贡献。\n\n== 未来\n\n2020\n将是我踏入社会的第一年，也是我毕业的一年。未来路途遥远，但我一点都不怕，有家人，有朋友，有兄弟，我还怕什么呢？只要保持一个向上的心去面对就好；乐观而又积极，平淡而又朴实。\n\n送给自己一句话：\n\n____\n我即少年慕磊落，谁能教我坦荡荡？\n____\n\n*2020，与君共勉*。\n\n","fields":{"slug":"/articles/2019/12/31/1577769144050.html","birthTime":"2019-12-31T05:12:24.107Z","modifiedTime":"2019-12-31","year":2019},"document":{"title":"2019，最后的轻狂"}},{"content":"= Spring Security Oauth2 从零到一完整实践（六）踩坑记录\n:page-description: 时隔半年，终于要来填坑了。不过经过这段时间的学习和实践，确实解决了不少问题。现在在这里一一记录一下。\n:page-category: spring\n:page-image: https://img.hacpai.com/bing/20181116.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2020/01/20/1579503807596.html\n:page-created: 1579503807648\n:page-modified: 1587795903960\n:toc:\n\n[IMPORTANT]\n*注意注意：本文章适用于5.3以前的spring security以及spring boot 2.3.x\n以前的 oauth，以下内容应该为过时！spring 提供新的 oauth2\n授权服务器。目前正在https://spring.io/blog/2019/11/14/spring-security-oauth-2-0-roadmap-update[实验性阶段]*\n\n时隔半年，终于要来填坑了。不过经过这段时间的学习和实践，确实解决了不少问题。现在在这里一一记录一下。\n\n不过在这之前，还是需要说一下19年11月一件关于 spring security oauth\n的大事，参见官网文章\nhttps://spring.io/blog/2019/11/14/spring-security-oauth-2-0-roadmap-update[Spring\nSecurity OAuth 2.0 Roadmap Update]。主要有以下两个点：\n\n[arabic]\n. *不再支持 OAuth2 授权服务器*。\n. spring security oauth 迁移至 spring security 中\n\n*但是由于第一点收到了太多用户的反馈，建议继续支持授权服务器，所以现在进行重新决议，目前正在决议中。另外还有一个项目生命周期的维护：*\n\n[NOTE]\nThe currently supported branches are 2.3.x and 2.4.x. The 2.3.x line\nwill reach EOL in March 2020. We will support the 2.4.x line at least\none year after reaching feature parity.\n\n目前官方支持的两个版本就是 spring security oauth 2.3.x 和\n2.4.x，其中，2.3.x 版本会在 2020 年 3 月的时候停止支持和维护，而 2.4.x\n会至少一年后停止支持和维护。\n\n在 spring security oauth 的项目中的 master\n分支（即2.4.x版本），相关的注解如\n`EnableAuthorizationServer`，都被标记为了 *过时* 。并给出了迁移 spring\nsecurity 的 wiki\n链接：https://github.com/spring-projects/spring-security/wiki/OAuth-2.0-Migration-Guide[OAuth-2.0-Migration-Guide]。\n\n但是现在的主要依赖（如现在的spring boot 2.2.3）都还是 spring security\noauth 的 2.3.x 分支，也就是说目前还是可以使用的。预计在三月，会使用它的\n2.4.x\n分支了。但是个人觉得自定义授权服务器还是非常重要的，很多场景下都适用，并且可以自己规划非常方便。所以也是希望他继续支持授权服务器的，并且在近一年内，spring\nsecurity oauth 的授权服务器都会继续使用，我也在我们学校搭建了一个 oauth2\n的授权中心：https://github.com/gzmuSoft/authorization-server[authorization-server]。这段时间也踩了不少坑，记录一下。\n\n____\n注意：以下内容依旧使用 spring security oauth 项目。\n____\n\n== 系列文章\n\n[arabic]\n. https://echocow.cn/articles/2019/07/14/1563082088646.html[较为详细的学习\noauth2 的四种模式其中的两种授权模式]\n. https://echocow.cn/articles/2019/07/14/1563082247386.html[spring boot\noauth2 自动配置实现]\n. https://echocow.cn/articles/2019/07/14/1563096109754.html[spring\nsecurity oauth2 授权服务器配置]\n. https://echocow.cn/articles/2019/07/20/1563611848587.html[spring\nsecurity oauth2 资源服务器配置]\n. https://echocow.cn/articles/2019/07/30/1564498598952.html[spring\nsecurity oauth2 自定义授权模式（手机、邮箱等）]\n. spring security oauth2 踩坑记录\n\n== REFRESH_TOKEN 第一次有效\n\n在刷新 token 的时候，携带 `refresh_token` 去请求 `/oauth/token`\n端点，会生成新的 `access_token` 和\n`refresh_token`，但是你会发现，*只有第一次的 `refresh_token`\n可以使用，后面的都不能够使用*。这个问题主要原因来自于授权服务器端点配置，*默认情况下，授权服务器的端点配置会有这么一个属性：`reuseRefreshToken`\n表示重复使用刷新令牌*。也就是说会一直重复使用第一次请求到的\n`refresh_token`，而后面的 `refresh_token` 就是无效的了。\n\n____\n参见\n`org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer`\n____\n\n所以我们需要修改一下这个设置\n\n[source,java]\n----\npublic class Oauth2AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter{\n    // ...\n    @Override\n    public void configure(AuthorizationServerEndpointsConfigurer endpoints) {\n        endpoints..reuseRefreshTokens(false);\n    }\n    // ...\n}\n----\n\n== 自定义客户端信息\n\n很多时候我要从数据库中读取客户端信息，但是不希望使用它的表结构来创建表，这个时候需要我们去自定义客户端信息。就像自定义用户信息一样，需要实现\n`org.springframework.security.oauth2.provider.ClientDetailsService`\n接口。它的返回值是\n`org.springframework.security.oauth2.provider.ClientDetails`。所以这里有两种实现方式\n\n* 第一种实体类实现 `ClientDetails` 接口\n* 第二种就是在写一个转换的方法，把你的 `ClientDetails` 转换为它的\n`ClientDetails`\n\n第一种可以参见： https://github.com/xkcoding/spring-boot-demo/blob/dev/spring-boot-demo-oauth/spring-boot-demo-oauth-authorization-server/src/main/java/com/xkcoding/oauth/entity/SysClientDetails.java[*SysClientDetails*]\n\n这里我使用的是第二种。\n\n[source,java]\n----\npublic org.springframework.security.oauth2.provider.ClientDetails buildSpringClientDetails() {\n    BaseClientDetails details = new BaseClientDetails(clientId, resourceIds, scope, grantTypes, authorities, redirectUrl);\n    details.setClientSecret(clientSecret);\n    details.setAutoApproveScopes(Collections.singletonList(autoApproveScopes));\n    details.setAccessTokenValiditySeconds(accessTokenValidity);\n    details.setRefreshTokenValiditySeconds(refreshTokenValidity);\n    details.setAdditionalInformation(JSON.parseObject(additionalInformation));\n    return details;\n}\n----\n\n然后将我们写的实现 `ClientDetailsService` 接口的 service 配置进去即可：\n\n[source,java]\n----\npublic class Oauth2AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {\n    // ......\n    @Override\n    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {\n        // 从数据库读取我们自定义的客户端信息\n        clients.withClientDetails(sysClientDetailsService);\n    }\n    // ......\n}\n----\n\n== 多类型混合存储\n\n我的一个需求就是，客户端信息我需要持久化存储，存在 `postgresql`\n里面，而我的 `token` 相关的需要频繁取出或者修改，所以我希望他存在\n`redis` 里面并且需要使用 jwt\n非对称密钥转换。那么我就要从两个不同的地方取出不同的东西。所以我们需要给他两个东西\n\n[arabic]\n. `RedisTokenStore`：从 Redis 中获取 token\n. `ClientDetailsService` ：从 Postgresql 中获取客户端信息\n\n这个时候 `JwtTokenStore` 不是必须的，需要的是 `JwtAccessTokenConverter`\n来进行令牌的转换。\n\n[source,java]\n----\n@Bean\n@Primary\npublic TokenStore tokenStore() {\n    return new RedisTokenStore(redisConnectionFactory);\n}\n\n@Bean\npublic JwtAccessTokenConverter jwtAccessTokenConverter() {\n    final JwtAccessTokenConverter accessTokenConverter = new JwtAccessTokenConverter();\n    accessTokenConverter.setKeyPair(keyPair());\n    return accessTokenConverter;\n}\n\n@Bean\npublic KeyPair keyPair() {\n    KeyStoreKeyFactory keyStoreKeyFactory = new KeyStoreKeyFactory(new ClassPathResource(\"oauth.jks\"), \"123456\".toCharArray());\n    return keyStoreKeyFactory.getKeyPair(\"oauth\");\n}\n----\n\n同样，在有其他的组合需求的时候也只需要提供相应的实现就可以了。\n\n== 授权服务器、资源服务器共存\n\n这个是比较头疼的地方了。头疼在哪里呢？就是头疼在 `CSRF` 这么个东西。\n\n[TIP]\n参见：\n https://zh.wikipedia.org/zh/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%5D(https://zh.wikipedia.org/zh/跨站请求伪造)[CSRF\n跨站请求伪造]\n\n我希望我的项目即是资源服务器，又是授权服务器。说白了他能够提供令牌发放的功能，但是也通过简单的一些查询的功能。*但是当他作为授权服务器的时候，使用授权码模式的时候，他是一个使用模板引擎的前后端未分离的项目，而当他作为资源服务器的时候，他是一个前后端分离的提供\nAPI 服务的项目。那么这个时候 CSRF 就比较棘手了*。\n\n在前后端未分离的情况下，需要提交 post 请求的时候都要经过 `CSRF`\n认证才可以进行提交，所以你不能够简单粗暴的直接关闭\n`CSRF`，因为他可能带来安全问题。而在前后端分离的情况下我们使用了 JWT\n非对称加密，所以是不存在 `CSRF` 安全的问题的，\n\n就目前而言，我并没有找到一个好的方式来处理 POST 请求下的 CSRF\n问题，一个方法就是，不使用 `@EnableResourceServer`\n自己编写一个资源服务器的相关配置。但是太过于复杂了。当然还有其他曲线救国的方法，比如自己定义一些过滤规则，或者自己手动加上\n`csrf_token` 等，不过都是有一定的代码量的。\n\n个人认为最佳的实践就是，授权服务器提供部分资源服务器的功能，比如查询一些相关的数据，也就是只提供\nGET\n方法，而修改数据则是单独用一个资源服务器来完成。授权服务器只提供发放、校验令牌和一些信息的查询功能，*不提供增删改等复杂的功能*，这样也能够减少授权服务器的压力。\n\n== 资源服务器安全配置顺序\n\n当我配置资源服务器的时候，会涉及到 spring security 相关的配置和 spring\nsecurity oauth resource server\n相关的配置。这里需要非常注意他们的顺序问题：\n\n* spring secruity 需要继承 `WebSecurityConfigurerAdapter` ，order 为 100\n* spring security oauth resource server 需要继承\n`ResourceServerConfigurerAdapter`， order 为 3\n\n他们两个都会对安全进行控制，所以要很好的调配。个人建议完全只交给一个去完成安全的控制，order\n越小，优先级越高。\n\n== 安全退出\n\n什么是安全退出呢？我个人的理解就是点击退出以后，它的 `token`\n完全失效了。举个栗子：\n\n[arabic]\n. 小明在家登录了，获取了一个令牌 `access_token1`。\n. 小明在家没有退出，去公司又登录了，获取到了同一个令牌 `access_token1`\n. 晚上小明回家了，突然想起公司的电脑还保留自己的登录状态，但是又不能够叫别人帮忙退出登录或者删除登录状态。\n. 他只需要在家安全退出，那么 `access_token1`\n将会被完全销毁，在家、在公司，都不再保持登录状态。\n. 他在家安全退出后再次登录，获取了一个新的令牌 `access_token2`。\n\n总结就是 ``**一处退出，处处退出**''。当然，这种模式只有在 *授权码模式*\n有效，非授权码模式客户端只要删除本地存储的令牌即可，但是没有办法做到安全退出的。\n\n在授权码模式下，我们登录是要在授权服务器这边进行登录的，所以在授权服务器这边存在用户相关的\n`session`，因此退出的时候我们也要来授权服务器这边进行一次退出，再去客户端那边进行一次退出。因此我们需要客户端那边传递一个退出完成的回调地址给我们进行跳转，我们主要有如下步骤：\n\n[arabic]\n. 自定义退出端点\n. 自定义退出页面\n. 自定义退出成功处理器\n. spring security 配置\n\n=== 自定义退出端点\n\n就是写一个控制器\n\n[source,java]\n----\n@Controller\n@RequestMapping(\"/oauth\")\n@RequiredArgsConstructor\npublic class OauthController {\n    @GetMapping(\"/logout\")\n    public ModelAndView logoutView(\n            @RequestParam(\"redirect_url\") String redirectUrl,\n            // 如果存在客户端 id，就是安全退出，否则只是普通退出\n            @RequestParam(name = \"client_id\", required = false) String clientId,\n            // 登录用户的信息\n            Principal principal) {\n        if (Objects.isNull(principal)) {\n            // 如果用户的 session 已经失效，那么授权服务器这边是已经没有用户信息了的\n            // 直接重定向到回调地址\n            return new ModelAndView(new RedirectView(redirectUrl));\n        }\n        ModelAndView view = new ModelAndView();\n        // 视图名称\n        view.setViewName(\"logout\");\n        /// 用户名称\n        view.addObject(\"user\", principal.getName());\n        view.addObject(\"redirectUrl\", redirectUrl);\n        view.addObject(\"clientId\", clientId);\n        return view;\n    }\n}\n----\n\n=== 自定义退出页面\n\n页面各有不同，可以参考我写的\nhttps://github.com/gzmuSoft/authorization-server/blob/master/src/main/resources/templates/logout.html[logout.html]。注意\nPOST 提交需要携带 `csrf_token`。\n\n=== 自定义退出成功处理器\n\n[source,java]\n----\n@Slf4j\n@Component\n@AllArgsConstructor\npublic class AuthLogoutSuccessHandler implements LogoutSuccessHandler {\n    private final @NonNull Oauth2Helper oauth2Helper;\n\n    @Override\n    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException {\n        String redirectUrl = request.getParameter(\"redirectUrl\");\n        // 一般来说回调地址是必填的，不会有为空的情况\n        // 但是如果用户直接浏览器输入授权服务器的退出地址，就可能不存在\n        // 所以需要判断一下，如果没有就让他重定向到登录页面\n        if (StringUtils.isBlank(redirectUrl)) {\n            redirectUrl = \"/oauth/login\";\n        }\n        String clientId = request.getParameter(\"clientId\");\n        // 如果客户端 id 不为空，就是安全退出，需要清除内存或者redis中的当前用户的令牌信息\n        if (StringUtils.isNoneBlank(clientId)) {\n            oauth2Helper.safeLogout(clientId, authentication);\n        }\n        // 设置状态码和重定向地址\n        response.setStatus(HttpStatus.FOUND.value());\n        response.sendRedirect(redirectUrl);\n    }\n}\n----\n\n安全推出的逻辑\n\n[source,java]\n----\n@Component\n@RequiredArgsConstructor\npublic class Oauth2Helper {\n    private final TokenStore tokenStore;\n    /**\n     * 如果携带了 clientId，清除 令牌 信息\n     * 实现 一处退出，处处退出\n     *\n     * @param clientId       clientId\n     * @param authentication authentication\n     */\n    public void safeLogout(String clientId, Authentication authentication) {\n        tokenStore\n                .findTokensByClientIdAndUserName(clientId, authentication.getName())\n                .forEach(oAuth2AccessToken -> {\n                    tokenStore.removeAccessToken(oAuth2AccessToken);\n                    tokenStore.removeRefreshToken(oAuth2AccessToken.getRefreshToken());\n                });\n    }\n}\n----\n\n=== spring security 配置\n\n前面说道资源服务器安全配置的顺序，这里我是完全交给了 spring security\n来管理，配置一下相关信息：\n\n[source,java]\n----\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                // ......\n                .formLogin()\n                .loginPage(\"/oauth/login\")\n                .loginProcessingUrl(\"/authorization/form\")\n                .failureHandler(authFailureHandler)\n                .successHandler(authSuccessHandler)\n                .and()\n                // 退出登录相关\n                .logout()\n                // 退出登录的 url，post 方法\n                .logoutUrl(\"/oauth/logout\")\n                // 推出登录成功处理器\n                .logoutSuccessHandler(authLogoutSuccessHandler);\n    }\n----\n\n=== 效果\n\n自己写了一个简单的 demo，前后端分离，前端使用vue，后端就是spring\nboot，授权服务器就是我们学校的授权服务器。*注意看 URL 的变化*。\n\nimage::https://resources.echocow.cn/file/2020/01/20logout.gif[logout]\n\n== JWK 端点\n\n在 spring secruity oauth 迁移 spring security\n的过程中，我发现资源服务器和客户端都支持 jwk 端点了。所以引入一下 jwk\n端点：\n\n你可能需要引入如下依赖：\n\n[source,bash]\n....\ngroup id: org.wso2.orbit.com.nimbusds\nartifactId: nimbus-jose-jwt\n....\n\n添加如下端点：\n\n[source,java]\n----\nimport com.nimbusds.jose.jwk.JWKSet;\nimport com.nimbusds.jose.jwk.RSAKey;\nimport lombok.AllArgsConstructor;\nimport lombok.NonNull;\nimport net.minidev.json.JSONObject;\nimport org.springframework.security.oauth2.provider.endpoint.FrameworkEndpoint;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport java.security.KeyPair;\nimport java.security.interfaces.RSAPublicKey;\n\n@FrameworkEndpoint\n@AllArgsConstructor\npublic class JwkEndpoint {\n    // 这是前面 @Bean 添加的非对称加密的密钥对\n    private final @NonNull KeyPair keyPair;\n\n    @GetMapping(\"/.well-known/jwks.json\")\n    @ResponseBody\n    public JSONObject getKey() {\n        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();\n        // 注意 包 别引错\n        RSAKey key = new RSAKey.Builder(publicKey).build();\n        return new JWKSet(key).toJSONObject();\n    }\n\n}\n----\n\n当然，目前 JWK 是完全暴露出来的，个人认为还是需要进行 BASIC\n认证的，但是目前还没找到在哪儿加的好。\n\n== 自定义端点路径\n\n目前 spring security oauth 提供的端点都是\n`/oauth/token`，`/oauth/token_key`\n之类的，如果我们需要自定义呢？配置如下：\n\n[source,java]\n----\npublic class Oauth2AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {\n    @Override\n    public void configure(AuthorizationServerEndpointsConfigurer endpoints) {\n        // ......\n        endpoints.pathMapping(\"/oauth/token\", \"/auth/token\");\n        // ......\n    }\n\n}\n----\n\n== RBAC 动态权限控制\n\n目前找到两种比较好的权限控制：\n\n[arabic]\n. 自定义 `FilterInvocationSecurityMetadataSource` 和\n`AccessDecisionManager`\n. 自定义权限表达式\n\n我使用的是第一种，安全配置如下：\n\n[source,java]\n----\nprivate final FilterInvocationSecurityMetadataSource securityMetadataSource;\nprivate final AuthAccessDecisionManager authAccessDecisionManager;\n// ......\nhttp\n    .authorizeRequests()\n    .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\n        @Override\n        public <O extends FilterSecurityInterceptor> O postProcess(O o) {\n            o.setSecurityMetadataSource(securityMetadataSource);\n            o.setAccessDecisionManager(authAccessDecisionManager);\n            return o;\n        }\n    }).anyRequest().permitAll()\n----\n\n具体实现可以参见\nhttps://github.com/gzmuSoft/lesson-cloud/tree/master/lesson-cloud-auth/src/main/java/cn/edu/gzmu/auth/res[res]。\n\n当然，在第二个项目中我使用了第二种方式，不过是基于 webflux 的，参见\nhttps://github.com/gzmuSoft/authorization-center-web/blob/master/src/main/kotlin/cn/edu/gzmu/center/config/ResourceConfig.kt[ResourceConfig]。\n\n== 传统项目的过渡\n\n如何对传统项目进行添加 token\n解析呢？直接将他们作为一个资源服务器肯定是不行的，光是 CSRF\n问题就是比较难处理的了。我们完全可以手动解析\nTOKEN，比较好的一种方式就是自定义一个过滤器，放在\n`org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter`\n之前进行用户的验证，如果请求头中有 `AUTHORIZATION` 并且是以 `Bearer`\n开头的，那么就进行手动解析一下然后存在安全上下文之中就可以了。\n\n可以参考我写的\nhttps://github.com/gzmuSoft/authorization-server/blob/master/src/main/java/cn/edu/gzmu/authserver/auth/res/SecurityMetadataSource.java#L141[AuthToken]\n。\n\n== 测试\n\n它的测试比较复杂，我只会写它的集成测试，对于单元测试涉及到的东西太多了，所以不会。。。\n\n集成测试中，就是向授权服务器获取\ntoken，通过密码模式获取最为简单，授权码模式涉及到 `csrf_token`\n的问题比较复杂，并且不止一个请求。自己也写了一些以供参考\n\n* 密码模式获取令牌： https://github.com/gzmuSoft/lesson-cloud/blob/master/lesson-cloud-core/src/test/java/cn/edu/gzmu/integration/Oauth2RestTemplate.java[Oauth2RestTemplate]\n* 授权码模式获取授权码： https://github.com/xkcoding/spring-boot-demo/blob/master/spring-boot-demo-oauth/spring-boot-demo-oauth-authorization-server/src/test/java/com/xkcoding/oauth/oauth/AuthorizationCodeGrantTests.java#L66[testCodeAcquisitionWithCorrectContext]\n\n个人觉得开发的时候用密码模式就好，目前我们的测试是继承\nOauth2RestTemplate 就可以获取到已经拥有 access_token 的restTemplate\n直接请求数据即可。\n\n== 总结\n\n这是目前能够想到的，其实在实践的过程中还有很多的坑，自己也被很多问题卡了很久。庆幸的是后面都过来了。其实预计这个是这个系列的最后一篇文章，但是计划赶不上变化，spring\nsecurity oauth 客户端和资源服务器已经开始迁移到了 spring security 5.2\n里面去了。所以可能后面还要写一篇博客来学习吧，在实践的过程中确实发现其实迁移过后的资源服务器更加简单，并且定制起来非常容易。相比起原来其实好了很多。不管是\nservlet 的也好，还是 webflux\n的也好，都比以前高度可定制了很多。后面会继续更新的～\n\n","fields":{"slug":"/articles/2020/01/20/1579503807596.html","birthTime":"2020-01-20T07:03:27.648Z","modifiedTime":"2020-04-25","year":2020},"document":{"title":"Spring Security Oauth2 从零到一完整实践（六）踩坑记录"}},{"content":"= vert.x 4 日志配置\n:page-description: vert.x 4 日志配置\n:page-category: vert.x\n:page-image: https://img.hacpai.com/bing/20190603.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2020/01/31/1580462516035.html\n:page-created: 1580462516228\n:page-modified: 1580469306324\n:toc:\n\n\n目前（2020-1-30）在 https://vertx.io/docs/vertx-core/java/#_logging[Vert.x 官网日志配置]\n的版本还是处于 3.8.x 版本的。在 vertx 3 版本中，我都是直接使用 `JUL`\n来进行日志配置，因为在默认情况下，vert.x 会使用 Java 默认的日志 `JUL` 即\n`Java Util Log`，并读取 `resource` 下的\n`vertx-default-jul-logging.properties` 文件并且不需要加任何依赖。\n\n如果需要添加其他的日志依赖还需要设置以下相应的环境变量，例如：\n\n[source,kotlin]\n----\nSystem.setProperty(LOGGER_DELEGATE_FACTORY_CLASS_NAME, SLF4JLogDelegateFactory::class.java.name)\n----\n\n但是在 vert.x 4 的版本中，`io.vertx.core.logging.LoggerFactory`\n已经被标记为了 *过时* 状态。具体原因见 https://github.com/eclipse-vertx/vert.x/issues/2774[Github\nIssue]。大意就是 vert.x\n作为一个工具库，公开的日志存在一些移植性上的问题，不提供内部的日志的职责，并且在以后的主要版本中将其用作内部记录器。如果需要使用日志，自行配置使用。\n\n事实上在现在已经发布的 `vert.x 4.0.0-SNAPSHOT`\n中，也同样对其进行了说明。而在新的官网文档(4.0.0)中提到：\n\n[4.0.0]\n====\n=== Logging\n\nVert.x logs using its internal logging API and supports various logging\nbackends.\n\nThe logging backend is selected as follows:\n\n[arabic]\n. the backend denoted by the `vertx.logger-delegate-factory-class-name`\nsystem property if present or,\n. JDK logging when a `vertx-default-jul-logging.properties` file is in\nthe classpath or,\n. a backend present in the classpath, in the following order of\npreference:\n[arabic]\n.. SLF4J\n.. Log4J\n.. Log4J2\n\nOtherwise Vert.x defaults to JDK logging.\n\n==== Configuring with the system property\n\nSet the `vertx.logger-delegate-factory-class-name` system property to:\n\n* `io.vertx.core.logging.SLF4JLogDelegateFactory` for SLF4J or,\n* `io.vertx.core.logging.Log4jLogDelegateFactory` for Log4J or,\n* `io.vertx.core.logging.Log4j2LogDelegateFactory` for Log4J2 or,\n* `io.vertx.core.logging.JULLogDelegateFactory` for JDK logging\n\n==== Configuring JUL logging\n\nA JUL logging configuration file can be specified in the normal JUL way,\nby providing a system property named `java.util.logging.config.file`\nwith the value being your configuration file. For more information on\nthis and the structure of a JUL config file please consult the JDK\nlogging documentation.\n\nVert.x also provides a slightly more convenient way to specify a\nconfiguration file without having to set a system property. Just provide\na JUL config file with the name `vertx-default-jul-logging.properties`\non your classpath (e.g. inside your fatjar) and Vert.x will use that to\nconfigure JUL.\n====\n\n== JUL\n\n对于 `JUL` 依旧没有改变，只需要添加\n`vertx-default-jul-logging.properties` 文件即可。我以前项目的配置：\n\n[source,properties]\n----\nhandlers=java.util.logging.ConsoleHandler,java.util.logging.FileHandler\n# 日志格式化\njava.util.logging.SimpleFormatter.format=%1$tc %4$s: %3$s %n%5$s  %n\njava.util.logging.ConsoleHandler.formatter=java.util.logging.SimpleFormatter\njava.util.logging.ConsoleHandler.level=INFO\n# 日志输出设置\njava.util.logging.FileHandler.level=WARNING\njava.util.logging.FileHandler.formatter=java.util.logging.SimpleFormatter\njava.util.logging.FileHandler.pattern=%h/vertxLog/Drcom.log\n\n.level=INFO\nio.vertx.ext.web.level=FINEST\nio.vertx.level=INFO\ncom.hazelcast.level=INFO\nio.netty.util.internal.PlatformDependent.level=SEVERE\n----\n\n但是众所周知，`JUL` 的功能不如 Logback/Log4j2 等完善，比如 Output\nHandler 就没有 Logback/Log4j2\n的丰富，有时候需要自己来继承定制，又比如它的配置局限性很大，格式化、控制台颜色、日志输入等都没有太完善的支持。\n\n所以我们大可以抛弃使用 `JUL` 转而使用 `Logback` 或者\n`Log4j2`。这次我选择使用的是 `Log4j2`，他吸取了 `Logback`\n的优点，并且可以完美配合 `SLF4J` 来进行使用。\n\n____\n为什么一定要使用 `SLF4J` 呢？\n\n这就涉及到一个概念，`JCL` —— *Commons Logging*。`JCL` 是一个\n`Log Facade`，只提供 `Log API`，不提供实现。而 `SLF4j` 是类似于 `JCL` 的\n`Log Facade`，其作者认为 `JCL` 的 `API`\n设计得不好，容易让使用者写出性能有问题的代码，所以自己写了一套\n`Log Facade` 。而有了相应的 `Log API` 就要有相应的\n`Log Implementation`，而 `Log4j2` 设计上很大程度上模仿了\n`SLF4J`/`Logback`，性能上也获得了很大的提升。\n____\n\n== Log4j2 + SLF4J\n\n毫无疑问，项目中应该只使用一个具体的 `Log Implementation`。我们选择了\n`Log4j2`，\n\n从 vert.x 4 的官网文档中可以明确知道，他加载的顺序如下：\n\n[arabic]\n. 系统环境是否设置了\n`vertx.logger-delegate-factory-class-name`，如果有，就是用设置的值。\n. `JUL` 的配置文件 `vertx-default-jul-logging.properties` 是否在\n`classpath` 下\n. 如果上面都没有，就在 `classpath` 下按照顺序查找以下包是否存在\n[arabic]\n.. `SLF4J`\n.. `Log4J`\n.. `Log4J2`\n\n如果以上都没有，使用 `vert.x` 默认的 `JUL` 配置。\n\n所以 `vert.x` 4 中，是不需要我们去手动设置\n`vertx.logger-delegate-factory-class-name` 参数了，他会默认去加载\n`classpath` 下的日志库的。因此我们需要添加相关的依赖。事实上现在\n`Log4j2` 对 `SLF4J`\n的支持简直好得不要不要的。以至于连以前添加一个日志需要加 3 - 5\n个依赖的，现在只需要一个。如果你有兴趣翻看过文档的话应该可以看到https://logging.apache.org/log4j/2.0/log4j-slf4j-impl/index.html[这篇]。\n\n____\n[arabic]\n. `log4j-slf4j-impl` should be used with `SLF4J` *1.7.x* releases or\nolder.\n. `log4j-slf4j18-impl` should be used with `SLF4J` *1.8.x* releases or\nnewer.\n____\n\n如果我们想用 `Log4j2` + `SLF4J` 的组合，直接选择 `log4j-slf4j-impl` 或者\n`log4j-slf4j18-impl` 即可。这里当然选用 `log4j-slf4j18-impl`\n使用最新版本 `2.13.0`。它包含如下依赖：\n\n* `org.slf4j:slf4j-api:1.8.0-alpha2`\n* `org.apache.logging.log4j:log4j-api:2.13.0`\n* `org.apache.logging.log4j:log4j-core:2.13.0`\n\n这三个依赖已经包含了我们所有需要引入的东西。\n\n接下来就是添加相应的配置文件了，配置文件网上一搜有很多的，这是我用的\n\n[source,xml]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration status=\"WARN\" monitorInterval=\"30\">\n\n  <Properties>\n    <Property name=\"LOG_PATH\" value=\"./logs\"/>\n    <Property name=\"LOG_TMP_FILE\" value=\"./logs/authorization-center-tmp.log\"/>\n    <Property name=\"LOG_INFO_FILE\" value=\"./logs/authorization-center-info.log\"/>\n    <Property name=\"LOG_WARN_FILE\" value=\"./logs/authorization-center-warn.log\"/>\n    <Property name=\"LOG_ERROR_FILE\" value=\"./logs/authorization-center-error.log\"/>\n    <Property name=\"CONSOLE_LAYOUT\"\n              value=\"%style{%d{yyyy-MM-dd HH:mm:ss.SSS}}{Blue,Bright} %highlight{${LOG_LEVEL_PATTERN:-%5p}}{FATAL=bg_red, ERROR=red, WARN=yellow, INFO=green, DEBUG=grey, TRACE=blue} %style{%pid}{magenta} --- %style{[%15.15t] %-40.40c{1.}}{cyan,Bright} : %m%n%ex\"/>\n    <Property name=\"FILE_LAYOUT\"\n              value=\"%d{yyyy-MM-dd HH:mm:ss.SSS} ${LOG_LEVEL_PATTERN:-%5p} %pid --- [%15.15t] %-40.40c{1.} : %m%n%ex\"/>\n  </Properties>\n\n  <Appenders>\n    <Console name=\"Console\" target=\"SYSTEM_OUT\">\n      <PatternLayout pattern=\"${CONSOLE_LAYOUT}\"/>\n    </Console>\n    <RollingFile name=\"RollingFileInfo\" fileName=\"${LOG_INFO_FILE}\"\n                 filePattern=\"${LOG_PATH}/info/info.%d{yyyy-MM-dd}.%i.log.gz\">\n      <ThresholdFilter level=\"info\" onMatch=\"ACCEPT\" onMismatch=\"DENY\"/>\n      <PatternLayout pattern=\"${FILE_LAYOUT}\"/>\n      <Policies>\n        <TimeBasedTriggeringPolicy/>\n        <SizeBasedTriggeringPolicy size=\"50MB\"/>\n      </Policies>\n    </RollingFile>\n    <RollingFile name=\"RollingFileWarn\" fileName=\"${LOG_WARN_FILE}\"\n                 filePattern=\"${LOG_PATH}/warn/warn.%d{yyyy-MM-dd}.%i.log.gz\">\n      <ThresholdFilter level=\"warn\" onMatch=\"ACCEPT\" onMismatch=\"DENY\"/>\n      <PatternLayout pattern=\"${FILE_LAYOUT}\"/>\n      <Policies>\n        <TimeBasedTriggeringPolicy/>\n        <SizeBasedTriggeringPolicy size=\"50MB\"/>\n      </Policies>\n    </RollingFile>\n    <RollingFile name=\"RollingFileError\" fileName=\"${LOG_ERROR_FILE}\"\n                 filePattern=\"${LOG_PATH}/error/error.%d{yyyy-MM-dd}.%i.log.gz\">\n      <ThresholdFilter level=\"warn\" onMatch=\"ACCEPT\" onMismatch=\"DENY\"/>\n      <PatternLayout pattern=\"${FILE_LAYOUT}\"/>\n      <Policies>\n        <TimeBasedTriggeringPolicy/>\n        <SizeBasedTriggeringPolicy size=\"50MB\"/>\n      </Policies>\n    </RollingFile>\n  </Appenders>\n  <Loggers>\n    <Logger name=\"cn.edu.gzmu.center\" level=\"debug\" additivity=\"false\">\n      <AppenderRef ref=\"Console\"/>\n    </Logger>\n    <Root level=\"info\">\n      <AppenderRef ref=\"Console\"/>\n      <AppenderRef ref=\"RollingFileInfo\"/>\n      <AppenderRef ref=\"RollingFileWarn\"/>\n      <AppenderRef ref=\"RollingFileError\"/>\n    </Root>\n  </Loggers>\n</Configuration>\n----\n\n当然，`log4j2` 的功能很强大，还有严格模式的 `xml`、`json`、`yaml`\n等配置方式，都是不错的。而且他支持控制台的颜色输出等，比如我配置的颜色是这样的：\n\nimage::https://resources.echocow.cn/file/2020/01/30/深度截图_选择区域_20200131170626.png[color]\n\n可以去看https://logging.apache.org/log4j/2.x/manual/layouts.html[官方文档]\n，非常详细。\n\n=== 使用\n\n使用的时候需要用的是如下两个包：\n\n* `io.vertx.core.impl.logging.LoggerFactory`\n* `io.vertx.core.impl.logging.Logger`\n\n使用：\n\n[source,kotlin]\n----\nprivate val log: Logger = LoggerFactory.getLogger(MainVerticle::class.java.name)\n\n// ......\n\nlog.info(\"Server start......\")\n----\n\n或者使用如下包：\n\n* `org.slf4j.Logger`\n* `org.slf4j.LoggerFactory`\n\n使用的时候可以使用可变参数\n\n[source,java]\n----\nlog.info(\"Server start on port {}......\", server.getInteger(\"port\", 8888))\n----\n\n== 总结\n\n`vert.x` 4 有很多改变，也加了很多新的特性，最大的改变莫过于\n`Core futurisation` 了。然而对于拥有协程的 `Kotlin`\n来说，有些地方编码方式没有太大改变。比较多的就是废弃了很多以前的\n`API`，比如 `JWT` 相关的，比如 `Web` 相关的 `API`\n都有部分被废弃，日志这里也有或多或少的改变。在 3.8.x\n的时候进行逐渐的过度，新项目使用 4.0.0 还是不错的。\n\n","fields":{"slug":"/articles/2020/01/31/1580462516035.html","birthTime":"2020-01-31T09:21:56.228Z","modifiedTime":"2020-01-31","year":2020},"document":{"title":"vert.x 4 日志配置"}},{"content":"= vert.x 4 使用插件完善你的项目\n:page-description: vert.x 一直是一个维护非常积极的项目，从诞生至今一直如此。现在他的 GitHub 上面 open 的 issues 也只有一百多个，保持积极处理的状态，而不是堆积一堆。并在在提出相关 issue 以后，都会积极的回应以及处理。\n:page-category: vert.x\n:page-image: https://img.hacpai.com/bing/20180117.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2020/02/01/1580550298345.html\n:page-created: 1580550298408\n:page-modified: 1581243385457\n:toc:\n\nvert.x 一直是一个维护非常积极的项目，从诞生至今一直如此。现在他的 GitHub\n上面 open 的 issues\n也只有一百多个，保持积极处理的状态，而不是堆积一堆。并在在提出相关 issue\n以后，都会积极的回应以及处理。\n\n在 vert.x 中，它的一大特点就是 `Verticle`。每一个 `Verticle`\n都有自己的功能，各司其职。并且，他们都可以是事件驱动的。今天我们的主要任务就是改善我们在官网上面生成下来的\nvert.x 项目，通过使用插件来让我们的项目运行简单、部署简单。\n\n我们主要用到如下两款插件：\n\n[arabic]\n. https://github.com/jponge/vertx-gradle-plugin[vertx-plugin]：这是官方提供的\nvert.x 的 gradle\n插件。*主要功能是提供完整的依赖管理，以及轻松整合https://github.com/johnrengelman/shadow[shadow]\n,https://docs.gradle.org/current/userguide/application_plugin.html[application]\n等构建工具*。\n. https://github.com/jponge/vertx-boot[vertx-boot]：这虽然不是官方提供的，但是开发者依旧是核心的官方人员。*主要功能是通过配置文件的方式来配置启动我们的`Verticle`，不需要在代码中写死或者命令行传参。*\n\n目前（2020-2-1）这两款插件一直在积极的维护中。通过这两款插件，能够极大的让我们的\nvert.x 应用更加灵活，更容易部署。\n\n当然，现在我开始向 Koltin 转型，所以以下的配置均是使用 Kotlin DSL\n进行书写的 Gradle 文件。\n\n所以主要分为三部分：\n\n[arabic]\n. 修改项目初始化的文件，将 Groovy DSL 的 Gradle 文件 修改为 Kolitn DSL\n的 Gradle 文件。\n. 整合 `vertx-plugin`\n. 整合 `vertx-boot`\n\n____\n2020.2.6 更新：`vert.x` 中移除了 deploy 的几个关于类加载的参数，参见\nhttps://github.com/eclipse-vertx/vert.x/issues/3274[ISSUE]。`vertx-boot`\n还没有对其更新后的参数进行完整性支持，所以如果使用 `vert.x 4` 版本， -\n对于 `Kotlin` 会造成 `NoSuchMethodError` 错误。 - 对于 `Java`\n会提示方法过期。\n____\n\n== 在这之前\n\n我们需要从 https://start.vertx.io/[vert.x starter]\n上面初始化我们的项目。目前提供的有如下四个版本：\n\n* 3.8.5\n* 3.7.1\n* 4.0.0-milestone4\n* 4.0.0-SNAPSHOT\n\n我并不是用在生产环境上的，所以大可以使用 4.0.0\n版本。而我不选择使用里程碑版本，使用快照版本即可。版本间的具体差别请自行谷歌。值得注意的是，3.x.x\n版本到 4.x.x 版本是大版本更新，有了很多的改变。\n\n同时选择使用 Kotlin 、Gradle 来创建项目，组件选择使用\nWeb，其他随意，高级选项可以选择 Jdk11。\n\n== 使用 Kotlin DSL 改造项目\n\n下载初始化后的项目以后，我们的 `build.gradle` 大概是这样子的：\n\n[source,groovy]\n----\nplugins {\n  id 'org.jetbrains.kotlin.jvm' version '1.3.20'\n  id 'application'\n  id 'com.github.johnrengelman.shadow' version '5.0.0'\n}\n\ngroup = 'cn.edu.gzmu.center'\nversion = '1.0.0-SNAPSHOT'\n\nrepositories {\n  maven { url 'http://maven.aliyun.com/nexus/content/groups/public/' }\n  maven {\n    url 'https://oss.sonatype.org/content/repositories/snapshots'\n    mavenContent {\n      snapshotsOnly()\n    }\n  }\n  mavenCentral()\n  jcenter()\n}\n\next {\n  kotlinVersion = '1.3.20'\n  vertxVersion = '4.0.0-SNAPSHOT'\n  junitJupiterEngineVersion = '5.4.0'\n}\n\napplication {\n  mainClassName = 'io.vertx.core.Launcher'\n}\n\n\ndef mainVerticleName = 'cn.edu.gzmu.center.MainVerticle'\ndef watchForChange = 'src/**/*'\ndef doOnChange = './gradlew classes'\n\ndependencies {\n  implementation \"io.vertx:vertx-web-client:$vertxVersion\"\n  implementation \"io.vertx:vertx-auth-jwt:$vertxVersion\"\n  implementation \"io.vertx:vertx-auth-oauth2:$vertxVersion\"\n  implementation \"io.vertx:vertx-unit:$vertxVersion\"\n  implementation \"io.vertx:vertx-web:$vertxVersion\"\n  implementation \"io.vertx:vertx-config:$vertxVersion\"\n  implementation \"io.vertx:vertx-config-yaml:$vertxVersion\"\n  implementation \"io.vertx:vertx-pg-client:$vertxVersion\"\n  implementation \"io.vertx:vertx-lang-kotlin-coroutines:$vertxVersion\"\n  implementation \"io.vertx:vertx-consul-client:$vertxVersion\"\n  implementation \"io.vertx:vertx-lang-kotlin:$vertxVersion\"\n\n  testImplementation \"io.vertx:vertx-junit5:$vertxVersion\"\n  testRuntimeOnly \"org.junit.jupiter:junit-jupiter-engine:$junitJupiterEngineVersion\"\n  testImplementation \"org.junit.jupiter:junit-jupiter-api:$junitJupiterEngineVersion\"\n}\n\ncompileKotlin {\n  kotlinOptions.jvmTarget = '1.8'\n}\n\ncompileTestKotlin {\n  kotlinOptions.jvmTarget = '1.8'\n}\n\n\nshadowJar {\n  archiveClassifier.set('fat')\n  manifest {\n    attributes 'Main-Verticle': mainVerticleName\n  }\n  mergeServiceFiles {\n    include 'META-INF/services/io.vertx.core.spi.VerticleFactory'\n  }\n}\n\ntest {\n  useJUnitPlatform()\n  testLogging {\n    events 'PASSED', 'FAILED', 'SKIPPED'\n  }\n}\n\nrun {\n  args = ['run', mainVerticleName, \"--redeploy=$watchForChange\", \"--launcher-class=$mainClassName\", \"--on-redeploy=$doOnChange\"]\n}\n----\n\n我们的第一步，将它改成我们 Kotlin DSL 写的 Gradle，我们一块一块的来。\n\n*在这之前要将文件`build.gradle` 重命名为 `build.gradle.kts`*。\n\n=== plugins\n\nplugin 部分很简单，只是单双引号的函数调用的问题：\n\n[source,kotlin]\n----\nplugins {\n  application\n  kotlin(\"jvm\") version \"1.3.20\"\n  id(\"com.github.johnrengelman.shadow\") version \"5.0.0\"\n}\ngroup = \"cn.edu.gzmu.center\"\nversion = \"1.0.0-SNAPSHOT\"\n----\n\n=== repository\n\nrepositories 也是如此，不过我们不用让他拉取快照了。\n\n[source,kotlin]\n----\nrepositories {\n  maven(\"http://maven.aliyun.com/nexus/content/groups/public/\")\n  maven(\"https://oss.sonatype.org/content/repositories/snapshots\")\n  mavenCentral()\n  jcenter()\n}\n----\n\n=== ext\n\n对于 Gradle 的 extra 部分较为复杂，在 Koltin DSL 中，设置与获取不太优雅\n\n[source,kotlin]\n----\next {\n    set(\"vertxVersion\", \"4.0.0-SNAPSHOT\")\n}\n//......\n// 使用\nimplementation \"io.vertx:vertx-auth-oauth2:${extra[\"vertxVersion\"]}\"\n----\n\n另外一种方式是通过委托\n\n[source,kotlin]\n----\nval vertxVersion by extra { \"4.0.0-SNAPSHOT\" }\n\n//......\n// 使用\nimplementation \"io.vertx:vertx-auth-oauth2:$vertxVersion\"\n----\n\n我们姑且使用第二种方式。\n\n[source,kotlin]\n----\n// 变量直接把 def 改成 val，单引号改成双引号就可以了。\nval mainVerticleName = \"cn.edu.gzmu.center.MainVerticle\"\n\nval kotlinVersion by extra { \"1.3.20\" }\nval vertxVersion by extra { \"4.0.0-SNAPSHOT\" }\n// 加一个日志进去\nval log4j2Version by extra { \"2.13.0\" }\nval junitJupiterEngineVersion by extra { \"5.4.0\" }\n----\n\n=== application\n\n这里就是单双引号的问题\n\n[source,kotlin]\n----\napplication {\n  mainClassName = \"io.vertx.core.Launcher\"\n}\n----\n\n=== dependencies\n\n这里就是单双引号的问题，同时要加上括号\n\n[source,kotlin]\n----\ndependencies {\n  implementation(\"io.vertx:vertx-web-client:$vertxVersion\")\n  implementation(\"io.vertx:vertx-auth-jwt:$vertxVersion\")\n  implementation(\"io.vertx:vertx-auth-oauth2:$vertxVersion\")\n  implementation(\"io.vertx:vertx-unit:$vertxVersion\")\n  implementation(\"io.vertx:vertx-web:$vertxVersion\")\n  implementation(\"io.vertx:vertx-config:$vertxVersion\")\n  implementation(\"io.vertx:vertx-config-yaml:$vertxVersion\")\n  implementation(\"io.vertx:vertx-pg-client:$vertxVersion\")\n  implementation(\"io.vertx:vertx-lang-kotlin-coroutines:$vertxVersion\")\n  implementation(\"io.vertx:vertx-consul-client:$vertxVersion\")\n  implementation(\"io.vertx:vertx-lang-kotlin:$vertxVersion\")\n  // 日志\n  implementation(\"org.apache.logging.log4j:log4j-slf4j18-impl:$log4j2Version\")\n\n  testImplementation(\"io.vertx:vertx-junit5:$vertxVersion\")\n  testRuntimeOnly(\"org.junit.jupiter:junit-jupiter-engine:$junitJupiterEngineVersion\")\n  testImplementation(\"org.junit.jupiter:junit-jupiter-api:$junitJupiterEngineVersion\")\n}\n----\n\n=== compileKotlin/compileTestKotlin\n\n这里需要引入一个类，同时使用委托。官网强制要求这样写的\n\n[source,kotlin]\n----\nimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile\n\n// ......\n\nval compileKotlin: KotlinCompile by tasks\n\ncompileKotlin.kotlinOptions {\n  jvmTarget = \"1.8\"\n}\nval compileTestKotlin: KotlinCompile by tasks\n\ncompileTestKotlin.kotlinOptions {\n  jvmTarget = \"1.8\"\n}\n----\n\n=== shadowJar\n\n这个就是一个 task 而已：\n\n[source,kotlin]\n----\ntasks.shadowJar {\n  archiveClassifier.set(\"fat\")\n  manifest {\n    // 需要使用 map\n    attributes(mapOf(\"Main-Verticle\" to mainVerticleName ))\n  }\n  mergeServiceFiles {\n    include(\"META-INF/services/io.vertx.core.spi.VerticleFactory\")\n  }\n}\n----\n\n=== test\n\n这里也是一个 task，需要引入一下 `Test` 的枚举：\n\n[source,kotlin]\n----\nimport org.gradle.api.tasks.testing.logging.TestLogEvent.*\n\n// ......\n\ntasks.withType<Test> {\n  useJUnitPlatform()\n  testLogging {\n    events = mutableSetOf(PASSED, FAILED, SKIPPED)\n  }\n}\n----\n\n=== run\n\n最后就是 run 了，这里我们换一个 task 的写法：\n\n[source,kotlin]\n----\ntasks {\n  // 前面的 def 变量我拿到这里了\n  val watchForChange = \"src/**/*\"\n  val doOnChange = \"./gradlew classes\"\n  // JavaExec 类型 task\n  \"run\"(JavaExec::class) {\n    // 运行参数\n    args(\"run\", mainVerticleName,\n      \"--redeploy=$watchForChange\",\n      \"--launcher-class=${application.mainClassName}\",\n      \"--on-redeploy=$doOnChange\")\n  }\n}\n----\n\n=== 最终结果\n\n最后我们得到的 `build.gradle.kts` 如下：\n\n[source,kotlin]\n----\nimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile\nimport org.gradle.api.tasks.testing.logging.TestLogEvent.*\n\nplugins {\n  application\n  kotlin(\"jvm\") version \"1.3.20\"\n  id(\"com.github.johnrengelman.shadow\") version \"5.0.0\"\n}\n\ngroup = \"cn.edu.gzmu.center\"\nversion = \"1.0.0-SNAPSHOT\"\n\nrepositories {\n  maven(\"http://maven.aliyun.com/nexus/content/groups/public/\")\n  maven(\"https://oss.sonatype.org/content/repositories/snapshots\")\n  mavenCentral()\n  jcenter()\n}\n\n\napplication {\n  mainClassName = \"io.vertx.core.Launcher\"\n}\nval mainVerticleName = \"cn.edu.gzmu.center.MainVerticle\"\n\nval kotlinVersion by extra { \"1.3.20\" }\nval vertxVersion by extra { \"4.0.0-SNAPSHOT\" }\nval log4j2Version by extra { \"2.13.0\" }\nval junitJupiterEngineVersion by extra { \"5.4.0\" }\n\ndependencies {\n  implementation(\"io.vertx:vertx-web-client:$vertxVersion\")\n  implementation(\"io.vertx:vertx-auth-jwt:$vertxVersion\")\n  implementation(\"io.vertx:vertx-auth-oauth2:$vertxVersion\")\n  implementation(\"io.vertx:vertx-unit:$vertxVersion\")\n  implementation(\"io.vertx:vertx-web:$vertxVersion\")\n  implementation(\"io.vertx:vertx-config:$vertxVersion\")\n  implementation(\"io.vertx:vertx-config-yaml:$vertxVersion\")\n  implementation(\"io.vertx:vertx-pg-client:$vertxVersion\")\n  implementation(\"io.vertx:vertx-lang-kotlin-coroutines:$vertxVersion\")\n  implementation(\"io.vertx:vertx-consul-client:$vertxVersion\")\n  implementation(\"io.vertx:vertx-lang-kotlin:$vertxVersion\")\n  implementation(\"org.apache.logging.log4j:log4j-slf4j18-impl:$log4j2Version\")\n\n  testImplementation(\"io.vertx:vertx-junit5:$vertxVersion\")\n  testRuntimeOnly(\"org.junit.jupiter:junit-jupiter-engine:$junitJupiterEngineVersion\")\n  testImplementation(\"org.junit.jupiter:junit-jupiter-api:$junitJupiterEngineVersion\")\n}\n\nval compileKotlin: KotlinCompile by tasks\n\ncompileKotlin.kotlinOptions {\n  jvmTarget = \"1.8\"\n}\nval compileTestKotlin: KotlinCompile by tasks\n\ncompileTestKotlin.kotlinOptions {\n  jvmTarget = \"1.8\"\n}\n\n\ntasks.shadowJar {\n  archiveClassifier.set(\"fat\")\n  manifest {\n    attributes(mapOf(\"Main-Verticle\" to mainVerticleName ))\n  }\n  mergeServiceFiles {\n    include(\"META-INF/services/io.vertx.core.spi.VerticleFactory\")\n  }\n}\n\ntasks.withType<Test> {\n  useJUnitPlatform()\n  testLogging {\n    events = mutableSetOf(PASSED, FAILED, SKIPPED)\n  }\n}\n\ntasks {\n  val watchForChange = \"src/**/*\"\n  val doOnChange = \"./gradlew classes\"\n  \"run\"(JavaExec::class) {\n    args(\"run\", mainVerticleName,\n      \"--redeploy=$watchForChange\",\n      \"--launcher-class=${application.mainClassName}\",\n      \"--on-redeploy=$doOnChange\")\n  }\n}\n----\n\nIDEA 中 `reimport`，一下，然后等待加载。运行原来的 `MainVerticle` 和\nGradle 的 shadow 命令试试能不能正常运行和打包。\n\n== 整合 vertx-plugin\n\n可以看到，我们的整个文件比较冗长，有差不多 90\n行的配置。并且很多地方特别难看，比如版本号那里。\n\n在 Spring boot 的 Gradle 项目里，我们所有的 Spring 相关的依赖都交给了\n`io.spring.dependency-management` 插件来管理。那么 vert.x\n应该也有这么一个东西，也就是\nhttps://github.com/jponge/vertx-gradle-plugin[vertx-plugin]。\n\n我们接下来将它整合到项目中去。\n\n=== plugins\n\n因为 vertx-plugin 已经为我们整合了多款插件，包括 `application`\n、`shadow`，所以我们删除他们\n\n[source,kotlin]\n----\nplugins {\n  kotlin(\"jvm\") version \"1.3.20\"\n  id(\"io.vertx.vertx-plugin\") version \"1.0.1\"\n}\n----\n\n=== 简单变化\n\n* repositories：不变\n* application：已经内置，直接移除\n* extra：\n** `val vertxVersion by extra { \"4.0.0-SNAPSHOT\" }` 移除，交给插件管理。\n** `val junitJupiterEngineVersion by extra { \"5.4.0\" }`\n移除，交给插件管理。\n* shadowJar：移除，交给插件管理\n* run：移除，交给插件管理\n\n=== dependencies\n\n移除版本号与单元测试依赖，插件自动添加\n\n[source,kotlin]\n----\ndependencies {\n  implementation(\"io.vertx:vertx-web-client\")\n  implementation(\"io.vertx:vertx-auth-jwt\")\n  implementation(\"io.vertx:vertx-auth-oauth2\")\n  implementation(\"io.vertx:vertx-unit\")\n  implementation(\"io.vertx:vertx-web\")\n  implementation(\"io.vertx:vertx-config\")\n  implementation(\"io.vertx:vertx-config-yaml\")\n  implementation(\"io.vertx:vertx-pg-client\")\n  implementation(\"io.vertx:vertx-lang-kotlin-coroutines\")\n  implementation(\"io.vertx:vertx-consul-client\")\n  implementation(\"io.vertx:vertx-lang-kotlin\")\n  implementation(\"org.apache.logging.log4j:log4j-slf4j18-impl:$log4j2Version\")\n  testImplementation(\"io.vertx:vertx-junit5\")\n}\n----\n\n=== 新增\n\n新增两个，一个是指定插件运行环境（可以省略），另外一个是插件配置\n\n[source,kotlin]\n----\ntasks.withType<KotlinCompile> {\n  kotlinOptions {\n    freeCompilerArgs = listOf(\"-Xjsr305=strict\")\n    jvmTarget = \"1.8\"\n  }\n}\n\nvertx {\n  // 运行的主要 Verticle\n  mainVerticle = \"cn.edu.gzmu.center.WebVerticle\"\n  // 运行的版本号，默认 3.8.3\n  vertxVersion = \"4.0.0-SNAPSHOT\"\n}\n----\n\n=== 最终结果\n\n最后我们得到新的 `build.gradle.kts`\n\n[source,kotlin]\n----\nimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile\nimport org.gradle.api.tasks.testing.logging.TestLogEvent.*\n\nplugins {\n  kotlin(\"jvm\") version \"1.3.20\"\n  id(\"io.vertx.vertx-plugin\") version \"1.0.1\"\n}\n\ngroup = \"cn.edu.gzmu.center\"\nversion = \"1.0.0-SNAPSHOT\"\n\nrepositories {\n  maven(\"http://maven.aliyun.com/nexus/content/groups/public/\")\n  maven(\"https://oss.sonatype.org/content/repositories/snapshots\")\n  mavenCentral()\n  jcenter()\n}\n\nval mainVerticleName = \"cn.edu.gzmu.center.MainVerticle\"\nval kotlinVersion by extra { \"1.3.20\" }\nval log4j2Version by extra { \"2.13.0\" }\n\ndependencies {\n  implementation(\"io.vertx:vertx-web-client\")\n  implementation(\"io.vertx:vertx-auth-jwt\")\n  implementation(\"io.vertx:vertx-auth-oauth2\")\n  implementation(\"io.vertx:vertx-unit\")\n  implementation(\"io.vertx:vertx-web\")\n  implementation(\"io.vertx:vertx-config\")\n  implementation(\"io.vertx:vertx-config-yaml\")\n  implementation(\"io.vertx:vertx-pg-client\")\n  implementation(\"io.vertx:vertx-lang-kotlin-coroutines\")\n  implementation(\"io.vertx:vertx-consul-client\")\n  implementation(\"io.vertx:vertx-lang-kotlin\")\n  implementation(\"org.apache.logging.log4j:log4j-slf4j18-impl:$log4j2Version\")\n  testImplementation(\"io.vertx:vertx-junit5\")\n}\n\nval compileKotlin: KotlinCompile by tasks\ncompileKotlin.kotlinOptions {\n  jvmTarget = \"1.8\"\n}\n\nval compileTestKotlin: KotlinCompile by tasks\ncompileTestKotlin.kotlinOptions {\n  jvmTarget = \"1.8\"\n}\n\ntasks.withType<Test> {\n  useJUnitPlatform()\n  testLogging {\n    events = mutableSetOf(PASSED, FAILED, SKIPPED)\n  }\n}\n\ntasks.withType<KotlinCompile> {\n  kotlinOptions {\n    freeCompilerArgs = listOf(\"-Xjsr305=strict\")\n    jvmTarget = \"1.8\"\n  }\n}\n\nvertx {\n  mainVerticle = \"cn.edu.gzmu.center.verticle.WebVerticle\"\n  vertxVersion = \"4.0.0-SNAPSHOT\"\n}\n----\n\n最终只有 65\n行代码。同时版本交给了插件来进行管理，方便省心。并且默认就配置了热部署和热\ndebug。\n\n自动添加了如下命令：\n\n* run\n* runShadow\n* startShadowScripts\n* vertxDebug\n* vertxRun\n\n我们可以直接使用 vertx 提供的 vertxRun 和 vertxDebug ，运行\n`./gradlew vertxRun` 即可热运行，实时更新。很棒！\n\n== 整合 vertx-boot\n\n在我们整合了 vertx-plugin 以后，已经很方便了。但是还是需要我们提供一个\n`mainVerticle`，然后在 `mainVerticle` 里面配置我们要启动的\n`Verticle`，还要在代码中配置其参数。所以是较为麻烦的，那么我们如何改变呢？这里就用到了\nhttps://github.com/jponge/vertx-boot[vertx-boot] 这个库。\n\n他最重要的作用就是提供了一个配置文件让我们来配置我们要启动的\n`Verticle`，可以怼他进行高级配置，比如 `Verticle`\n最大的特性就是直接可以集群部署。那么我们就可以直接指定他集群部署的实例数目；再比如我们可以指定它的启动配置等等。还支持高级配置，例如将它配置成\n`worker verticle`。\n\n所以接下来我们来引入这个库，只需要两步就可以完成：\n\n=== 添加依赖\n\n[source,kotlin]\n----\nval vertxBootVersion by extra { \"1.1.2\" }\n\n// ......\n\nimplementation(\"io.github.jponge:vertx-boot:$vertxBootVersion\")\n----\n\n=== 添加配置文件\n\n在 `resource` 下添加 `application.conf`\n\n[source,kotlin]\n----\nvertx-boot {\n  verticles {\n    web {\n      name = \"cn.edu.gzmu.center.verticle.WebVerticle\"\n      instance = 3 // 创建 3 个实例\n    }\n  }\n}\n----\n\n=== 运行\n\n我们修改 `build.gradle.kts` 的 `vertx` 函数：\n\n[source,kotlin]\n----\nvertx {\n  // 必须为这个\n  mainVerticle = \"io.github.jponge.vertx.boot.BootVerticle\"\n  vertxVersion = \"4.0.0-SNAPSHOT\"\n}\n----\n\n然后运行 `./gradlew vertxRun` 即可看到效果！\n\n=== IDEA 运行\n\n如果我们希望使用 IDEA 运行，也非常简单！创建一个 main 函数即可\n\n[source,kotlin]\n----\nfun main() {\n  Vertx.vertx().deployVerticle(\"io.github.jponge.vertx.boot.BootVerticle\")\n  // 或\n  // Vertx.vertx().deployVerticle(BootVerticle::class.java.name)\n}\n----\n\n然后运行这个 main 函数即可！\n\n== 其他\n\n初始化的项目默认使用的 Kotlin 是 `1.3.20`，我们可以将它改为最新的\n`1.3.61`。同时使用的是 JDK11,让他编译后的字节码是 `11`\n的（*注：这个特性只有在`1.3.30` 以后版本中可以使用*。）\n\n[source,kotlin]\n----\nval compileKotlin: KotlinCompile by tasks\ncompileKotlin.kotlinOptions {\n  // Target version of the generated JVM bytecode (1.6, 1.8, 9, 10, 11 or 12), default is 1.6\n  jvmTarget = \"11\"\n}\n\nval compileTestKotlin: KotlinCompile by tasks\ncompileTestKotlin.kotlinOptions {\n  // Target version of the generated JVM bytecode (1.6, 1.8, 9, 10, 11 or 12), default is 1.6\n  jvmTarget = \"11\"\n}\n----\n\n== 总结\n\nvert.x\n的国内生态真的不怎么样，用的人凤毛麟角，资料更是少之又少。但是他确实足够轻量，足够棒。在他上面可以实现很多东西，相比于\nSpring 的开发模式，vert.x\n更加锻炼一个人、更加考验一个人。并且在多个方面都让自己思维上有不少的进步。这两款插件国内都没有任何介绍，都是自己不断翻文档，一步一步的摸索找到的，然后啃文档弄上去。其中比较复杂的其实是\nGroovy DSL 转 Koltin DSL 的过程，大多资料用的都是\nGroovy，所以学习起来还是有点吃力的。不过 vert.x 真的棒，配合 Koltin\n协程简直爽翻了！\n\n","fields":{"slug":"/articles/2020/02/01/1580550298345.html","birthTime":"2020-02-01T09:44:58.408Z","modifiedTime":"2020-02-09","year":2020},"document":{"title":"vert.x 4 使用插件完善你的项目"}},{"content":"= kotlin 1.3.70 中 kotlinx.serialization 升级到 0.20.0\n:page-description: 月初的时候 Kotlin 1.3.70 正式发布 这不得不说是一个非常好的消息，带来的不仅是标准库新的功能，同时让我们写起来也更加舒服，现在对.gradle.kts 更加友好了.\n:page-category: kotlin\n:page-image: https://img.hacpai.com/bing/20180821.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2020/03/11/1583919686142.html\n:page-created: 1583919686317\n:page-modified: 1583919802128\n:toc:\n\n\n月初的时候 Kotlin 1.3.70\nhttps://blog.jetbrains.com/kotlin/2020/03/kotlin-1-3-70-released/[正式发布]了，这不得不说是一个非常好的消息，带来的不仅是标准库新的功能，同时让我们写起来也更加舒服，现在对\n`.gradle.kts`\n也更加友好了，具体可以查看它的发布文档。随之而然的，就是相应的生态进行更新了，不得不提的就是\n https://github.com/Kotlin/kotlinx.serialization[kotlinx.serialization]\n这个库了。他为我们序列化提供了极大的方便，而他与 1.3.70 对应的版本是\n https://github.com/Kotlin/kotlinx.serialization/blob/master/CHANGELOG.md#0200--2020-03-04[0.20.0]。\n\n如果你还在使用 v0.14.0 版本，可能会报以下错误：\n\n[source,bash]\n....\njava.lang.NoSuchMethodError: No direct method (ILkotlinx/serialization/SerializationConstructorMarker;)V in class Lcom/xxxx/common/core/Model; or its super classes (declaration of 'com.xxxx.common.core.Model' appears in /data/app/com.xxxx.demo-PV-n86-hzEl-eyc8UqbACQ==/base.apk!classes7.dex)\n10-11 15:30:10.048 E/AndroidRuntime(25760): at com.xxxx.reg.data.User.(Unknown Source:9)\n10-11 15:30:10.048 E/AndroidRuntime(25760): at com.xxxx.reg.data.User$$serializer.deserialize(Unknown Source:624)\n10-11 15:30:10.048 E/AndroidRuntime(25760): at com.xxxx.reg.data.User$$serializer.deserialize(User.kt:17)\n10-11 15:30:10.048 E/AndroidRuntime(25760): at kotlinx.serialization.json.internal.PolymorphicKt.decodeSerializableValuePolymorphic(Polymorphic.kt:33)\n....\n\n升级到 v0.20.0 就可以了。当然在这个版本中发生了不小的改变，将它过期的\napi 总结一下。\n\n== Json.nonstric\n\n默认情况下，他开启 `nonstric` 模式的，也就是解析的 `key`\n必须完全符合实体类的要求，不能够多出其他的字段。但是很多时候我们不希望这样，在以前的版本中是这样配置的：\n\n[source,kotlin]\n----\nprivate val json = Json(JsonConfiguration(strictMode = false))\n----\n\n但是在 0.20.0 中，已经不能够这样配置了，参见 https://github.com/Kotlin/kotlinx.serialization/blob/master/runtime/commonMain/src/kotlinx/serialization/json/JsonConfiguration.kt#L112[github]\n\n* `strictMode` 分割为 `ignoreUnknownKeys`、`isLenient`和\n`serializeSpecialFloatingPointValues`，\n* `unquoted` 重命名为 `unquotedPrint`\n\n在新的版本中我们需要如下使用：\n\n[source,kotlin]\n----\nprivate val json = Json(\n  JsonConfiguration.Default.copy(\n    ignoreUnknownKeys = true,\n    isLenient = true,\n    serializeSpecialFloatingPointValues = true,\n    useArrayPolymorphism = true\n  )\n)\n----\n\n== SerialDescriptor\n\n我们在对某些数据结构进行序列化和反序列化的时候应该写过如下的代码：\n\n[source,kotlin]\n----\n@Serializer(forClass = LocalDateTime::class)\nclass LocalDateTimeSerializer : KSerializer<LocalDateTime> {\n\n  override val descriptor: SerialDescriptor = StringDescriptor\n  private val formatter: DateTimeFormatter =\n    DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\").withLocale(Locale.SIMPLIFIED_CHINESE)\n\n  override fun deserialize(decoder: Decoder): LocalDateTime =\n    LocalDateTime.parse(decoder.decodeString(), formatter)\n\n  override fun serialize(encoder: Encoder, obj: LocalDateTime) {\n    encoder.encodeString(formatter.format(obj))\n  }\n}\n----\n\n通过实现 `serialize` 和 `descriptor`\n方法就可以完成自定义的序列化。但是在 0.20.0 版本中 `StringDescriptor`\n被标记为过时了，相应的以下基本数据类型的都被标记了过时：\n\n* `IntDescriptor`\n* `UnitDescriptor`\n* `BooleanDescriptor`\n* `ByteDescriptor`\n* `ShortDescriptor`\n* `LongDescriptor`\n* `FloatDescriptor`\n* `DoubleDescriptor`\n* `CharDescriptor`\n* `StringDescriptor`\n\n源码中的注解如下：\n\n[source,kotlin]\n----\n@Deprecated(message = message,\n    replaceWith = ReplaceWith(\"PrimitiveDescriptor(\\\"yourSerializerUniqueName\\\", PrimitiveKind.STRING)\"))\nobject StringDescriptor : Migration()\n----\n\n我们需要使用 `PrimitiveDescriptor`\n来进行替代，参考 https://github.com/Kotlin/kotlinx.serialization/blob/146a0d08ed87a97cf5435a89fcafd3aa639c106e/runtime/commonMain/src/kotlinx/serialization/SerialDescriptorBuilder.kt#L60[github]：\n\n[source,kotlin]\n----\noverride val descriptor: SerialDescriptor = PrimitiveDescriptor(\"LocalDateTimeTz\", PrimitiveKind.STRING)\n----\n\n需要注意的是这个字符串的 `key`\n需要是唯一的。不然的话可能会造成他无法找到等问题。\n\n== bultins package\n\n另外，一些功能已移至 bultins package 包。\n\n例如：\n\n[source,kotlin]\n----\nimport kotlinx.serialization.list\nUser.serializer().list\n// 替换为\nimport kotlinx.serialization.builtins.list\nUser.serializer().list\n----\n\n[source,kotlin]\n----\nimport kotlinx.serialization.internal.StringSerializer\nStringSerializer()\n// 替换为\nimport kotlinx.serialization.builtins.serializer\nString.serializer()\n----\n\n","fields":{"slug":"/articles/2020/03/11/1583919686142.html","birthTime":"2020-03-11T09:41:26.317Z","modifiedTime":"2020-03-11","year":2020},"document":{"title":"kotlin 1.3.70 中 kotlinx.serialization 升级到 0.20.0"}},{"content":"= Spring Reactive Mongodb Jpa Auditing 审计\n:page-description: 相信很多人都知道 Jpa 的一个非常强大的功能：审计。我们就来聊聊他。\n:page-category: spring\n:page-image: https://img.hacpai.com/bing/20180313.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2020/04/09/1586446987932.html\n:page-created: 1586446988036\n:page-modified: 1586446988036\n:toc:\n\n相信很多人都知道 Jpa 的一个非常强大的功能：审计。\n\n简单地说就是你提供一些审计的元数据，Jpa\n会给你自动根据这些元数据去填充你相应的信息。在它的实现中，其元数据就是我们的注解或者接口。通过注解或者接口，Jpa\n可以更好的自动填充你的实体类信息。\n\n举个栗子：\n\n[source,java]\n----\nclass Customer {\n\n  /**\n   * 创建时间\n   */\n  @CreatedDate\n  private LocalDateTime createTime = LocalDateTime.now();\n\n  /**\n   * 创建用户\n   */\n  @CreatedBy\n  private String createUser;\n\n  /**\n   * 最后修改时间\n   */\n  @LastModifiedDate\n  private LocalDateTime modifyTime = LocalDateTime.now();\n\n  /**\n   * 最后修改用户\n   */\n  @LastModifiedBy\n  private String modifyUser;\n\n  // ...... 其他字段\n}\n----\n\n这四个字段如果在每个实体类创建、修改的时候手动设置无疑是非常麻烦的事情。但是我们通过上面的注解就可以实现\nJpa 的审计，让他帮我们去填充。\n\n== 一般情况\n\n在传统模式中，配合 Spring Security\n去实现这一个过程是很简单的，只需要如下几步：\n\n[arabic]\n. 为实体类添加审计注解\n[arabic]\n.. `@CreatedDate` 创建时间\n.. `@CreatedBy` 创建用户\n.. `@LastModifiedDate` 最后修改时间\n.. `@LastModifiedBy` 最后修改用户\n. 启动/配置类添加 `@EnableJpaAuditing` 开启审计\n. 实体类添加 `@EntityListeners(AuditingEntityListener.class)`\n注解（在后面的版本中可以省略）\n\n这样就可以自动审计了，如果是自定义用户实体了的，需要自定义一下获取用户的方式，例如：\n\n[source,java]\n----\n@Configuration\npublic class UserAuditorHandle implements AuditorAware<String> {\n    @NotNull\n    @Override\n    public Optional<String> getCurrentAuditor() {\n        return Optional.ofNullable(SecurityContextHolder.getContext())\n                .map(SecurityContext::getAuthentication)\n                .map(Principal::getName);\n    }\n}\n----\n\n但是这是在传统模式下，使用 servlet 的阻塞式情况下去完成的。\n\n== Reactive Mongodb Auditing\n\n____\n使用依赖：\n\n....\norg.springframework.boot:spring-boot-starter-data-mongodb-reactive\n....\n____\n\n最近在实践响应式微服务的时候就发现代码审计是存在问题的，在 Reactive\n的环境下，需要下面几步：\n\n[arabic]\n. 同传统模式，为实体类添加审计注解\n. 启动类添加 `@EnableMongoAuditing` 开启审计\n\n这样我们开启了部分的代码审计，这种模式下只会自动添加 _时间_\n类型的代码审计。\n\n但是我们如果需要用户的审计如何使用呢？`AuditorAware` 是不存在\n`Spring Security Reactive` 版本的。对于时间的审计，它存在一个\n`ReactiveAuditingEntityCallback` 进行审计。官方也在 jira 中提出提出了\nhttps://jira.spring.io/browse/DATACMNS-1231[Auditing should support\nreactive security\ncontext]，但是至今为止快三年了，都没有去做。不过他倒是给出了一个解决方案，使用\n`EntityCallbacks` 来完成相应的 Reactive 审计。\n\n官网中给出了三个 `EntityCallbacks`：\n\n____\n注： Jpa 在执行任何操作之前所有的实体类都会转化为 `org.bson.Document`\n____\n\n[width=\"100%\",cols=\"<19%,<33%,<33%,<15%\",options=\"header\",]\n|===\n|Callback |Method |Description |Order\n|Reactive/BeforeConvertCallback\n|`onBeforeConvert(T entity, String collection)`\n|在实体类转化为`org.bson.Document` 之前进行调用。\n|`Ordered.LOWEST_PRECEDENCE`\n\n|Reactive/AuditingEntityCallback\n|`onBeforeConvert(Object entity, String collection)` |标记审计的实体是\n_创建_ 还是 _修改_ |100\n\n|Reactive/BeforeSaveCallback\n|`onBeforeSave(T entity, org.bson.Document target, String collection)`\n|在保存实体之前调用。可以修改要持久化的目标\n`Document`，其中包含所有映射的实体信息。 |`Ordered.LOWEST_PRECED`\n|===\n\n其中第一、三个为接口，第二个是一个类，就是它来完成时间的审计的。如何选择呢？总结了一下他们的适用场景\n\n[width=\"100%\",cols=\"<35%,<65%\",options=\"header\",]\n|===\n|Callback |适用场景\n|Reactive/BeforeConvertCallback\n|所有的操作之前都会调用。可以对目标进行统一处理，只能获取到转化前的实体类。\n\n|Reactive/AuditingEntityCallback\n|他是第一种的接口的一个实现，在没有明确的字段能够识别当前实体是新建还是修改的情况下，可以参照这个实现类进行区分和修改。\n\n|Reactive/BeforeSaveCallback |只有使用 `save`\n方法之前会调用到这个方法，同时他可以对转化后的 `Document` 进行操作。\n|===\n\n很明显，我们需要填充用户的审计信息但是不需要操作\n`Document`，那么就是需要统一处理，同时我可以根据 id\n去判断是否是新增的实体，所以就直接使用第一个了。\n\nKotlin 版本\n\n[source,kotlin]\n----\n  @Bean\n  @Order(99)    // 可选\n  // 因为强转了会有警告，抑制一下，又因为实体类是 Java 的，他会要求我使用 = 访问属性\n  // 但是 Java 代码是不可以的，所以同样抑制下\n  @Suppress(\"UsePropertyAccessSyntax\", \"USELESS_CAST\")\n  fun userAuditingHandler() =\n    ReactiveBeforeConvertCallback { entity: Any, _: String ->\n      ReactiveSecurityContextHolder.getContext()\n        .map { context -> context.authentication.principal }\n        // 这里根据你的授权机制去修改，强转为对应的授权对象\n        .map { it as Jwt }\n        .map { it.claims[\"user_id\"].toString() }\n        .map {\n          val id = (entity as BaseEntity).getId()\n          if (id == null) entity.setCreateUser(it)\n          else entity.setModifyUser(it)\n          // 一定要强转回去，kotlin 里面 as 以后，下面代码的所有类型就全改变了\n          // 不然子类实体的字段会丢失\n          entity as Any\n        }.defaultIfEmpty(entity)\n      }\n----\n\nJava 版本\n\n[source,java]\n----\n@Bean\npublic ReactiveBeforeConvertCallback<Objects> userAuditingHandler() {\n    return (entity, _) ->\n        ReactiveSecurityContextHolder.getContext()\n            .map(securityContext -> {\n                // 这里根据你的授权机制去修改，强转为对应的授权对象并获取用户信息\n                Jwt jwt = (Jwt) securityContext.getAuthentication().getPrincipal();\n                return jwt.getClaims().get(\"user_id\").toString();\n            })\n            .map(userId -> {\n                String id = ((BaseEntity) entity).getId();\n                if (id == null) {\n                    ((BaseEntity) entity).setCreateUser(id);\n                } else {\n                    ((BaseEntity) entity).setModifyUser(id);\n                }\n                return entity;\n            }).defaultIfEmpty(entity);\n}\n----\n\n*值得注意的是，对于 `ReactiveBeforeConvertCallback`，其 `entity`\n的类型是什么，他就会拦截什么类型的实体*。这里是\n`Any/Object`，那么他就会拦截所有的实体。同理\n`Reactive/BeforeSaveCallback` 接口也是一样的。\n\n== 总结\n\n代码审计能够帮我节省不少麻烦事儿的。这次看了他审计的一些源码，其实一开始准备使用第二种他提供的实例方式来实现的，但是发现有几个难点。\n\n`ReactiveAuditingEntityCallback` 中核心就是 `auditingHandlerFactory`\n里面的 `IsNewAwareAuditingHandler`，但是他需要一个 `PersistentEntities`\n传入，他需要一个 `MappingContext`\n上下文对象去创建。这就很麻烦了（我不会告诉你我找不到这个上下文怎么用。。。），所以在自己能够区分是新增还是编辑的情况下大可以自己实现一个简单版本的。\n\n","fields":{"slug":"/articles/2020/04/09/1586446987932.html","birthTime":"2020-04-09T15:43:08.036Z","modifiedTime":"2020-04-09","year":2020},"document":{"title":"Spring Reactive Mongodb Jpa Auditing 审计"}},{"content":"= Spring Reactive Mongodb Jpa Repository 总结\n:page-description: 上一篇中提到了 Reactive data Jpa 的一个强大功能：审计。而这篇文章则是对于 Repository implement 使用方式的总结。\n:page-category: spring\n:page-image: https://img.hacpai.com/bing/20190430.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2020/04/13/1586760856276.html\n:page-created: 1586760856338\n:page-modified: 1586761258962\n:toc:\n\n上一篇中提到了 `Reactive data Jpa`\n的一个强大功能：审计。而这篇文章则是对于 Repository implement\n使用方式的总结。\n\n在我们使用 `Jpa` 的时候，有如下几种个人觉得比较规范的方式来进行使用：\n\n[arabic]\n. https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods[从方法名称派生查询]\n. https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.at-query[使用\n`@Query` 注解自定义]\n. 对于复杂的数据查询，可以使用\nhttps://docs.spring.io/spring-data/jpa/docs/current/reference/html/#query-by-example[QueryByExampleExecutor]\n接口\n. 对于复杂的数据操作，我们有\nhttps://docs.spring.io/spring-data/jpa/docs/current/reference/html/#specifications[JpaSpecificationExecutor]\n接口，也可以使用\nhttps://docs.spring.io/spring-data/jpa/docs/current/reference/html/#core.extensions[`Querydsl`\n扩展]\n. 我们如果需要职责分离，希望将数据库的操作 *完全* 封装到 Repository\n里面，我们可以 https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.single-repository-behavior[自定义某个\nRepository 的复杂操作]\n. 当然，也可以自定义一个 https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.customize-base-repository[类似于\nJpaRepository 的 BaseRepository]\n. 直接使用 `EntityManager`\n\n有了以上这些方式就完全够我们大部分需求了。但是为什么还会有这篇文章呢？原因和上篇文章一样，因为\n`Reactive`。\n\n对于 Reactove Mongo\n来说，传统的七点都是可以继续使用的，他们实现的方式和以前都是大同小异。我们可以直接使用\n`ReactiveMongoOperations` 来替代 `EntityManager` 进行数据库的。\n\n== 从方法名派生查询\n\n这个是最为常用的一种，也是最为方便的使用方式。\n\n[source,kotlin]\n----\n  /**\n   * 通过 [ids] 查询\n   */\n  fun findAllByIdContaining(ids: List<String>): Flux<E>\n\n  /**\n   * 查询 isEnable 字段为 true 的数量\n   */\n  fun countAllByIsEnableTrue(): Mono<Long>\n----\n\n唯一不同的就是返回值了，同时需要注意的是，在 Reactive\n的环境中，他是没有办法获取到分页的对象的，文档中明确指出：\n\n____\nThe `Page` return type (as in `Mono`) is not supported by reactive\nrepositories.\n\n在 Reactive 仓库中 Page 类型的返回值（作为 Mono）是不被支持的。\n____\n\n所以我们写出来的分页方法如下：\n\n[source,kotlin]\n----\n/**\n * 分页查询，名称不能直接写 findAll，否则会报错，必须至少一个条件\n */\nfun findAllByIsEnableIsTrue(pageable: Pageable): Flux<E>\n----\n\n那么分页怎么写呢？Kotlin 里面自然就可以用协程了\n\n[source,kotlin]\n----\n  override suspend fun page(pageable: Pageable): Page<E> {\n    val content = repository.findAllByIsEnableIsTrue(pageable).collectList().awaitSingle()\n    val count = repository.countAllByIsEnableTrue().awaitSingle()\n    return PageImpl(content, pageable, count)\n  }\n----\n\n当然你也可以用 `mono` 将它包裹起来，返回值就变成了 `Mono<Page<E>>`\n了。如果不使用协程，需要操作两个不同类型的 Mono，我们可以使用 `Mono.zip`\n方法来完成\n\n[source,kotlin]\n----\n  override suspend fun page(pageable: Pageable, entity: E): Mono<Page<E>> =\n    Mono.zip(repository.findAllByIsEnableIsTrue(pageable).collectList(), repository.countAllByIsEnableTrue()) { content, count ->\n      PageImpl(content, pageable, count)\n    }\n----\n\n使用起来和以前方式还是有些许区别。\n\n== 使用 `@Query` 自定义\n\n这种就没啥可以说的了\n\n[source,kotlin]\n----\n  /**\n   * Get menu by [roles].\n   * If one of the lines contains one of the [roles], will match.\n   */\n  @Query(\"{ 'roles': { '\\$in': ?0 }}\")\n  fun searchByRoles(roles: List<Long>): Flux<Route>\n----\n\n当然，在以前，我们可以在里面写更新、创建的操作，但是在 Mongo\n中是不可以的。\n\n== 使用 `ReactiveQueryByExampleExecutor` 接口\n\n我们只需要构建一个 `Example` 过去就可以查询了\n\n[source,kotlin]\n----\nval all: Flux<User> = repository.findAll(Example.of(entity));\n----\n\n但是他却没有提供分页的接口，例如我想要的\n\n[source,kotlin]\n----\nfun findAll(example: Example<E>, pageable: Pageable): FLux<E>\n----\n\n他就没有，后面会说咋自定义。\n\n当然还有一种用法，对于动态条件匹配，我们可以预先准备一个自定义的匹配器\nhttps://docs.spring.io/spring-data/mongodb/docs/current/reference/html/#query-by-example.matchers[ExampleMatcher]：\n\n[source,kotlin]\n----\n  private fun getPageMatcher() = ExampleMatcher.matching()\n      // 以下字段模糊匹配\n      .withMatcher(\"name\", ExampleMatcher.GenericPropertyMatcher().contains())\n      .withMatcher(\"spell\", ExampleMatcher.GenericPropertyMatcher().contains())\n      .withMatcher(\"remark\", ExampleMatcher.GenericPropertyMatcher().contains())\n      // 忽略为 null 字段\n      .withIgnoreNullValues()\n----\n\n也是可以满足我们部分需求了的。\n\n== 使用 ReactiveQuerydslPredicateExecutor\n\nReactive 是没有 `Specification` 的，所以只能是Spring 是整合的\nhttps://http://www.querydsl.com%22[Querydsl] ，值得注意的是，这个是在\n*2.2* 版本以后才引入的支持，在之前的版本，是不支持 Reactive\n的。所以需要引入以下它的依赖：\n\n[source,markdown]\n----\ngroupId：com.querydsl\nartifactId：querydsl-apt\n----\n\n它的使用流程先生成 `@Entity` 注解下的实体类，编译以后会生成 `Q`\n开头的实体类，通过这个实体类进行 DSL 操作。不过他目前只支持 maven\n插件以及 gradle 5 以下的插件注解生成，见\nhttps://github.com/ewerk/gradle-plugins[github] ：\n\n[cols=\",,,\",options=\"header\",]\n|===\n|Plugin |≥ 2.1 |≥ 3.3 |≥ 5.0\n|annotation-processor-plugin |≤1.0.3 |≥1.0.4 |ø\n|artifactory-deb-publish-plugin |≤1.0.1 |≥1.0.2 |ø\n|auto-value-plugin |≤1.0.7 |≥1.0.8 |ø\n|dagger-plugin |≤1.0.7 |≥1.0.8 |ø\n|integration-test-plugin |≤1.0.8 |≥1.0.9 |ø\n|jaxb2-plugin |≤1.0.2 |≥1.0.3 |ø\n|querydsl-plugin |≤1.0.7 |≥1.0.8 |`INCUBATING`\n|===\n\n对于 Gradle 大于 5.0\n的是正在开发中的，所以目前是无法进行注解生成的，不过\nhttps://stackoverflow.com/questions/54134455/java-11-querydsl-4-gradle-5-springboot-2-1-not-generating-qclasses[stackoverflow]\n上面有些许解决办法，但我尚未尝试。``曲线救国'' 的方式就是使用 IDEA\n的注解处理器，如果是 Kotlin 的就可以使用 Kapt\n注解处理器。当然这里就不做演示了，具体可以参见\nhttp://www.querydsl.com/static/querydsl/latest/reference/html/[官方文档]。\n\n== 自定义某个 Repository 的复杂操作\n\n这种方式个人觉得是不太好用的一种方式，有以下原因\n\n[arabic]\n. 指定定义一个 Repository 的复杂操作\n. 需要实现那个 Repository\n接口，那么就必须实现它的所有方法，就会失去根据名称派生查询优势\n\n这种比较鸡肋，比如有几个 Repository 具有同一个方法，但是其他的\nRepository\n又没有，同时这个方法又没法自动推断或者是更新、删除等操作，这个时候才会抽出一个部分共用的的\nRepository 来实现。但是有个问题就是几个 Repsitory\n对应的实体都是不一样的，那么抽出来的实体只能是 BaseEntity\n的子类，也就是公共实体，而 BaseEntity 又是所有 Entity\n的父类，那就是通用的了，那我为啥还要抽出来=-=\n\n所以个人想到的只有一个场景，你有一个 Repsoitory，但是这个 Repsoitory\n的部分方法需要 Jpa\n通过方法名称派生查询，部分方法需要自己去实现，那么就可以单独写一个去用了。\n\n这个实现起来很简单\n\n[source,kotlin]\n----\ninterface CustomizedUserRepository {\n  fun someCustomMethod(User user);\n}\n----\n\n[source,kotlin]\n----\nclass CustomizedUserRepositoryImpl implements CustomizedUserRepository {\n\n  fun someCustomMethod(User user) {\n    // Your custom implementation\n  }\n}\n----\n\n____\n*注意：实现类必须以 `Impl`\n结尾*，如果不是需要修改注解参数 `@EnableReactiveMongoRepositories(repositoryImplementationPostfix = \"Impl\")`\n，默认是 `Impl`\n____\n\n== 类似于 JpaRepository 的 BaseRepository\n\n这种方式个人觉得非常常用，在我的项目中我写了两个 `BaseRepository`。\n\n* `ExpandRepository`：用来自定义各种实现的方法，继承\n`ReactiveMongoRepository`\n* `BaseRepository`： 用来通过方法名派生查询的方法，继承\n`ExpandRepository`和 `ReactiveQuerydslPredicateExecutor`\n\n这样就能够很方便的定义许多操作。来说说他们的实现吧\n\n=== `ExpandRepository`\n\n接口很简单，这里我们写一个他 `ReactiveQueryByExampleExecutor`\n没有提供的方法，也就是分页\n\n[source,kotlin]\n----\n@NoRepositoryBean\ninterface ExpandRepository<E: BaseEntity<E>>: ReactiveMongoRepository<E, String> {\n\n  /**\n   * Find all by [example] and [pageable].\n   */\n  fun findAll(example: Example<E>, pageable: Pageable): Flux<E>\n\n}\n----\n\n然后定一个实现类\n\n[source,kotlin]\n----\nclass ExpandRepositoryImpl<E : BaseEntity<E>>(\n    private val entityInformation: MongoEntityInformation<E, String>,\n    private val mongoOperations: ReactiveMongoOperations\n) : SimpleReactiveMongoRepository<E, String>(entityInformation, mongoOperations), ExpandRepository<E> {\n\n  override fun findAll(example: Example<E>, pageable: Pageable): Flux<E> =\n      mongoOperations.find(\n          Query(Criteria().alike(example))\n              .collation(entityInformation.collation)\n              .with(pageable),\n          example.probeType,\n          entityInformation.collectionName\n      )\n\n}\n----\n\n最后修改注解就可以了\n\n[source,kotlin]\n----\n@EnableReactiveMongoRepositories(repositoryBaseClass = ExpandRepositoryImpl::class)\n----\n\n=== `BaseRepository`\n\n这就是一个通过方法名或者 `@Query` 派生的接口\n\n[source,kotlin]\n----\n@NoRepositoryBean\ninterface BaseRepository<E : BaseEntity<E>> : ExpandRepository<E>, ReactiveQuerydslPredicateExecutor<E> {\n\n  fun findAllByIdContaining(ids: List<String>): Flux<E>\n\n  fun countAllByIsEnableTrue(): Mono<Long>\n\n}\n----\n\n=== 高级用法\n\n当然，还有一个高级用法，就是我们可以自定义它的工厂以及工厂 Bean\n\n[source,kotlin]\n----\n/**\n * This bean will be injected in [cn.edu.gzmu.university.common.MongodbConfig].\n * It will give a [cn.edu.gzmu.university.common.base.ExpandRepository] implement and\n * a [ExpandMongoRepositoryFactory] to create repository.\n *\n * @author <a href=\"https://echocow.cn\">EchoCow</a>\n * @date 2020/4/12 下午7:14\n */\nclass ExpandRepositoryFactoryBean<T : Repository<E, String>, E : BaseEntity<E>>(\n    repositoryInterface: Class<out T>\n) : ReactiveMongoRepositoryFactoryBean<T, E, String>(repositoryInterface) {\n\n  /**\n   * Get customize factory instance.\n   */\n  override fun getFactoryInstance(operations: ReactiveMongoOperations): RepositoryFactorySupport =\n      ExpandMongoRepositoryFactory<E>(operations)\n\n  @Suppress(\"UNCHECKED_CAST\")\n  private class ExpandMongoRepositoryFactory<E : BaseEntity<E>>(\n      private val mongoOperations: ReactiveMongoOperations\n  ) : ReactiveMongoRepositoryFactory(mongoOperations) {\n\n    /**\n     * Get our customize repository base class.\n     */\n    override fun getRepositoryBaseClass(metadata: RepositoryMetadata): Class<*> = ExpandRepositoryImpl::class.java\n\n    /**\n     * Get target repository.\n     */\n    override fun getTargetRepository(information: RepositoryInformation): Any {\n      val entityInformation: MongoEntityInformation<*, Serializable> = getEntityInformation(information.domainType)\n      return ExpandRepositoryImpl(entityInformation as MongoEntityInformation<E, String>, mongoOperations)\n    }\n\n  }\n}\n----\n\n当然，不要忘记添加如下注解：\n\n[source,kotlin]\n----\n@EnableReactiveMongoRepositories(repositoryFactoryBeanClass = ExpandRepositoryFactoryBean::class)\n----\n\n这个是最简单的一个实现。`ExpandRepositoryFactoryBean` 会注入一个\n`ExpandMongoRepositoryFactory` ，然后他就可以生产我们的 repository base\nclass 来完成自定义 repository\n实现。为什么需要这个高级用法呢？一个最明显的栗子就是在它的父类\n`ReactiveMongoRepositoryFactoryBean` 中，有一个创建工厂的方法：\n\n[source,java]\n----\n@Override\nprotected RepositoryFactorySupport createRepositoryFactory() {\n\n    RepositoryFactorySupport factory = getFactoryInstance(operations);\n\n    if (createIndexesForQueryMethods) {\n        factory.addQueryCreationListener(new IndexEnsuringQueryCreationListener(\n            collectionName -> IndexOperationsAdapter.blocking(operations.indexOps(collectionName))));\n    }\n\n    return factory;\n}\n----\n\n`createRepositoryFactory` 是用来创建工厂的，他在这里加入了一个\n`IndexEnsuringQueryCreationListener`，他会去检查\n`RepositoryQuery`，并且为它的属性创建索引。那么我们自然可以模仿他去创建一些其他的监听器并作出一些实现。再比如我们可以通过\n`addRepositoryProxyPostProcessor` 添加\n`RepositoryProxyPostProcessor`，在进行代理之前操作工厂。\n\n同时我们也可以通过工厂的 `getQueryLookupStrategy`\n方法自定义工厂的查询查找策略，默认是 `MongoQueryLookupStrategy`。\n\n[source,java]\n----\n    @Override\n    protected Optional<QueryLookupStrategy> getQueryLookupStrategy(@Nullable Key key,\n            QueryMethodEvaluationContextProvider evaluationContextProvider) {\n        return Optional.of(new MongoQueryLookupStrategy(operations, evaluationContextProvider, mappingContext));\n    }\n----\n\n这些都是一些可以进行自定义的高级操作。在某些场合还是非常有用的。\n\n== 总结\n\nJpa 实在是太过方便，除了上面几种我们还可以直接注入\n`ReactiveMongoOperations`、`ReactiveMongoTemplate`\n来直接操作数据库也是十分方便，事实上 Repository\n他们的底层其实也就是这两样。总的来说 Jpa\n给我们提供太多的方便，对于许多地方的自定义配置都留了很大很大的空间。个人喜欢\nJpa 比喜欢 Mybatis 好多了！\n\n","fields":{"slug":"/articles/2020/04/13/1586760856276.html","birthTime":"2020-04-13T06:54:16.338Z","modifiedTime":"2020-04-13","year":2020},"document":{"title":"Spring Reactive Mongodb Jpa Repository 总结"}},{"content":"= Phpstorm + Docker / Docker Compose + xdebug 环境搭建\n:page-description: Phpstorm + Docker / Docker Compose + xdebug 环境搭建\n:page-category: 归档\n:page-image: https://resources.echocow.cn/file/2020/8/1/image-20200731211328720.png?imageView2/1/w/1280/h/720/interlace/1/q/100\n:page-href: /articles/2020/08/01/1596268325013.html\n:page-created: 1596268325192\n:page-modified: 1596268325192\n:toc:\n\n刚换笔记本，不想搞太多环境，什么 Apache、Mysql 啥的，想全部交给 Docker\n管理，复杂一点的直接 Docker compose\n编排一下就好了。乐得清闲，升级又容易，php\n的环境也不例外，所以将它搭建一下：\n\n== 环境准备\n\n* 开发工具：Phpstorm\n* 必备环境：Docker 或 Docker Compose\n** https://docs.docker.com/docker-for-windows/install/[Windows 安装]\n** https://docs.docker.com/docker-for-mac/install/[Mac 安装]\n\n不需要安装 php，不需要安装 apach，也不需要配置 xdebug，啥都不用，安排。\n\n== 开始\n\n创建一个 phpstrom 空项目，然后创建一个 `index.php` 文件\n\n[source,php]\n----\n<?php\n$world = \"World\";\necho \"hello,\", $world;\n----\n\n== Docker 方式\n\n两种方式拉去镜像\n\n* 去 https://hub.docker.com/[Docker Hub] 搜索 phpstorm 下的\nhttps://hub.docker.com/u/phpstorm/[php 镜像]\n* 去 https://github.com/JetBrains/phpstorm-docker-images[Phpstorm\nGithub] 查找相应版本的 Docker 镜像\n\n主要提供两种类型的镜像（以 7.4 php 为例，*注意：7.4 版本官方没有传到\nDocker Hub，可以使用 7.3 的*）：\n\n* `php-74-cli-xdebug-29`：主要提供基础的 `php 7.4` + `xdebug 2.9` +\n`mysqli` 环境，不提供web环境与端口暴露。\n* `php-74-apache-xdebug-29`：主要提供 `php 7.4` + `xdebug 2.9` +\n`mysqli`+ `apache2` 环境，同时安装了 `php` 部分依赖（见\nhttps://github.com/phpearth/docker-php/blob/master/docker/7.4-apache.Dockerfile[Docker\n官方构建文件]），提供web环境，内部暴露端口 `80`。\n\n本次以 `php-74-apache-xdebug-29`\n为例，在**项目所在的目录**启动并拉取容器：\n\n[source,shell]\n----\ndocker run --name php-web-dev -p 80:80 -e XDEBUG_CONFIG=remote_host=host.docker.internal -v $(pwd):/var/www/html -d phpstorm/php-73-apache-xdebug-27\n----\n\n具体参数不做解释啦，能安装 `Docker` 的应该都能明白，可以通过 `man`\n查一下。\n\n____\n需要注意以下两点：\n\n[arabic]\n. 其中的 `${pwd}` 是获取当前的工作目录路径，可以自己手动指定。或者\n* 对于 `Windows` 的 `cmd` 可以是 `%cd%`\n* 对于 `Windows` 的 `powershell` 可以不变。如果不行可以尝试 `${PWD}`\n. 通过 `-e` 设置的环境变量 `XDEBUG_CONFIG` 指定了远程的主机地址，对于\n`windows` 和 `Mac` 来说，`host.docker.internal` 即是主机地址（参考\nhttps://docs.docker.com/docker-for-windows/networking/[官网文档1] 与\nhttps://docs.docker.com/docker-for-mac/networking/[官网文档2]）。而对于\nLinux，则是**无法进行识别**的（参考\nhttps://github.com/docker/for-linux/issues/264[Github\nIssue]），这个时候可以使用 *主机名* 来指定（通过 `hostname`\n获取），请自己根据情况修改 。\n____\n\n然后直接访问 http://127.0.0.1[127.0.0.1]，结果如下：\n\nimage::https://resources.echocow.cn/file/2020/8/1/image-20200731211328720.png[image-20200731211328720]\n\n这样就跑起来啦。\n\n== Docker Compose 方式\n\n____\n注意：如果你是一步一步的来，请先停止上一步的容器：\n\n[source,shell]\n----\ndocker stop php-web-dev\n----\n____\n\n项目根目录创建一个 `docker-compose.yml` 文件，如下：\n\n[source,yaml]\n----\nversion: '3.8'\nservices:\n  webserver:\n    image: phpstorm/php-73-apache-xdebug-27\n    ports:\n      - \"80:80\"\n    volumes:\n      - ./:/var/www/html\n    environment:\n      XDEBUG_CONFIG: remote_host=host.docker.internal\n----\n\n对于 `Linux` ，修改 `environment`\n\n[source,yaml]\n----\n   ...\n    environment:\n      XDEBUG_CONFIG: remote_host=<hostname>\n----\n\n____\n注意：Docker Compose 和 Docker 的版本有所关系，具体参见\nhttps://docs.docker.com/compose/compose-file/compose-versioning/[官方文档]。\n____\n\n创建完成直接运行即可\n\nimage::https://resources.echocow.cn/file/2020/8/1/image-20200731212509592.png[image-20200731212509592]\n\n____\nTips: `phpstorm` 和 `idea` 一样，都有 `services`，可以直接通过\n`services` 进行容器管理。\n\nimage::https://resources.echocow.cn/file/2020/8/1/image-20200731212534550.png[image-20200731212534550]\n____\n\n访问测试 http://127.0.0.1[127.0.0.1]，结果同上。\n\n== Debug\n\n浏览器安装 `xdebug` 扩展插件，见\nhttps://www.jetbrains.com/help/phpstorm/browser-debugging-extensions.html?_ga=2.160701439.351768353.1596075455-1678276671.1595950120[官方文档]，`Zend Debugger`\n没有试过。\n\n访问 http://127.0.0.1[127.0.0.1] ，开启插件 `debug` 模式\n\nimage::https://resources.echocow.cn/file/2020/8/1/image-20200731214409388.png[image-20200731214409388]\n\n上述两种方式的 Debug 的方式都是一样的，所以一起说啦。首先打断点\n\nimage::https://resources.echocow.cn/file/2020/8/1/image-20200731212639298.png[image-20200731212639298]\n\n开启 `phpstorm` 的 `debug` 监听\n\n(开启前)\n\nimage::https://resources.echocow.cn/file/2020/8/1/image-20200731212753466.png[image-20200731212753466]\n\n(开启后)\n\nimage::https://resources.echocow.cn/file/2020/8/1/image-20200731212834049.png[image-20200731212834049]\n\n无论上述两种的那种运行方式，直接访问\nhttp://127.0.0.1[127.0.0.1]，会弹出如下界面：\n\nimage::https://resources.echocow.cn/file/2020/8/1/image-20200731213100779.png[image-20200731213100779]\n\n选择当前项目，`ACCEPT` 即可！随后就可以看到效果啦\n\nimage::https://resources.echocow.cn/file/2020/8/1/image-20200731213555345.png[image-20200731213555345]\n\n== 发生了什么\n\n其实这个过程很好理解，通过查看他的构建方式就知道，主要有以下几步：\n\n[arabic]\n. 拉取 `php7.4` 镜像，完成基本的依赖安装、`apache` 、`xdebug`安装\n. 指定当前工作目录映射到容器内的 `apache` 下，端口 `80` 进行映射\n. *指定 `xdebug` 的主机地址为我们宿主机*\n. 开启 `phpstorm` 的监听，以及文件的 `debug`映射\n\n这里需要提一下，其实我们在倒数第二部 `ACCEPT` 那里，主要是配置了一个\n`php server`：\n\nimage::https://resources.echocow.cn/file/2020/8/1/image-20200731214550471.png[image-20200731214550471]\n\n这个配置是十分重要的，你可以提前将它配置好，然后倒数第二部里面进行选择即可。如果是\n`Zend Debugger` ，无非就是修改 `Debugger`，但是*没有官方镜像支持*。\n\n== Docker Compose 编排\n\n下面我们加上另外一个容器：Mysql8，很简单：\n\n[source,yaml]\n----\nversion: '3.8'\nservices:\n  mysql-php-dev:\n    container_name: mysql-php-dev\n    image: mysql:8\n    command: --default-authentication-plugin=mysql_native_password\n    environment:\n      MYSQL_ROOT_PASSWORD: 123456\n    networks:\n      - php-mysql\n  webserver:\n    container_name: php-web-dev-1\n    depends_on:\n      - mysql-php-dev\n    image: phpstorm/php-73-apache-xdebug-27\n    ports:\n      - \"80:80\"\n    volumes:\n      - ./:/var/www/html\n    environment:\n      XDEBUG_CONFIG: remote_host=host.docker.internal\n    networks:\n      - php-mysql\n\nnetworks:\n  php-mysql:\n----\n\n修改代码：\n\n[source,php]\n----\n<?php\n$world = \"World\";\necho \"Hello，\", $world;\n$servername = \"mysql-php-dev\";\n$username = \"root\";\n$password = \"123456\";\n\n$conn = mysqli_connect($servername, $username, $password);\nif (!$conn) {\n    die(\"Connection failed: \" . mysqli_connect_error());\n}\necho \"连接成功\";\n----\n\n访问测试一下：\n\nimage::https://resources.echocow.cn/file/2020/8/1/image-20200731215831768.png[image-20200731215831768]\n\n搞定！\n\n","fields":{"slug":"/articles/2020/08/01/1596268325013.html","birthTime":"2020-08-01T07:52:05.192Z","modifiedTime":"2020-08-01","year":2020},"document":{"title":"Phpstorm + Docker / Docker Compose + xdebug 环境搭建"}},{"content":"= Spring Security OAuth2 Authorization Server 初体验\n:page-description: 好久没有写 Spring Security OAuth2的文章了，这段时间成长了很多，也发现以前文中存在的一些问题。后面慢慢改成。但是还是很激动的有好消息！\n:page-category: spring\n:page-image: https://b3logfile.com/bing/20200415.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2020/08/25/1598370094047.html\n:page-created: 1598370094100\n:page-modified: 1598370120551\n:toc:\n\n== Spring Security OAuth2 Authorization Server 初体验\n\n好久没有写 Spring Security OAuth2\n的文章了，这段时间成长了很多，也发现以前文中存在的一些问题。后面慢慢改成。但是还是很激动的有好消息！\n\n这周六，最让人兴奋的就是 Spring Security OAuth2 Authorization Server\n发布了 https://spring.io/blog/2020/08/21/get-the-very-first-bits-of-spring-authorization-server-0-0-1[初版本\n0.0.1]了！终于盼来了！从当初的宣布不再维护，到听取社区意见进行重写，再到今天发布\n0.0.1\n第一个小版本，八九个月了，还在使用以前的授权服务器，现在终于有新的东西了！而且还是基于最新的\nSpring Security 构建，可以直接无缝接入 Spring Security 中的 OAuth\nLogin、OAuth Resource Server。\n\n虽然不能在生产环境适用，但我们可以先来尝尝鲜！目前已经可以使用的功能如下：\n\n* OAuth 2.0 Authorization Code\nGrant — https://tools.ietf.org/html/rfc6749#section-4.1[RFC 6749] —\n授权吗模式\n* OAuth 2.0 Client Credentials\nGrant — https://tools.ietf.org/html/rfc6749#section-4.4[RFC 6749] -\n客户端令牌模式\n* JSON Web Token (JWT) — https://tools.ietf.org/html/rfc7519[RFC 7519] -\nJWT 令牌支持\n* JSON Web Signature (JWS) — https://tools.ietf.org/html/rfc7515[RFC\n7515] -JWS 令牌支持\n* JSON Web Key (JWK) — https://tools.ietf.org/html/rfc7517[RFC 7517] -\nJWK 端点支持\n* Key Management for providing key(s) when signing a JWT (JWS) — Jwt key\n管理\n\n主要涉及到的 RFC\n\n* https://tools.ietf.org/html/rfc6749[RFC-6749 The OAuth 2.0\nAuthorization Framework]\n* https://tools.ietf.org/html/rfc7515[RFC-7515 JSON Web Signature (JWS)]\n* https://tools.ietf.org/html/rfc7517[RFC-7517 JSON Web Key (JWK)]\n* https://tools.ietf.org/html/rfc7518[RFC-7518 JSON Web Algorithms\n(JWA)]\n* https://tools.ietf.org/html/rfc7519[RFC-7519 JSON Web Token (JWT)]\n\n当然对于每个RFC中都是部分实现，还没有完全实现。但是不影响我们体验。\n\n这篇文章适合具有 OAuth2 基础以及 Spring Security 基础的童鞋阅读。\n\n=== 在这之前\n\n初始化项目，使用 Gradle 进行构建\n\n[source,kotlin]\n----\nimplementation(\"org.springframework.boot:spring-boot-starter-web\")\nimplementation(\"org.springframework.security.experimental:spring-security-oauth2-authorization-server:0.0.1\"\n----\n\n=== 授权服务器\n\n由于是初版，并没有注解来完成自动化配置，事实上 OAuth\n模块迁移以后，都不使用注解来完成自动化配置了。\n\n[source,java]\n----\n@SpringBootApplication\npublic class AuthorizationServerJavaApplication {\n\n  public static void main(String[] args) {\n    SpringApplication.run(AuthorizationServerJavaApplication.class, args);\n  }\n\n}\n----\n\n添加一个安全配置并导入默认配置\n\n[source,java]\n----\n/**\n * Spring security config from authorization server.\n *\n * @author echo\n * @date 2020/8/23 13:56:02\n */\n@Configuration\n@Import(OAuth2AuthorizationServerConfiguration.class)\npublic class SecurityConfig  {\n\n  /**\n   * Give a client repository.\n   *\n   * @return RegisteredClientRepository\n   */\n  @Bean\n  public RegisteredClientRepository registeredClientRepository() {\n    RegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString())\n        .clientId(\"messaging-client\")\n        .clientSecret(\"secret\")\n        .clientAuthenticationMethod(ClientAuthenticationMethod.BASIC)\n        // Authorization Code Grant Type\n        .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)\n        // Client Credentials Grant Type\n        .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)\n        .redirectUri(\"http://example.com\")\n        .scope(\"message.read\")\n        .scope(\"message.write\")\n        .build();\n    return new InMemoryRegisteredClientRepository(registeredClient);\n  }\n\n  /**\n   * Give a default key manager.\n   * @return keyManager\n   */\n  @Bean\n  public KeyManager keyManager() {\n    return new StaticKeyGeneratingKeyManager();\n  }\n\n  /**\n   * Give a user.\n   * @return UserDetailsService\n   */\n  @Bean\n  public UserDetailsService users() {\n    UserDetails user = User.withDefaultPasswordEncoder()\n        .username(\"user1\")\n        .password(\"password\")\n        .roles(\"USER\")\n        .build();\n    return new InMemoryUserDetailsManager(user);\n  }\n\n}\n----\n\n我们在配置文件中做了如下几件事：\n\n[arabic]\n. 配置一个内存级的 `ClientRepository`，他实现了\n`RegisteredClientRepository` 接口，可以通过实现这个接口完成其他的 store\n进行存储客户端信息。\n. 配置一个静态的\n`KeyManaget`，初版没有只提供了一个，他的作用应该是为了管理多个 Key\n的情况，对不同的应用使用不同的 Key 进行管理而不是所有的 OAuth2\n客户端都使用同一个。这个是以前的授权服务器所没有的东西。\n. 配置一个默认的用户信息的 `Service`，这个属于 `Spring Security`\n的基础了，提供查询用户的服务。\n\n==== 授权码模式\n\n运行项目，然后按照授权码模式进行请求：\n\n[arabic]\n. 请求\nhttp://127.0.0.1:8080/oauth2/authorize?client_id=messaging-client&redirect_uri=http://example.com&response_type=code&scope=message.read，在\nURL 参数中进行指定客户端 id、授权类型、请求 scope 等。\n. 使用用户 `user1` 进行登陆。\n. 登陆成功后重定向到指定地址 example.com，其中包含 code 参数如下：\n* http://example.com/?code=Yfwoy3Lkuu_pdLPG0ttn50ezbHeDmDLZJrGsZEwuwrY%3D\n. 获取 code 参数 `Yfwoy3Lkuu_pdLPG0ttn50ezbHeDmDLZJrGsZEwuwrY%3D`，*进行\nURL 解码*，一定要解码，否则找不到。解码后\n`Yfwoy3Lkuu_pdLPG0ttn50ezbHeDmDLZJrGsZEwuwr=`。通过 POST 请求，获取\ntoken。\n* 编码的这里是一个坑，按照常理应该是由\n进行解码的，不然每个客户端都需要自己来解码一遍肯定是不对的。已经提了一个\nhttps://github.com/spring-projects-experimental/spring-authorization-server/issues/102[issue]\n\nimage::https://b3logfile.com/file/2020/08/solofetchupload2401606585440275624-b0493a47.png[Authorization]\n\nimage::https://b3logfile.com/file/2020/08/solofetchupload6968077758085459537-5e7e7c1f.png[image-20200825212051607]\n\n=== 客户端模式\n\n客户端模式没有什么好说的了，只验证请求头中的授权信息和 scope 而已。\n\nimage::https://b3logfile.com/file/2020/08/solofetchupload2906726793585363159-4b997cba.png[image-20200825212631184]\n\n获取 token\n\nimage::https://b3logfile.com/file/2020/08/solofetchupload869172233136295980-242f2021.png[image-20200825212700050]\n\n=== JWK 端点\n\n在新版中，我们不需要自己去配置 JWK\n端点了，已经帮我们弄好了，可以直接访问 `/oauth2/jwks` 查看\n\n[source,json]\n----\n{\n    \"keys\":[\n        {\n            \"kty\":\"RSA\",\n            \"e\":\"AQAB\",\n            \"use\":\"sig\",\n            \"kid\":\"fff84a76-437e-4198-8b99-e80171afa6fb\",\n            \"alg\":\"RS256\",\n            \"n\":\"pfeYq-vtmSwnI0FWveVyCB8jcrsgnY81RDr00yfggj8bPe6T53yNO4ghoY4f3noSGuU1vcT_7dUIGOcFT6A2SN0Omyta5XaMNGJfLZd9QSGApi4zbsaizXsbRPRkAGlcdq3SCYTylHcSP2hhL_Kxco4ZGCdbKHJEQY0mIQyAGZDLm_VPVGjpImuuzLhF3BPGJQbIR7H7qBjPkJPsHfflXV2jndQi-QWckRi_oIU2wEzLSHFKFAOzWotJbd-4LDiedM_SN9834NO2TdZULbcwuY2_i09BKxHP6I6FzQbAQLsDI484UdLa5pZjJ9mJxIZp0Da6AzFHSHtO4oKoR0muew\"\n        }\n    ]\n}\n----\n\n简单解释下：\n\n[cols=\",\",options=\"header\",]\n|===\n|Key |Value\n|kty（Key Type） |标识与密钥一起使用的加密算法族，如``RSA''或``EC''。\n\n|use（Public Key Use）\n|标识公钥的预期用途。``use''参数用于指示是否使用公钥加密数据或验证数据上的签名。\n\n|kid（Key ID） |用于匹配特定密钥。\n\n|alg（Algorithm） |标识要与密钥一起使用的算法。\n\n|e |RSA Key 的公共指数\n\n|n |RSA 私钥参数\n|===\n\nJWK RSA 参考 https://tools.ietf.org/html/rfc7517#section-9.3[RSA Private\nKey Representations and Blinding]。\n\n其主要定义来自\nhttps://github.com/spring-projects-experimental/spring-authorization-server/blob/master/oauth2-authorization-server/src/main/java/org/springframework/security/oauth2/server/authorization/web/JwkSetEndpointFilter.java#L98[org.springframework.security.oauth2.server.authorization.web.JwkSetEndpointFilter]。\n\n未使用 JWK 前进行验证 token\n\nimage::https://b3logfile.com/file/2020/08/solofetchupload255189275893034017-eb2a0623.png[image-20200825231353232]\n\n使用 JWK 进行验证 Token（在右下脚输入后，会自动更新左边的 JWS）\n\nimage::https://b3logfile.com/file/2020/08/solofetchupload2789815987656918357-fa395e92.png[image-20200825231558186]\n\n=== 总结\n\n先说说现在我发现的两个问题吧，见\nhttps://github.com/spring-projects-experimental/spring-authorization-server/issues/102[issue\n102].\n\n[arabic]\n. 回调地址中的 `code` 是经过 URL\n编码的，但是他并没有为我们解，需要每个客户端进行解码。\n. 请求 `/oauth2/token` 端点时，不能够携带 `client_id`\n参数，如果携带了他授权的类型就是客户端的了， 源码中\nhttps://github.com/spring-projects-experimental/spring-authorization-server/blob/master/oauth2-authorization-server/src/main/java/org/springframework/security/oauth2/server/authorization/authentication/OAuth2AuthorizationCodeAuthenticationProvider.java#L88[getPrincipal()]\n得到的类型就是 `String` 的了。在\nhttps://tools.ietf.org/html/rfc6749#section-4.1.3[RFC-6749\nsection-4.1.3]. 中提到\n\n====\nREQUIRED, if the client is not authenticating\nwith the authorization server as described in Section 3.2.1.\n\n如果在请求头中设置了客户端令牌，那么这个参数可以不需要。但是当我传递正确的客户端id的时候他应该忽视或者对他进行验证，而不是抛出错误给我，因为我的方式是没有问题的。\n====\n\n其他的慢慢测看看。而这次默认的就是使用了JWT作为签名，生成 JWS 作为\ntoken。JWE 可能还需要等一段时间。\n\n","fields":{"slug":"/articles/2020/08/25/1598370094047.html","birthTime":"2020-08-25T15:41:34.100Z","modifiedTime":"2020-08-25","year":2020},"document":{"title":"Spring Security OAuth2 Authorization Server 初体验"}},{"content":"// View this document online at https://asciidoctor.org/docs/asciidoc-writers-guide/\n= AsciiDoc Guide\nDan Allen <https://github.com/mojavelinux[@mojavelinux]>; Sarah White <https://github.com/graphitefriction[@graphitefriction]>\n:description: This guide describes the basic structure of an AsciiDoc document\n:keywords: AsciiDoc, Asciidoctor, syntax, reference, learn, how to, writers, authors\n:page-description: {description}\n:page-keywords: {keywords}\n:page-layout: docs\n:page-category: test\n:page-sort: 1\n:page-image: https://rmt.dogedoge.com/fetch/fluid/storage/hexo-static/cover.jpg?w=480&fmt=webp\nifndef::env-site[]\n:toc: left\n:icons: font\n:idprefix:\n:idseparator: -\n:sectanchors:\n:source-highlighter: highlightjs\nendif::[]\n:experimental:\n:mdash: &#8212;\n:language: asciidoc\n:source-language: {language}\n:table-caption!:\n:example-caption!:\n:figure-caption!:\n// Refs\n:url-docs-asciidoc: https://docs.asciidoctor.org/asciidoc/latest/\n:url-quickref: {url-docs-asciidoc}syntax-quick-reference/\n:asciidoctor-ref: https://asciidoctor.org/\n:asciidoctor-gem-ref: https://rubygems.org/gems/asciidoctor\n:uri-install: https://asciidoctor.org/docs/install-toolchain/\n:fopub-doc-ref: https://github.com/asciidoctor/asciidoctor-fopub/blob/master/README.adoc\n:docs-ref: https://asciidoctor.org/docs\n:gist-ref: https://gist.github.com\n:publican-ref: https://fedorahosted.org/publican\n:page-exclude: true\n\nThis guide provides a gentle introduction to AsciiDoc, a _plain text_ documentation *syntax* and *processor*.\nThis introduction is intended for anyone who wants to reduce the effort required to write and publish content, whether for technical documentation, articles, web pages or good ol'-fashioned prose.\n\nTIP: If you want to know what AsciiDoc is all about, find the answer in {url-docs-asciidoc}#about-asciidoc[About AsciiDoc].\nIf you're looking for a concise survey of the AsciiDoc syntax, consult the {url-quickref}[AsciiDoc Syntax Quick Reference].\n\nIn this guide, you'll learn:\n\n- The basic structure of an AsciiDoc document\n- How to create your first AsciiDoc document\n- How to add other structural elements such as lists, block quotes and source code\n- How to convert an AsciiDoc document to HTML, DocBook and PDF\n\nIn addition to covering the AsciiDoc basics, this guide also suggests a set of conventions to help you create more consistent documents and maximize your writing productivity.\n\nLet's dive in to AsciiDoc!\n\n== Writing in AsciiDoc\n\nThe goal of this section is to teach you how to compose your first AsciiDoc document.\nHopefully, when you look back, you'll agree it just makes sense.\n\nYour adventure with AsciiDoc begins in your favorite text editor.\n\n=== It's just text, mate.\n\nSince AsciiDoc syntax is just _plain text_, you can write an AsciiDoc document using _any_ text editor.\nYou don't need complex word processing programs like Microsoft Word, OpenOffice Writer or Google Docs.\nIn fact, you _shouldn't_ use these programs because they add cruft to your document (that you can't see) and makes conversion tedious.\n\nTIP: While it's true any text editor will do, I recommend selecting an editor that supports syntax highlighting for AsciiDoc.\nThe *[red]##c##[green]##o##[purple]##l##[fuchsia]##o##[blue]##r##* brings contrast to the text, making it easier to read.\nThe highlighting also confirms when you've entered the correct syntax for an inline or block element.\n\nThe most popular application for editing plain text on macOS is *TextMate*.\nA similar choice on Linux is *GEdit*.\nOn Windows, stay away from Notepad and Wordpad because they produce plain text which is not cross-platform friendly.\nOpt instead for a competent text editor like *Notepad++*.\nIf you're a programmer (or a writer with an inner geek), you'll likely prefer *Vim*, *Emacs*, or *Sublime Text*, all of which are available cross-platform.\nThe key feature all these editors share is syntax highlighting for AsciiDoc.\n\nOpen up your favorite text editor and get ready to write some AsciiDoc!\n\n=== Content is king!\n\nThe bulk of the content in a document is paragraph text.\nThis is why Asciidoctor doesn't require any special markup or attributes to specify paragraph content.\nYou can just start typing.\n\nIn Asciidoctor, adjacent or consecutive lines of text form a paragraph element.\nTo start a new paragraph after another element, such as a section title or table, hit the kbd:[RETURN] key twice to insert a blank line, and then continue typing your content.\n\n.Two paragraphs in an AsciiDoc document\n[source]\n----\nThis journey begins one late Monday afternoon in Antwerp.\nOur team desperately needs coffee, but none of us dare open the office door.\n\nTo leave means code dismemberment and certain death.\n----\n\n.The two paragraphs rendered using the default (html5) converter and stylesheet (asciidoctor.css)\n====\nThis journey begins one late Monday afternoon in Antwerp.\nOur team desperately needs coffee, but none of us dare open the office door.\n\nTo leave means code dismemberment and certain death.\n====\n\nJust like that, *you're writing in AsciiDoc!*\nAs you can see, it's just like writing an e-mail.\n\nSave the file with a file extension of `.adoc`.\n\nTIP: If you want to find out how to convert the document to HTML, DocBook or PDF, skip ahead to the section on <<converting-your-document>>.\n\n==== Wrapped text and hard line breaks\n\nSince adjacent lines of text are combined into a single paragraph when Asciidoctor converts a document, that means you can wrap paragraph text or put each sentence or phrase on a separate line.\nThe line breaks won't appear in the output.\n\nHowever, if you want the line breaks in a paragraph to be preserved, you can either use a space followed by a plus sign (`{plus}`) or set the `hardbreaks` option on the paragraph.\nThis results in a visible line break (e.g., `<br>`) following each line.\n\n[source]\n.Line breaks preserved using a space followed by the plus sign ({plus})\n----\nRubies are red, +\nTopazes are blue.\n----\n\n====\nRubies are red, +\nTopazes are blue.\n====\n\n[source]\n.Line breaks preserved using the hardbreaks option\n----\n[%hardbreaks]\nRuby is red.\nJava is black.\n----\n\n====\n[%hardbreaks]\nRuby is red.\nJava is black.\n====\n\nTo preserve line breaks throughout your whole document, add the `hardbreaks` attribute to the document's header.\n\n.Line breaks preserved throughout the document using the hardbreaks attribute\n[source]\n----\n= Line Break Doc Title\n:hardbreaks:\n\nRubies are red,\nTopazes are blue.\n----\n\n=== Admonitions\n\nThere are certain statements you may want to draw attention to by taking them out of the content's flow and labeling them with a priority.\nThese are called admonitions.\nIt's rendered style is determined by the assigned label (i.e., value).\nAsciidoctor provides five admonition style labels:\n\n* `NOTE`\n* `TIP`\n* `IMPORTANT`\n* `CAUTION`\n* `WARNING`\n\n.Caution vs. Warning\n[#caution-vs-warning]\n****\nWhen choosing the admonition type, you may find yourself getting confused between \"caution\" and \"warning\" as these words are often used interchangeably.\nHere's a simple rule to help you differentiate the two:\n\n* Use *CAUTION* to advise the reader to _act_ carefully (i.e., exercise care).\n* Use *WARNING* to inform the reader of danger, harm, or consequences that exist.\n\nTo find a deeper analysis, see https://www.differencebetween.com/difference-between-caution-and-vs-warning/.\n****\n\nWhen you want to call attention to a single paragraph, start the first line of the paragraph with the label you want to use.\nThe label must be uppercase and followed by a colon (`:`).\n\n.Admonition paragraph syntax\n[source]\n----\nWARNING: Wolpertingers are known to nest in server racks. <1> <2>\nEnter at your own risk.\n----\n<1> The label must be uppercase and immediately followed by a colon (`:`).\n<2> Separate the first line of the paragraph from the label by a single space.\n\n.Result: Admonition paragraph\n====\nWARNING: Wolpertingers are known to nest in server racks.\nEnter at your own risk.\n====\n\nAn admonition paragraph is rendered in a callout box with the admonition label--or its corresponding icon--in the gutter.\nIcons are enabled by setting the `icons` attribute on the document.\n\nNOTE: Admonitions can also encapsulate any block content, which we'll cover later.\n\n=== Mild punctuation, strong impact\n\nJust as we emphasize certain words and phrases when we speak, we can emphasize them in text by surrounding them with punctuation.\nAsciiDoc refers to this markup as _quoted text_.\n\n==== Quoted text\n\nFor instance, in an e-mail, you might \"`speak`\" a word louder by enclosing it in asterisks.\n\n[source]\nI can't believe it, we *won*!\n\nAs you would expect, the asterisks make the text *won* bold.\nYou can almost sense the emotion.\nThis is one example of quoted (i.e., formatted) text.\n\nNOTE: The term \"`quote`\" is used liberally here to apply to any symbols that surround text in order to apply emphasis or special meaning.\n\nHere are the forms of quoted text that AsciiDoc recognizes:\n\n.Bold, italic, and monospace formatting syntax\n[source]\n----\nbold *constrained* & **un**constrained\n\nitalic _constrained_ & __un__constrained\n\nbold italic *_constrained_* & **__un__**constrained\n\nmonospace `constrained` & ``un``constrained\n\nmonospace bold `*constrained*` & ``**un**``constrained\n\nmonospace italic `_constrained_` & ``__un__``constrained\n\nmonospace bold italic `*_constrained_*` & ``**__un__**``constrained\n----\n\nWhen you want to quote text (e.g., place emphasis) somewhere other than at the boundaries of a word, you need to double up the punctuation.\n\n.Result: Bold, italic, and monospace text\n====\nbold *constrained* & **un**constrained\n\nitalic _constrained_ & __un__constrained\n\nbold italic *_constrained_* & **__un__**constrained\n\nmonospace `constrained` & ``un``constrained\n\nmonospace bold `*constrained*` & ``**un**``constrained\n\nmonospace italic `_constrained_` & ``__un__``constrained\n\nmonospace bold italic `*_constrained_*` & ``**__un__**``constrained\n====\n\nAny quoted text can be prefixed with an attribute list.\nThe first positional attribute is treated as a role.\nThe role can be used to apply custom styling to the text.\nFor instance:\n\n[source]\nType the word [.userinput]#asciidoc# into the search bar.\n\nWhen converting to HTML, the word \"`asciidoc`\" is wrapped in `<span>` tags and the role is used as the element's CSS class:\n\n[source,xml]\n<span class=\"userinput\">asciidoc</span>\n\nYou can apply styles to the text using CSS.\n\nYou may not always want these substitutions to take place.\nIn those cases, you'll need to use markup to escape the text.\n\n==== Preventing substitution\n\nIf you are getting quoted text behavior where you don't want it, you can use a backslash or a passthrough macro to prevent it.\n\nAsciidoctor provides several approaches for preventing substitutions.\n\n.Backslash escaping\nTo prevent punctuation from being interpreted as formatting markup, precede it with a backslash (`\\`).\nIf the formatting punctuation begins with two characters (e.g., `+__+`), you need to precede it with two backslashes (`+\\\\+`).\nThis is also how you can prevent character and attribute references from substitution.\nWhen your document is processed, the backslash is removed so it doesn't display in your output.\n\n[source]\n----\n\\*Stars* will appear as *Stars*, not as bold text.\n\n\\&sect; will appear as an entity, not the &sect; symbol.\n\n\\\\__func__ will appear as __func__, not as emphasized text.\n\n\\{two-semicolons} will appear {two-semicolons}, not resolved as ;;.\n----\n\nAsciidoctor supports several forms of the passthrough macro.\n\ninline pass macro:: An inline macro named `pass` that can be used to passthrough content.\nSupports an optional set of substitutions.\n+\n[source]\n----\npass:[content like #{variable} passed directly to the output] followed by normal content.\n\ncontent with only select substitutions applied: pass:c,a[__<{email}>__]\n----\n\nsingle and double plus:: A special syntax for preventing text from being formatted.\nOnly escapes special characters for compliance with the output format and doesn't support explicit substitutions.\n\ntriple plus:: A special syntax for designating passthrough content.\nDoes not apply any substitutions (equivalent to the inline pass macro) and doesn't support explicit substitutions.\n\ndouble dollar (deprecated):: A deprecated special syntax for designating passthrough content.\nLike the triple plus, does not apply any substitutions and doesn't support explicit substitutions.\n\nCAUTION: Asciidoctor does not implement the block pass macro.\nInstead, you should use a <<pass-blocks,pass block>>.\n\n==== Inline pass macro and explicit substitutions\n\nTo exclude a phrase from substitutions and disable escaping of special characters, enclose it in the inline pass macro.\nFor example, here's one way to format text as underline when generating HTML from AsciiDoc:\n\n[source]\n----\nThe text pass:[<u>underline me</u>] is underlined.\n----\n\n====\nThe text pass:[<u>underline me</u>] is underlined.\n====\n\nIf you want to enable ad-hoc `quotes` substitution, then assign the `macros` value to `subs` and use the inline pass macro.\n\n------\n[subs=+macros] <1>\n----\nI better not contain *bold* or _italic_ text.\npass:quotes[But I should contain *bold* text.] <2>\n----\n------\n<1> `macros` is assigned to `subs`, which allows any macros within the block to be processed.\n<2> The pass macro is assigned the `quotes` value. Text within the square brackets will be formatted.\n\nThe inline pass macro does introduce additional markup into the source code that could make it invalid in raw form.\nHowever, the output it produces will be valid when viewed in a viewer (HTML, PDF, etc.).\n\n====\n[subs=+macros]\n----\nI better not contain *bold* or _italic_ text.\npass:quotes[But I should contain *bold* text.]\n----\n====\n\nThe inline pass macro also accepts shorthand values for specifying substitutions.\n\n* `c` = special characters\n* `q` = quotes\n* `a` = attributes\n* `r` = replacements\n* `m` = macros\n* `p` = post replacements\n\nFor example, the quotes text substitution value is assigned in the inline passthrough macro below:\n\n[source]\n----\nThe text pass:q[<u>underline *me*</u>] is underlined and the word \"`me`\" is bold.\n----\n\n====\nThe text pass:q[<u>underline *me*</u>] is underlined and the word \"`me`\" is bold.\n====\n\n==== Triple plus passthrough\n\nThe triple-plus passthrough works much the same way as the pass macro.\nTo exclude content from substitutions, enclose it in triple pluses (pass:[+++]).\n\n +++content passed directly to the output+++ followed by normal content.\n\nThe triple-plus macro is often used to output custom HTML or XML.\n\n[source]\n----\nThe text +++<u>underline me</u>+++ is underlined.\n----\n\n====\nThe text +++<u>underline me</u>+++ is underlined.\n====\n\n.Single plus enclosure\n\nTo exclude a phrase from substitutions, enclose it in plus signs (`+`).\n\n[source]\n----\nThis +*literal*+ will appear as *literal*.\n----\n\n==== Replacements\n\nAsciiDoc also recognizes textual representations of symbols, arrows and dashes.\n\n[cols=\"2,^1l,^1l,^1,2\"]\n.Textual symbol replacements\n|===\n|Name |Syntax |Unicode Replacement |Rendered |Notes\n\n|Copyright\n|(C)\n|&#169;\n|(C)\n|\n\n|Registered\n|(R)\n|&#174;\n|(R)\n|\n\n|Trademark\n|(TM)\n|&#8482;\n|(TM)\n|\n\n|Em dash\n|--\n|&#8212;\n|{empty}--{empty}\n|Only replaced if between two word characters, between a word character and a line boundary, or flanked by spaces.\n\nWhen flanked by space characters (e.g., `+a -- b+`), the normal spaces are replaced by thin spaces (\\&#8201;).\n\n|Ellipsis\n|...\n|&#8230;\n|...\n|\n\n|Single right arrow\n|->\n|&#8594;\n|->\n|\n\n|Double right arrow\n|=>\n|&#8658;\n|=>\n|\n\n|Single left arrow\n|<-\n|&#8592;\n|<-\n|\n\n|Double left arrow\n|<=\n|&#8656;\n|<=\n|\n\n|Typographic apostrophe\n|Sam's\n|Sam&#8217;s\n|Sam's\n|The typewriter apostrophe is replaced with the typographic (aka curly) apostrophe.\n|===\n\nThis mild punctuation does not take away from the readability of the text.\nIn fact, you could argue that it makes the text easier to read.\nWhat's important is that these are conventions with which you are likely already familiar.\n\nPunctuation is used in AsciiDoc to create another very common type of element in documents, _lists!_\n\n=== Lists, lists, lists\n\nThere are three types of lists supported in AsciiDoc:\n\n. Unordered\n. Ordered\n. Description\n\nUnordered and ordered lists are structurally very similar.\nThey consist of items that are prefixed by different types of markers (i.e., bullet).\nIn contrast, description lists--also called variable, labeled, or term-definition lists--are collections of terms that each have their own supporting content.\nUnlike unordered and ordered lists, description lists are rarely nested, though they often contain the former.\n\nLet's explore each type of list, then mix them together.\nWe'll also look at how to put complex content inside a list item.\n\n==== Lists of things\n\nIf you were to create a list in an e-mail, how would you do it?\nChances are, you'd mark list items using the same characters that Asciidoctor uses to find list items.\n\nIn the example below, each list item is marked using an asterisk (`{asterisk}`), the AsciiDoc syntax specifying an unordered list item.\n\n[source]\n----\n* Edgar Allan Poe\n* Sheri S. Tepper\n* Bill Bryson\n----\n\nA list item's first line of text must be offset from the marker (`{asterisk}`) by at least one space.\nIf you prefer, you can indent list items.\nBlank lines are required before and after a list.\nAdditionally, blank lines are permitted, but not required, between list items.\n\n.Rendered unordered list\n====\n* Edgar Allan Poe\n* Sheri S. Tepper\n* Bill Bryson\n====\n\nYou can add a title to a list by prefixing the title with a period (`.`).\n\n[source]\n----\n.Kizmet's Favorite Authors\n* Edgar Allan Poe\n* Sheri S. Tepper\n* Bill Bryson\n----\n\n.Rendered unordered list with a title\n====\n.Kizmet's Favorite Authors\n* Edgar Allan Poe\n* Sheri S. Tepper\n* Bill Bryson\n====\n\nWas your instinct to use a hyphen (`-`) instead of an asterisk to mark list items?\nGuess what?\nThat works too!\n\n[source]\n----\n- Edgar Allan Poe\n- Sheri S. Tepper\n- Bill Bryson\n----\n\nYou should reserve the hyphen for lists that only have a single level because the hyphen marker (`-`) doesn't work for nested lists.\nNow that we've mentioned nested lists, let's go to the next section and learn how to create lists with multiple levels.\n\n[#separating-lists]\n.Separating Lists\n****\nIf you have adjacent lists, they have the tendency to want to fuse together.\nTo force lists apart, insert a line comment (`//`) surrounded by blank lines between the two lists.\nHere's an example, where the `-` text in the line comment indicates the line serves as an \"`end of list`\" marker:\n\n[source]\n----\n* Apples\n* Oranges\n\n//-\n\n* Walnuts\n* Almonds\n----\n****\n\nTo nest an item, just add another asterisk (`{asterisk}`) to the marker, and another for each subsequent level.\n\n[source]\n----\n.Possible DefOps manual locations\n* West wood maze\n** Maze heart\n*** Reflection pool\n** Secret exit\n* Untracked file in git repository\n----\n\n.Rendered nested, unordered list\n====\n.Possible DefOps manual locations\n* West wood maze\n** Maze heart\n*** Reflection pool\n** Secret exit\n* Untracked file in git repository\n====\n\nIn Asciidoctor 1.5.7 and earlier you could only have up to six (6) levels of nesting (assuming one level uses the hyphen marker).\n\nSince Asciidoctor 1.5.8, you can nest unordered lists to any depth.\nKeep in mind, however, that some interfaces will begin flattening lists after a certain depth.\nGitHub starts flattening list after 10 levels of nesting.\n\n[source]\n----\n* level 1\n** level 2\n*** level 3\n**** level 4\n***** level 5\n* level 1\n----\n\n====\n* level 1\n** level 2\n*** level 3\n**** level 4\n***** level 5\n* level 1\n====\n\nWhile it would seem as though the number of asterisks represents the nesting level, that's not how depth is determined.\nA new level is created for each unique marker encountered.\nHowever, it's much more intuitive to follow the convention that the number of asterisks equals the level of nesting.\nAfter all, we're shooting for plain text markup that is readable _as is_.\n\n==== Ordering the things\n\nSometimes, we need to number the items in a list.\nInstinct might tell you to prefix each item with a number, like in this next list:\n\n[source]\n----\n1. Protons\n2. Electrons\n3. Neutrons\n----\n\nThe above works, but\nsince the numbering is obvious, the AsciiDoc processor will insert the numbers for you if you omit them:\n\n[source]\n----\n. Protons\n. Electrons\n. Neutrons\n----\n\n====\n. Protons\n. Electrons\n. Neutrons\n====\n\nIf you decide to use number for your ordered list, you have to keep them sequential.\nThis differs from other lightweight markup languages.\nIt's one way to adjust the numbering offset of a list.\nFor instance, you can type:\n\n[source]\n----\n4. Step four\n5. Step five\n6. Step six\n----\n\nHowever, in general the best practice is to use the `start` attribute to configure this sort of thing:\n\n[source]\n----\n[start=4]\n. Step four\n. Step five\n. Step six\n----\n\nTo present the items in reverse order, add the `reversed` option:\n\n[source]\n----\n[%reversed]\n.Parts of an atom\n. Protons\n. Electrons\n. Neutrons\n----\n\n====\n[%reversed]\n.Parts of an atom\n. Protons\n. Electrons\n. Neutrons\n====\n\nYou can give a list a title by prefixing the line with a dot immediately followed by the text (without leaving any space after the dot).\n\nHere's an example of a list with a title:\n\n[source]\n----\n.Parts of an atom\n. Protons\n. Electrons\n. Neutrons\n----\n\n====\n.Parts of an atom\n. Protons\n. Electrons\n. Neutrons\n====\n\nYou create a nested item by using one or more dots in front of each the item.\n\n[source]\n----\n. Step 1\n. Step 2\n.. Step 2a\n.. Step 2b\n. Step 3\n----\n\nAsciiDoc selects a different number scheme for each level of nesting.\nHere's how the previous list renders:\n\n.A nested ordered list\n====\n. Step 1\n. Step 2\n.. Step 2a\n.. Step 2b\n. Step 3\n====\n\n[TIP]\n====\nLike with the asterisks in an unordered list, the number of dots in an ordered list doesn't represent the nesting level.\nHowever, it's much more intuitive to follow this convention:\n\n[quote]\n# of dots = level of nesting\n\nAgain, we are shooting for plain text markup that is readable _as is_.\n====\n\nAsciidoctor works hard to infer the relationships between the items that are most intuitive to us humans.\nHere's an example of nesting an unordered list inside of an ordered list:\n\n[source]\n----\n. Linux\n* Fedora\n* Ubuntu\n* Slackware\n. BSD\n* FreeBSD\n* NetBSD\n----\n\n====\n. Linux\n* Fedora\n* Ubuntu\n* Slackware\n. BSD\n* FreeBSD\n* NetBSD\n====\n\nYou can spread the items out and indent the nested lists if that makes it more readable for you:\n\n[source]\n----\n. Linux\n\n  * Fedora\n  * Ubuntu\n  * Slackware\n\n. BSD\n\n  * FreeBSD\n  * NetBSD\n----\n\nThe following table shows the numbering scheme used by default for each nesting level.\n\n.Ordered list numbering scheme by level\n[cols=\"^2,3,3,4\"]\n|===\n|Level |Numbering Scheme |Examples |CSS class (HTML converter)\n\n|1\n|Arabic\n|1. 2. 3.\n|arabic\n\n|2\n|Lower Alpha\n|a. b. c.\n|loweralpha\n\n|3\n|Lower Roman\n|i. ii. iii.\n|lowerroman\n\n|4\n|Upper Alpha\n|A. B. C.\n|upperalpha\n\n|5\n|Upper Roman\n|I. II. III.\n|upperroman\n|===\n\nYou can override the number scheme for any level by setting its style (the first positional entry in a block attribute list).\nYou can also set the starting number using the `start` attribute:\n\n[source]\n----\n[lowerroman, start=5]\n. Five\n. Six\n[loweralpha]\n.. a\n.. b\n.. c\n. Seven\n----\n\n==== Description lists\n\nA description list (often abbreviate as dlist) is useful when you need to include a description or supporting text for one or more terms.\nEach item in a description list consists of:\n\n* one or more terms\n* a separator following each term (typically a double colon, `::`)\n* at least one space or endline\n* the supporting content (either text, attached blocks, or both)\n\nHere's an example of a description list that identifies parts of a computer:\n\n[source]\n----\nCPU:: The brain of the computer.\nHard drive:: Permanent storage for operating system and/or user files.\nRAM:: Temporarily stores information the CPU uses during operation.\nKeyboard:: Used to enter text or control items on the screen.\nMouse:: Used to point to and select items on your computer screen.\nMonitor:: Displays information in visual form using text and graphics.\n----\n\nBy default, the content of each item is displayed below the description when rendered.\nHere's a preview of how this list is rendered:\n\n.A basic description list\n====\nCPU:: The brain of the computer.\nHard drive:: Permanent storage for operating system and/or user files.\nRAM:: Temporarily stores information the CPU uses during operation.\nKeyboard:: Used to enter text or control items on the screen.\nMouse:: Used to point to and select items on your computer screen.\nMonitor:: Displays information in visual form using text and graphics.\n====\n\nIf you want the description and content to appear on the same line, add the horizontal style to the list.\n\n[source]\n----\n[horizontal]\nCPU:: The brain of the computer.\nHard drive:: Permanent storage for operating system and/or user files.\nRAM:: Temporarily stores information the CPU uses during operation.\n----\n\n====\n[horizontal]\nCPU:: The brain of the computer.\nHard drive:: Permanent storage for operating system and/or user files.\nRAM:: Temporarily stores information the CPU uses during operation.\n====\n\nThe content of a description list can be any AsciiDoc element.\nFor instance, we could rewrite the grocery list from above so that each aisle is a description rather than a parent outline list item.\n\n[source]\n----\nDairy::\n* Milk\n* Eggs\nBakery::\n* Bread\nProduce::\n* Bananas\n----\n\n====\nDairy::\n* Milk\n* Eggs\nBakery::\n* Bread\nProduce::\n* Bananas\n====\n\nDescription lists are quite lenient about whitespace, so you can spread the items out and even indent the content if that makes it more readable for you:\n\n[source]\n----\nDairy::\n\n  * Milk\n  * Eggs\n\nBakery::\n\n  * Bread\n\nProduce::\n\n  * Bananas\n----\n\n==== Hybrid lists\n\n[#three-hybrid]\nFinally, you can mix and match the three list types within a single hybrid list.\nAsciidoctor works hard to infer the relationships between the items that are most intuitive to us humans.\n\nHere's a list that mixes description, ordered, and unordered list items:\n\n[source]\n----\nOperating Systems::\n  Linux:::\n    . Fedora\n      * Desktop\n    . Ubuntu\n      * Desktop\n      * Server\n  BSD:::\n    . FreeBSD\n    . NetBSD\n\nCloud Providers::\n  PaaS:::\n    . OpenShift\n    . CloudBees\n  IaaS:::\n    . Amazon EC2\n    . Rackspace\n----\n\nHere's how the list is rendered:\n\n.A hybrid list\n====\nOperating Systems::\nLinux:::\n. Fedora\n* Desktop\n. Ubuntu\n* Desktop\n* Server\nBSD:::\n. FreeBSD\n. NetBSD\n\nCloud Providers::\nPaaS:::\n. OpenShift\n. CloudBees\nIaaS:::\n. Amazon EC2\n. Rackspace\n====\n\nYou can include more complex content in a list item as well.\n\n=== Links and images\n\nAsciiDoc makes it easy to include links, images and other types of media in a document.\n\n==== External links\n\nThere's nothing you have to do to make a link to a URL.\nJust include the URL in the document and AsciiDoc will turn it into a link.\n\nAsciidoctor recognizes the following common schemes without the help of any markup.\n\n[#schemes]\n* http\n* https\n* ftp\n* irc\n* mailto\n* \\email@email.com\n\nYou can think of these like implicit macro names (the bare email address being a special case).\nSince the URL in the example below begins with a protocol (in this case _https_ followed by a colon), Asciidoctor will automatically turn it into a hyperlink when it is processed.\n\n[source]\n----\nThe homepage for the Asciidoctor Project is https://asciidoctor.org. <1>\n----\n<1> The trailing period will not get caught up in the link.\n\nTo prevent automatic linking of an URL, prepend it with a backslash (`\\`).\n\n[source]\n----\nOnce launched, the site will be available at \\https://example.org.\n----\n\nIf you prefer URLs to be shown with the scheme hidden, set the `hide-uri-scheme` attribute in the document's header.\n\n[source]\n----\n:hide-uri-scheme:\n\nhttps://asciidoctor.org\n----\n\nWhen the hide-uri-scheme attribute is set, the above URL will render as follows:\n\n[source,xml]\n----\n<a href=\"https://asciidoctor.org\">asciidoctor.org</a>\n----\n\nNote the absence of _https_ inside the `<a>` element.\n\nTo attach a URL to text, enclose the text in square brackets at the end of the URL, thus making it an URL macro:\n\n[source]\n----\nChat with other Fedora users in the irc://irc.freenode.org/#fedora[Fedora IRC channel].\n----\n\nWhen a URL does not start with one of the <<schemes,common schemes>>, or the URL is not surrounded by word boundaries, you must use the `link` macro.\nThe `link` macro is a stronger version of a URI macro, which you can think of like an unconstrained macro.\nThe URL is preceded by `link:` and followed by square brackets.\nThe square brackets may include optional link text.\nThe URL is used for the text of the link if link text is not specified.\nPrior to 1.5.7, if the `linkattrs` document attribute is set, the text in square brackets is parsed as attributes, which allows a window name or role to be specified.\nSince 1.5.7, attributes are parsed automatically if an equal sign is found after a comma (e.g., `[link text,window=_blank]`).\n\n.Anatomy of a link macro\n[source]\n----\nlink:url[optional link text, optional target attribute, optional role attribute]\n----\n\nLet's consider a case where we need to use the link macro (instead of just a URI macro) to expand a link when it's not adjacent to a word boundary (i.e., unconstrained).\n\n[source]\n----\nsearch/link:https://ecosia.org[Ecosia]\n----\n\n====\nsearch/link:https://ecosia.org[Ecosia]\n====\n\nIf we didn't use the `link:` prefix in this case, the URL macro would not be detected by the parser.\n\n==== Target window and role attributes for links\n\n[#link-macro-attributes]\nPrior to 1.5.7, Asciidoctor _does not_ parse attributes in the link macro by default.\nIf you want attributes in the link macro to be parsed, you must set the `linkattrs` document attribute in the header.\nSince 1.5.7, this parsing is automatic (and the attribute is not required) if an equal sign is found after a comma.\nWhen attribute parsing is enabled, you can then specify the name of the target window using the `window` attribute.\n\n[source]\n----\n= Asciidoctor Document Title\n\nLet's view the raw HTML of the link:view-source:asciidoctor.org[Asciidoctor homepage,window=_blank].\n----\n\n====\nLet's view the raw HTML of the link:view-source:asciidoctor.org[Asciidoctor homepage,window=_blank].\n====\n\nSince `_blank` is the most common window name, we've introduced shorthand for it.\nJust end the link text with a caret (`+^+`):\n\n[source]\n----\nLet's view the raw HTML of the link:view-source:asciidoctor.org[Asciidoctor homepage^].\n----\n\nCAUTION: If you use the caret syntax more than once in a single paragraph, you may need to escape the first occurrence with a backslash.\n\nWhen attribute parsing is enabled, you can add a role (i.e., CSS class) to the link.\n\n[source]\n----\nChat with other Asciidoctor users on the https://discuss.asciidoctor.org/[*mailing list*^,role=green].\n----\n\n====\nChat with other Asciidoctor users on the https://discuss.asciidoctor.org/[*mailing list*^,role=green].\n====\n\nTIP: Links with attributes (including the subject and body segments on mailto links) are a feature unique to Asciidoctor.\nWhen they're enabled, you must surround the link text in double quotes if it contains a comma.\n\n==== Links to relative files\n\nIf you want to link to an external file relative to the current document, use the `link` macro in front of the file name.\n\n[source]\n----\nlink:protocol.json[Open the JSON file]\n----\n\nIf your file is an HTML file, you can link directly to a section in the document, append a hash (`#`) followed by the section's ID to the end of the file name.\n\n[source]\n----\nlink:external.html#livereload[LiveReload]\n----\n\nFor links to relative AsciiDoc documents cross references should be used.\n\n[reftext=\"Internal Cross References\"]\n==== Cross references\n\nA link to another location within an AsciiDoc document or between AsciiDoc documents is called a _cross reference_ (also referred to as an _xref_).\n\nIn Asciidoctor, the inline xref macro is used to create cross references (also called in-text or page citations) to content elements (sections, blocks, or phrases) that have an ID (regardless of whether that ID is explicit or auto-generated).\n\nYou create a cross reference by enclosing the ID of the target block or section (or the path of another document with an optional anchor) in double angled brackets.\n\n.Cross reference using the ID of the target section\n[source]\n----\nThe section <<images>> describes how to insert images into your document.\n----\n\n.Rendered cross reference using the ID of the target section\n====\nThe section <<images>> describes how to insert images into your document.\n====\n\nYou can also link to a block or section using the title by referencing its title, referred to as a [.term]_natural cross reference_.\nThe title must contain at least one space character or contain at least one uppercase letter.\n(If you are using Ruby < 2.4, that uppercase letter is restricted to the basic Latin charset).\n\n.Cross reference using a section's title\n[source]\n----\nRefer to <<Internal Cross References>>.\n----\n\n.Rendered cross reference using a section's title\n====\nRefer to <<Internal Cross References>>.\n====\n\nConverters usually use the reftext of the target as the default text of the link.\nWhen the document is parsed, attribute references in the reftext are substituted immediately.\nWhen the reftext is displayed, additional reftext substitutions are applied to the text (specialchars, quotes, and replacements).\n\nYou can override the reftext of the target by specifying alternative text at the location of the cross reference.\nAfter the ID, add a comma and then enter the custom text you want the cross reference to display.\n\n.Cross reference with custom xreflabel text\n[source]\n----\nLearn how to <<link-macro-attributes,use attributes within the link macro>>.\n----\n\n.Rendered cross reference using custom xreflabel text\n====\nLearn how to <<link-macro-attributes,use attributes within the link macro>>.\n====\n\nYou can also use the inline xref macro as an alternative to the double angled bracket form.\n\n.Inline xref macro\n[source]\n----\nLearn how to xref:link-macro-attributes[use attributes within the link macro].\n----\n\nCross references can also be used to create a link to a file relative to the current document.\nFor links to another AsciiDoc document, this is the preferred way.\n\nThe trailing hash (`#`) means that you refer to the top of the document.\n\n.Cross reference to the top of a relative AsciiDoc document\n[source]\n----\nRefer to <<document-b.adoc#,Document B>> for more information.\n----\n\n.Converted HTML for cross reference to relative AsciiDoc document\n[source,html]\n----\nRefer to <a href=\"document-b.html\">Document B</a> for more information.\n----\n\nTo link directly to a section in the document, append the section's ID after the hash (`#`).\n\n.Cross reference to a specific section of a relative AsciiDoc document\n[source]\n----\nRefer to <<document-b.adoc#section-b,Section B>> for more information.\n----\n\n.Converted HTML for cross reference to section of a relative AsciiDoc document\n[source,html]\n----\nRefer to <a href=\"document-b.html#section-b\">Section B</a> for more information.\n----\n\nIn both cases, this syntax will also work if you are inside the document you are referring to.\nThis is useful if you are sharing the same link across multiple documents.\n\nIn the link that is created from the inter-document cross reference, the source file extension is replaced with the value of the `outfilesuffix` attribute.\nTo customize the file extension used in the target of the link, simply change the value of this attribute.\n\nImage references are similar to links since they are also references to URLs or files.\nThe difference, of course, is that they display the image in the document.\n\n==== Images\n\nTo include an image on its own line (i.e., a _block image_), use the `image::` prefix in front of the file name and square brackets after it:\n\n[source]\nimage::sunset.jpg[]\n\nIf you want to specify alt text, include it inside the square brackets:\n\n[source]\nimage::sunset.jpg[Sunset]\n\nYou can also give the image an id, a title (i.e., caption), set its dimensions (i.e., width and height) and make it a link:\n\n[source]\n----\n[#img-sunset]\n.A mountain sunset\n[link=https://www.flickr.com/photos/javh/5448336655]\nimage::sunset.jpg[Sunset,300,200]\n----\n\nThe title of a block image is displayed underneath the image when rendered.\nHere's a preview:\n\n.A hyperlinked image with caption\n====\n[#img-sunset]\n.A mountain sunset\n[link=https://www.flickr.com/photos/javh/5448336655]\nimage::sunset.jpg[Sunset,300,200]\n====\n\nIMPORTANT: Images are resolved relative to the value of the `imagesdir` document attribute, which defaults to an empty value.\nThe `imagesdir` attribute can be an absolute path, relative path or base URL.\nIf the image target is a URL or an absolute path, the `imagesdir` prefix is _not_ added.\n\nTIP: You should use the `imagesdir` attribute to avoid hard coding the shared path to your images in every image macro.\n\nIf you want to include an image inline, use the `image:` prefix instead (notice there is only one colon):\n\n[source]\nPress the image:save.png[Save, title=\"Save\"] button.\n\nFor inline images, the optional title is displayed as a tooltip.\n\nIf paragraphs and lists are the meat of the document, then titles and sections are its bones.\nLet's explore how to give structure to our document.\n\n=== Titles, titles, titles\n\nAsciiDoc supports three types of titles:\n\n. Document title\n. Section title\n. Block title\n\nAll titles are optional in AsciiDoc.\nThis section will define each title type and explain how and when to use them.\n\n==== Document title\n\nJust as every e-mail has a subject, every document (typically) has a title.\nThe title goes at the top of an AsciiDoc document.\n\nTIP: A document title is an _optional_ feature of an AsciiDoc document.\n\nTo create a document title, begin the first line of the document with one equal sign followed by at least one space (``= ``), then the text of the title.\nThis syntax is the simplest (and thus recommended) way to declare a document title.\n\nHere's an example of a document title followed by an abbreviated paragraph:\n\n[source]\n----\n= Lightweight Markup Languages\n\nAccording to Wikipedia...\n----\n\nThe document title is part of the document header.\nSo, what else can go in the header?\nGood question.\n\n===== The document header\n\nNotice the blank line between the title line and the first line of content in the previous example.\nThis blank line separates the document header from the document body (in this case a paragraph).\nThe document title is part of the document header.\nIn all, the document header contains the title, author, revision information and document-wide attributes.\n\nCAUTION: If the title line is not offset by a blank line, it gets interpreted as a section title, which we'll discuss later.\n\nYour document now has a title, but what about an author?\nJust as every e-mail has a sender, every document must surely have an author.\nLet's see how to add additional information to the header, including an author.\n\nThere are two optional lines of text you can add immediately below the document title for defining common document attributes:\n\nLine 1:: Author name and an optional e-mail address\nLine 2:: An optional revision, a date and an optional remark\n\nLet's add these lines to our document:\n\n[source]\n----\n= Lightweight Markup Languages\nDoc Writer <doc.writer@asciidoc.org>\nv1.0, 2012-01-01\n\nAccording to Wikipedia...\n----\n\nThe header now contains a document title, an author, a revision number, and a date.\nThis information will typically be displayed as a formatted header at the top of the output document.\n\nNOTE: The header, including the document title, is _not required_.\nIf absent, the AsciiDoc processor will happily convert whatever content is present.\nThe header is only used when generating a full document.\nIt's excluded from the output of an embedded document.\n\nThe document header can also be used to define attributes.\n\n==== Document attributes\n\nAttributes are one of the features that sets AsciiDoc apart from other lightweight markup languages.\nYou can use attributes to toggle features or to store reusable or replacement content.\n\nMost often, attributes are defined in the document header.\nThere are scenarios where they can be defined inline, but we'll focus on the more common usage.\n\nAn attribute entry consists of a name surrounded by colons at the beginning of the line followed by at least one space, then the content.\nThe content is optional.\n\nHere's an example of an attribute that holds the version of an application:\n\n[source]\n----\n= User Guide\nDoc Writer <doc.writer@asciidoc.org>\n2012-01-01\n:appversion: 1.0.0\n----\n\nIMPORTANT: There should be no blank lines between the first attribute entry and the rest of the header.\n\nNow you can refer to this attribute anywhere in the document (where attribute substitution is performed) by surrounding the name in curly braces:\n\n[source]\nThe current version of the application is {appversion}.\n\nAttributes are also commonly used to store URLs, which can get quite lengthy.\nHere's an example:\n\n[source]\n----\n:fedpkg: https://apps.fedoraproject.org/packages/rubygem-asciidoctor\n----\n\nHere's the attribute in use:\n\n[source]\nInformation about the Asciidoctor package for Fedora can found at {fedpkg}.\n\nDocument attributes can also be used to toggle settings or set configuration variables that control the output generated by the AsciiDoc processor.\n\nFor example, to include a table of contents in your document, you can define the `toc` attribute:\n\n[source]\n----\n:toc:\n----\n\nTo undefine an attribute, place a `!` at the end of the name:\n\n[source]\n----\n:linkcss!:\n----\n\nYou can also set the base path to images (default: _empty_), icons (default: `./images/icons`), stylesheets (default: `./stylesheets`) and JavaScript files (default: `./javascripts`):\n\n[source]\n----\n:imagesdir: ./images\n:iconsdir: ./icons\n:stylesdir: ./styles\n:scriptsdir: ./js\n----\n\nTIP: Attribute values can also be set and overridden when invoking the AsciiDoc processor.\nWe'll explore that feature later.\n\nWhen you find yourself typing the same text repeatedly, or text that often needs to be updated, consider assigning it to a document attribute and use that instead.\n\nAs your document grows, you'll want to break the content into sections, like in this guide.\nThat's accomplished using section titles.\n\n==== Section titles\n\nSections partition the document into a content hierarchy.\nIn AsciiDoc, sections are defined using section titles.\n\nA section title uses the same syntax as a document title, except the line may begin with two to six equal signs instead of just a single equal sign.\nThe number of equal signs represents the nesting level (using a 0-based index).\n\nHere are all the section levels permitted in an AsciiDoc document (for an article doctype, the default), shown below the document title:\n\n[source]\n----\n= Document Title (Level 0)\n\n== Level 1 Section\n\n=== Level 2 Section\n\n==== Level 3 Section\n\n===== Level 4 Section\n\n====== Level 5 Section\n\n== Another Level 1 Section\n----\n\nNOTE: When the document is converted to HTML 5 (using the built-in `html5` backend), each section title becomes a heading element where the heading level matches the number of equal signs.\nFor example, a level 1 section (2 equal signs) maps to an `<h2>` element.\n\nSection levels cannot be chosen arbitrarily.\nThere are two rules you must follow:\n\n. A document can only have multiple level 0 sections if the `doctype` is set to `book`.footnote:[The default doctype is `article`, which only allows one level 0 section (i.e., the document title).]\n. Section levels cannot be skipped when nesting sections\n\nFor example, the following syntax is illegal:\n\n[source]\n----\n= Document Title\n\n= Illegal Level 0 Section (violates rule #1)\n\n== First Section\n\n==== Illegal Nested Section (violates rule #2)\n----\n\nContent above the first section (after the document title) is part of the preamble.\nOnce the first section is reached, content is associated with the section that precedes it:\n\n[source]\n----\n== First Section\n\nContent of first section\n\n=== Nested Section\n\nContent of nested section\n\n== Second Section\n\nContent of second section\n----\n\nTIP: In addition to the equals marker used for defining single-line section titles, Asciidoctor recognizes the hash symbol (`#`) from Markdown.\nThat means the outline of a Markdown document will convert just fine as an AsciiDoc document.\n\nTo have the processor auto-number the sections, define the `sectnums` attribute in the document header:\n\n[source]\n----\n:sectnums:\n----\n\nYou can also use this attribute entry above any section title in the document to toggle the auto-numbering setting.\nWhen you want to turn off the numbering, add an exclamation point to the end of the attribute name:\n\n[source]\n----\n:sectnums!:\n\n== Unnumbered Section\n----\n\n===== Preamble\n\nContent between the document title and the first section is called the preamble.\nIf a document title is not present, this content is not wrapped in a preamble section.\n\n[source]\n----\n= Document Title\n\npreamble\n\nanother preamble paragraph\n\n== First Section\n----\n\nTIP: When using the default Asciidoctor stylesheet, this preamble is rendered in the style of a lead (i.e., larger font).\n\nYou can also assign titles to individual elements.\n\n==== Block titles\n\nYou can assign a title to any paragraph, list or delimited block element.\nThe title is used as the element's caption.\nIn most cases, the title is displayed immediately above the content.\nIf the content is a figure or image, the title is displayed below the content.\n\nA block title is defined on a line above the element.\nThe line must begin with a dot (`.`) and be followed immediately by the title text with no spaces in between.\n\nHere's an example of a list with a title:\n\n[source]\n----\n.TODO list\n- Learn the AsciiDoc syntax\n- Install AsciiDoc\n- Write my document in AsciiDoc\n----\n\nSpeaking of block titles, let's dig into blocks and discover which types of blocks AsciiDoc supports.\n\n== Building blocks in AsciiDoc\n\nAsciiDoc provides a nice set of components for including non-paragraph text--such as block quotes, source code listings, sidebars and tables--in your document.\nThese components are referred to as _delimited blocks_ because they are surrounded by delimiter lines.\n\n=== Delimited blocks\n\nYou've already seen many examples of the listing block (i.e., code block), which is surrounded by lines with four or more hyphens.\n\n[source]\n....\n----\nThis is an example of a _listing block_.\nThe content inside is displayed as <pre> text.\n----\n....\n\nWithin the boundaries of a delimited block, you can enter any content or blank lines.\nThe block doesn't end until the ending delimiter is found.\nThe delimiters around the block determine the type of block, how the content is processed and converted and what elements are used to wrap the content in the output.\n\nHere's how the block above appears when converted to HTML and viewed in a browser:\n\n....\nThis is an example of a _listing block_.\nThe content inside is displayed as <pre> text.\n....\n\nHere's the HTML source that is generated:\n\n[source,html]\n----\n<div class=\"listingblock\">\n  <div class=\"content monospaced\">\n    <pre>This is an example of a _listing block_.\nThe content inside is displayed as &lt;pre&gt; text.</pre>\n  </div>\n</div>\n----\n\nYou should notice a few things about how the content is processed:\n\n* the HTML tag `<pre>` is escaped\n* the endlines are preserved\n* the phrase \"`listing block`\" is not italicized, despite having underscores around it.\n\nEach type of block is processed according to its purpose.\nLiteral blocks don't receive the full set of substitutions normally applied to a paragraph.\nSince a listing block is typically used for source code, substitutions are not desirable.\n\nThe following table identifies the delimited blocks that AsciiDoc provides by default, their purpose and what substitutions are performed on its content.\n\n[cols=\"1,1l,1,1\"]\n|===\n|Name (Style) |Line delimiter |Purpose |Substitutions\n\n|comment\n|....\n|Private notes that are not displayed in the output\n|none\n\n|example\n|....\n|Designates example content or defines an admonition block\n|normal\n\n|literal\n|....\n|Output text to be displayed exactly as entered\n|verbatim\n\n|listing, source\n|----\n|Source code or keyboard input to be displayed as entered\n|verbatim\n\n|open\n|--\n|Anonymous block that can act as any other block (except _pass_ or _table_)\n|varies\n\n|pass\n|++++\n|Raw text to be passed through unprocessed\n|none\n\n|quote, verse\n|____\n|A quotation or verse with optional attribution\n|normal\n\n|sidebar\n|****\n|Aside text displayed outside the flow of the document\n|normal\n\n|table\n|\\|===\n|Used to display tabular content or advanced layouts\n|varies\n|===\n\nIMPORTANT: AsciiDoc allows delimited lines to be longer than 4 characters.\n*Don't do it.*\nMaintaining long delimiter lines is a _colossal_ waste of time, not to mention arbitrary and error prone.\nUse the minimum line length required to create a delimited block and _move on_ to drafting the content.\nThe reader will never see the long delimiters anyway since they are not carried over to the output.\n\nThis table shows the substitutions performed by each substitution group referenced in the previous table.\n\n|===\n|Group / Substitution |Normal |Verbatim |None\n\nh|Special chars\n|Yes\n|Yes\n|No\n\nh|Callouts\n|No\n|Yes\n|No\n\nh|Quotes\n|Yes\n|No\n|No\n\nh|Attributes\n|Yes\n|No\n|No\n\nh|Replacements\n|Yes\n|No\n|No\n\nh|Macros\n|Yes\n|No\n|No\n\nh|Post replacements\n|Yes\n|No\n|No\n|===\n\nIn order to apply normal substitutions to an attribute value, surround it with single quotes.\nThere are two exceptions to this behavior: At the moment normal substitutions are not applied to\nthe `options` and `title` attribute values.\n\nYou can control how blocks are displayed using block metadata.\n\n=== Block metadata\n\nMetadata can be assigned to any block.\nThere are several types of metadata:\n\n* Title\n* Id (i.e., anchor)\n* Style (first unnamed block attribute)\n* Named block attributes\n\nHere's an example of a quote block that includes all types of metadata:\n\n[source]\n----\n.Gettysburg Address\n[[gettysburg]]\n[quote, Abraham Lincoln, Address delivered at the dedication of the Cemetery at Gettysburg]\n____\nFour score and seven years ago our fathers brought forth\non this continent a new nation...\n\nNow we are engaged in a great civil war, testing whether\nthat nation, or any nation so conceived and so dedicated,\ncan long endure. ...\n____\n----\n\nHere's the metadata extracted from this block:\n\nTitle:: Gettysburg Address\nId:: gettysburg\nStyle:: quote\nNamed block attributes::\n  attribution::: Abraham Lincoln\n  citetitle::: Address delivered at the dedication of the Cemetery at Gettysburg\n\nTIP: A block can have multiple block attribute lines.\nThe attributes will be aggregated.\nIf there is a name conflict, the last attribute defined wins.\n\nSome metadata is used as supplementary content, such as the title, whereas other metadata, such as the style, controls how the block is converted.\n\n=== Masquerading blocks\n\nSome blocks can masquerade as other blocks, a feature which is controlled by the block style.\nThe block style is the first positional attribute in the block attribute list.\n\n==== Admonition blocks\n\nFor instance, an example block can act as an admonition block:\n\n[source]\n----\n[NOTE]\n====\nThis is an example of an admonition block.\n\nUnlike an admonition paragraph, it may contain any AsciiDoc content.\nThe style can be any one of the admonition labels:\n\n* NOTE\n* TIP\n* WARNING\n* CAUTION\n* IMPORTANT\n====\n----\n\n==== Listing and source code blocks\n\nAt the start of this tutorial, remember how painful we said it is to insert source code into a document using a traditional word processor.\nThey just aren't designed for that use case.\n*AsciiDoc is!*\n\nIn fact, inserting source code in an AsciiDoc is incredibly easy.\nJust shove the raw code into a listing block.\n\n[source]\n....\n----\nrequire 'asciidoctor'\n\nputs Asciidoctor.convert_file 'mysample.adoc', to_file: false\n----\n....\n\nTo enable syntax highlighting in the output, set the style on the block to `source` and specify the source language in the second attribute position.\n\n[source]\n....\n[source,ruby]\n----\nrequire 'asciidoctor'\n\nputs Asciidoctor.convert_file 'mysample.adoc', to_file: false\n----\n....\n\nYou can even use source code that's in a separate file.\nJust use the AsciiDoc include directive:\n\n[source]\n....\n[source,ruby]\n----\n\\include::example.rb[]\n----\n....\n\nTo really show how well-suited AsciiDoc is for technical documentation, it also supports callouts in source code.\nCode callouts are used to explain lines of source code.\nThe explanations are specified below the listing and keyed by number.\nHere's an example:\n\n[source]\n....\n[source,ruby]\n----\nrequire 'asciidoctor'  # \\<1>\n\nAsciidoctor.convert_file 'mysample.adoc'  # \\<2>\n----\n<1> Imports the library\n<2> Reads, parses, and converts the file\n....\n\nHere's how the callouts appear when rendered:\n\n[#eg-callouts]\n.Source code with callouts\n====\n[source,ruby]\n----\nrequire 'asciidoctor'  # <1>\n\nputs Asciidoctor.convert_file 'mysample.adoc'  # <2>\n----\n<1> Imports the library\n<2> Reads, parses, and converts the file\n====\n\n==== Open blocks\n\nThe most versatile block of all is the open block.\nAn open block can act as any other block, with the exception of _pass_ and _table_.\nHere's an example of an open block acting as a sidebar:\n\n[source]\n----\n[sidebar]\n.Related information\n--\nThis is aside text.\n\nIt is used to present information related to the main content.\n--\n----\n\n[#pass-blocks]\n==== Passthrough blocks\n\nThe \"`anything goes`\" mechanism in AsciiDoc is the passthrough block.\nAs the name implies, this block passes the content of the block directly through to the output document.\nWhen you've encountered a complex requirement that you cannot meet using the AsciiDoc syntax, a passthrough block can come in very handy.\n\nFor example, let's say you want to embed a GitHub gist into your document.\nYou can define the following passthrough block:\n\n[source]\n----\n++++\n<script src=\"https://gist.github.com/piscisaureus/3342247.js\"></script>\n++++\n----\n\n////\n[source]\n----\n++++\n<video poster=\"images/movie-reel.png\">\n  <source src=\"videos/writing-zen.webm\" type=\"video/webm\">\n</video>\n++++\n----\n////\n\nCAUTION: Using a passthrough block couples your content to a specific output format, such as HTML.\nIf you're going to use a passthrough block, we recommend using {user-ref}#conditional-preprocessor-directives[conditional preprocessor directives] to associate the format-specific content with each backend you intend to support.\n\n//The block style can be used in the absense of block delimiters to promote a paragraph to a block element.\n\n=== Delimiters optional\n\nIf the content is contiguous (not interrupted by blank lines), you can forgo the use of the block delimiters and instead use the block style above a paragraph to repurpose it as one of the delimited block types.\n\nThis format is often used for single-line listings:\n\n[source]\n----\n[listing]\nsudo dnf install asciidoc\n----\n\nor single-line quotes:\n\n[source]\n----\n[quote]\nNever do today what you can put off 'til tomorrow.\n----\n\nWhile most blocks are linear, tables give you the ability to layout content horizontally as well.\n\n=== A new perspective on tables\n\nTables are one of the most refined areas of the AsciiDoc syntax.\nThey are easy to create, easy to read in raw form and also remarkably sophisticated.\nI recommend that you use tables sparingly because they interrupt the conversation with your readers.\nWhen they are the most suitable way to present the information, know that you've got a powerful tool in your hands.\n\nYou can think of a table as a delimited block that contains one or more bulleted lists.\nThe list marker is a vertical bar (`|`).\nEach list represents one row in the table and must share the same number of items (taking into account any column or row spans).\n\nHere's a simple example of a table with two columns and three rows:\n\n[source]\n----\n[cols=2*]\n|===\n|Firefox\n|Web Browser\n\n|Ruby\n|Programming Language\n\n|TorqueBox\n|Application Server\n|===\n----\n\nThe first non-blank line inside the block delimiter (`|===`) determines the number of columns.\nSince we are putting each column title on a separate line, we have to use the `cols` block attribute to explicitly state that this table has two columns.\nThe `*` is the repeat operator.\nIt means to repeat the column specification for the remainder of columns.\nIn this case, it means to repeat no special formatting (since none is present) across 2 columns.\n\nWe can make the first row of the table the header by setting the `header` option on the table.\n\n[source]\n----\n[cols=2*,options=header]\n|===\n|Name\n|Group\n\n|Firefox\n|Web Browser\n\n|Ruby\n|Programming Language\n\n...\n|===\n----\n\nYou can also define the `header` option using the following shorthand:\n\n```\n[%header,cols=2*]\n```\n\nAlternatively, we could define the header row on a single line offset from the body rows by a blank line, so neither the `cols` nor the `options` attributes are required.\n\n[source]\n----\n|===\n|Name |Group\n\n|Firefox\n|Web Browser\n\n...\n|===\n----\n\nThe content of each item (i.e., cell) can span multiple lines, as is the case with other lists in AsciiDoc.\nUnlike other lists, the content of each cell may contain blank lines without the need for a list continuation to hold them together.\nA new cell begins when another non-escaped vertical bar (`|`) is encountered.\n\n[source]\n----\n|===\n|Name |Group |Description\n\n|Firefox\n|Web Browser\n|Mozilla Firefox is an open-source web browser.\nIt's designed for standards compliance,\nperformance, portability.\n\n|Ruby\n|Programming Language\n|A programmer's best friend.\n\n...\n|===\n----\n\nYou can set the relative widths of each column using _column specifiers_{mdash}a comma-separated list of relative values defined in the `cols` block attribute.\nThe number of entries in the list determines the number of columns.\n\n[source]\n----\n[cols=\"2,3,5\"]\n|===\n|Name |Group |Description\n\n|Firefox\n|Web Browser\n|Mozilla Firefox is an open-source web browser.\nIt's designed for standards compliance,\nperformance and portability.\n\n|Ruby\n|Programming Language\n|A programmer's best friend.\n\n...\n|===\n----\n\nIf you want to include blocks or lists inside the contents of a column, you can put an `a` (for AsciiDoc) at the end of the column's relative value.\n\n[source]\n----\n[cols=\"2,3,5a\"]\n|===\n|Name |Group |Description\n\n|Firefox\n|Web Browser\n|Mozilla Firefox is an open-source web browser.\nIt's designed for:\n\n* standards compliance,\n* performance and\n* portability.\n\n|Ruby\n|Programming Language\n|A programmer's best friend.\n\n...\n|===\n----\n\nAlternatively, you can apply the AsciiDoc style to an individual cell by prefixing the vertical bar with an `a`:\n\n[source]\n----\na|Mozilla Firefox is an open-source web browser.\nIt's designed for:\n\n* standards compliance,\n* performance and\n* portability.\n----\n\nThere's a whole collection of column and cell specifiers you can use to format the contents of the table, including styling and alignment.\n\nAsciiDoc tables can also be created directly from CSV data.\nJust set the `format` block attribute to `csv` and insert CSV data inside the block delimiters, either directly:\n\n[source]\n----\n[%header,format=csv]\n|===\nArtist,Track,Genre\nBaauer,Harlem Shake,Hip Hop\nThe Lumineers,Ho Hey,Folk Rock\n|===\n----\n\nor using an `include::[]` directive:\n\n[source]\n----\n[%header,format=csv]\n|===\n\\include::tracks.csv[]\n|===\n----\n\nAsciidoctor 0.1.3 also recognizes shorthand notation for setting CSV and DSV table formats.\nThe first position of the table block delimiter (i.e., `|===`) can be replaced by a data delimiter to set the table format accordingly.\n\nInstead of specifying the `csv` format using an attribute, you can simply replace the leading pipe (`|`) with a comma (`,`).\n\n//[source]\n----\n,===\na,b,c\n,===\n----\n\nIn the same way, the `dsv` format can be specified by replacing the leading pipe (`|`) with a colon (`:`).\n\n//[source]\n----\n:===\na:b:c\n:===\n----\n\nThat's a pretty powerful option.\n\n== What else can AsciiDoc do?\n\nWe've covered many of the features of the AsciiDoc syntax, but it still has much more depth.\nAsciiDoc is simple enough for a README, yet can scale to meet the requirements of a publisher.\n\nHere are some of the features that the AsciiDoc syntax supports:\n\n* footnotes\n* indexes\n* appendix, preface, dedication, partintro\n* multi-line attributes\n* preprocessor directive (conditional markup)\n* mathematical formulas\n* musical notation\n* diagrams\n* block filters\n* themes\n* custom blocks, macros and output formats\n\nConsult the {user-ref}[Asciidoctor User Manual] to continue exploring the syntax and processor capabilities.\n\nThat's enough syntax for now.\nYou've created your first AsciiDoc document.\nNow it's time to convert the document into a presentable format.\nThis will give you a real appreciation for the power that AsciiDoc puts in your hands.\n\n== Converting your document\n\nWhile AsciiDoc syntax is designed to be readable in raw form, the intended audience for that format are writers and editors.\nReaders aren't going to appreciate the raw text nearly as much.\nAesthetics matter.\nYou'll want to apply nice typography with font sizes that adhere to the \"`golden ratio`\", colors, icons and images to give it the respect it deserves.\nThat's where the Asciidoctor processor comes in (*after* you have done the writing).\n\nThe Asciidoctor processor parses the document and translates it into a backend format, such as HTML, ePub, DocBook or PDF.\nAsciidoctor ships with a set of default templates in the tin, but you can customize the templates or create your own to get exactly the output you want.\n\nBefore you can use the Asciidoctor processor, you have to install the {asciidoctor-gem-ref}[Asciidoctor Ruby Gem].\nReview the {uri-install}[Asciidoctor Installation Guide] if you need help to install the gem.\n\n=== Converting a document to HTML 5\n\nAsciidoctor provides both a command line tool and a Ruby API for converting AsciiDoc documents to HTML 5, Docbook 5.0 and custom output formats.\n\nTo use Asciidoctor to generate an HTML document, type `asciidoctor` followed by your document's name on the command line.\n\n $ asciidoctor mysample.adoc\n\nIn Asciidoctor, the *html5* backend is the default, so there's no need to specify a backend explicitly to generate an HTML 5 document.\n\nAsciidoctor also provides a Ruby API, so you can generate an HTML document directly from a Ruby application:\n\n[source,ruby]\n----\nrequire 'asciidoctor'\n\nAsciidoctor.convert_file 'mysample.adoc'\n----\n\nAlternatively, you can capture the HTML output into a variable instead of writing it to a file:\n\n[source,ruby]\n----\nhtml = Asciidoctor.convert_file 'mysample.adoc', to_file: false, header_footer: true\nputs html\n----\n\nTo generate DocBook, just specify the backend option:\n\n[source,ruby]\n----\nAsciidoctor.convert_file 'mysample.adoc', backend: 'docbook'\n----\n\nOne of the strengths of Asciidoctor is that it can output to a variety of formats, not just HTML.\n\n=== Converting a document to DocBook\n\nDespite the fact that writing in DocBook is inhumane, it's useful as a portable document format.\nSince AsciiDoc syntax was designed with DocBook output in mind, the conversion is very good.\nThere's a corresponding DocBook element for each markup in the AsciiDoc syntax.\n\nAsciidoctor provides a Docbook 5.0 backend out of the box.\nTo convert the document to Docbook 5.0, call the processor with the backend flag set to `docbook5`:\n\n $ asciidoctor -b docbook5 mysample.adoc\n\nA new XML document, named `mysample.xml`, will now be present in the current directory:\n\n $ ls -1\n mysample.adoc\n mysample.html\n mysample.xml\n\nIf you're on Linux, you can view the DocBook file using Yelp:\n\n $ yelp mysample.xml\n\nDocBook is only an intermediary format in the Asciidoctor toolchain.\nYou'll either feed it into a system that processes DocBook (like {publican-ref}[publican]), or you can convert it to PDF using the {fopub-doc-ref}[asciidoctor-fopub tool].\n\n=== Output galore\n\nThere's really no end to the customization you can do to the output the Asciidoctor processor generates.\nWe've just scratched the surface here.\n\nCheck out the {user-ref}[Asciidoctor User Manual] and the {docs-ref}[Asciidoctor Docs Page] to learn more.\n\n=== Where else is AsciiDoc supported?\n\nThe easiest way to experiment with AsciiDoc is online.\nAsciiDoc document in a GitHub repository or a {gist-ref}[gist] is automatically converted to HTML and rendered in the web interface.\n\nIf you have a project on GitHub, you can write the README or any other documentation in AsciiDoc and the GitHub interface will show the HTML output for visitors to view.\n\n// image?\n\nGists, in particular, are a great way to experiment with AsciiDoc.\nJust create a new gist, name the file with the extension `.adoc` and enter AsciiDoc markup.\nYou can save the document as public or secret.\nIf you want to try AsciiDoc without installing any software, a gist is a great way to get started.\n\n// image?\n\nWhile there's plenty more of the AsciiDoc syntax and toolchain to explore, you know more than enough about it to write a range of documentation, from a simple README to a comprehensive user guide.\n\n== Wrap-up\n\nWriting in AsciiDoc should be no more complex than writing an e-mail.\nAll you need to compose a document in AsciiDoc is open a text editor and type regular paragraphs.\nOnly when you need additional semantics or formatting do you need to introduce markup.\nLet your instinct guide you when you need to remember what punctuation to use.\nThe AsciiDoc syntax is based on time-tested plain-text conventions from the last several decades of computing.\nHopefully you agree that the markup does not detract from the readability of the text in raw form, as that's a key goal of lightweight markup languages like AsciiDoc.\n\nAs humans, communication is what connects us through the ages and allows us to pass on knowledge.\nAsciiDoc enables you to focus on communicating rather than distracting you with other stuff that just gets in the way.\nCopy the text of an e-mail into a document and see how easy it to repurpose it as documentation.\nAlmost immediately, you'll find your writing zen and enjoy the rewarding experience of producing.\n\n[glossary]\n== Glossary\n\n[glossary]\nadmonition paragraph:: a callout paragraph that has a label or icon indicating its priority\nadmonition block:: a callout block containing complex content that has a label or icon indicating its priority\nbackend:: a set of templates for converting AsciiDoc source to different output format\ncross reference:: a link from one location in the document to another location marked by an anchor\nlist continuation:: a plus sign (`+`) on a line by itself that connects adjacent lines of text to a list item\nquoted text:: text which is enclosed in special punctuation to give it emphasis or special meaning\n","fields":{"slug":"/post/AsciiDoc Writer's Guide/","birthTime":"2021-06-13T07:23:38.345Z","modifiedTime":"2021-06-13","year":2021},"document":{"title":"AsciiDoc Guide"}},{"content":"= Spring Security Oauth2 从零到一完整实践（五） 自定义授权模式（手机、邮箱等）\n:page-description: Spring Security Oauth2 从零到一完整实践（五） 自定义授权模式（手机、邮箱等）\n:page-category: spring\n:page-image: https://img.hacpai.com/bing/20171113.jpg?imageView2/1/w/960/h/540/interlace/1/q/100\n:page-href: /articles/2019/07/30/1564498598952.html\n:page-created: 1564498599003\n:page-modified: 1587796030706\n:toc:\n\n____\n*注意注意：本文章适用于5.3以前的spring security以及spring boot 2.3.x\n以前的 oauth，以下内容应该为过时！spring 提供新的 oauth2\n授权服务器，目前正在https://spring.io/blog/2019/11/14/spring-security-oauth-2-0-roadmap-update[实验性阶段]，同时资源服务器由\noauth 模块迁移到 spring security 之内。*\n____\n\n很多时候我们需要做自定义的操作，这些自定义的操作能够让框架更加的符合我们的项目需求。那么对于\nSpring secruity oauth2\n来说，自定义的过程是怎么样的呢？这一节我们就来详细探讨下。\n\n====\nGitHub 地址： https://github.com/lizhongyue248/spring-security-oauth2-demo[spring-security-oauth2-demo]\n\n博客地址： https://echocow.cn[echocow.cn]\n====\n\n== 系列文章\n\n[arabic]\n. https://echocow.cn/articles/2019/07/14/1563082088646.html[较为详细的学习\noauth2 的四种模式其中的两种授权模式]\n. https://echocow.cn/articles/2019/07/14/1563082247386.html[spring boot\noauth2 自动配置实现]\n. https://echocow.cn/articles/2019/07/14/1563096109754.html[spring\nsecurity oauth2 授权服务器配置]\n. https://echocow.cn/articles/2019/07/20/1563611848587.html[spring\nsecurity oauth2 资源服务器配置]\n. spring security oauth2 自定义授权模式（手机、邮箱等）\n. https://echocow.cn/articles/2020/01/20/1579503807596.html[spring\nsecurity oauth2 踩坑记录]\n\n== Spring security oauth2 授权模式\n\n在我们前面学习与使用授权服务器的时候，我们使用到他的授权端点的三种授权模式\n\n* 授权码模式\n* 密码模式\n* 刷新授权（注意：RFC 中只有四种，是没有这个的，这是 Spring security\noauth2 自己添加的）\n\n除了这三种还有两种授权模式：\n\n* 客户端模式\n* 简化模式\n\n当然这两种授权模式要不太过简单不够安全要不就是只适合一些特殊场景，所以我没有提到。那么我们希望再添加自己的授权模式呢？比如我们希望通过手机或者邮箱来完成认证（手机验证码、邮箱验证码），这个怎么完成呢？对于这种情况，我们提供两种方式来完成：\n\n[arabic]\n. 添加自定义端点，单独的授权\n. 原有基础上，添加授权模式，强烈推荐\n\n____\n内容较长，如果你只希望知道如何添加授权模式，可以直接查看最后的\nhttps://echocow.cn/articles/2019/07/30/1564498598952.html#b3_solo_h2_18[推荐：添加授权模式]\n____\n\n两种方式各有好坏，不过在那之前，我们需要做一件事：验证码。对于手机或者邮箱，我们都是只能够通过验证码的方式进行验证，最主要的原因是用来确认用户身份的。在数据手机或者邮箱后，要提供相应的手机验证码和邮箱验证码进行验证方可，所以\n*发送-验证* 这个过程 是必不可少，我们接下来就来一步一步的分析，\n\n== 验证码\n\n*手机和邮箱登录的过程无非就是需要用户填入手机号或者邮箱号，然后我们下发一条短信或者一封邮件，内容就是验证码，然后授权授权服务器验证用户输入的验证码是否是我们发送的即可*。我们用一张图来诠释前后端分离的情况下验证码的流程\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190726173141.png[验证码]\n\n[arabic]\n. 用户请求得到登录页面，前端负责\n. 用户填写手机号完毕\n[arabic]\n.. 点击前端获取验证码按钮\n.. 向资源服务器发出验证码获取请求\n.. 资源服务器在内网**携带客户端信息**向授权服务器请求验证码\n.. 授权服务器生成验证码然后存入 Redis 或者内存中\n.. 返回生成结果(可省，一般来说，我们需要向一个运营商申请短信接口，在发短信验证码时如果等待发送结果会造成用户等待时间过长，所以一般不进行等待，如果获取失败，就让用户再获取一次即可)\n. 用户获取验证码，完成表单填写\n[arabic]\n.. 资源服务器**携带客户端**信息向授权服务器请求验证\n.. 返回结果\n\n这个过程比较复杂的就是需要授权服务器作为一个中间人，为什么要这样呢？*在上一篇文章中其实就提过，就是为了保护我们应用的\n客户端信息（即加密后的客户端 id\n和客户端密钥）*。资源服务器是在我们服务器上的，所以由资源服务器发起请求是不会暴露的，但是如果在前端发起就会暴露在用户面前了。\n\n这个过程在授权服务器中需要完成什么呢？\n\n[arabic]\n. 获取验证码\n. 验证验证码\n\n我们来看看第一步的流程图\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190726181157.png[one]\n\n这一步很简单，就是一个 Controller\n就可以完成。但是我们可以发现，出来类型不同，他们其他的房的操作都是相同的，包括生成验证码，存入验证码。那么其实不同的就是如何生成的问题了，这就可以将它抽象出来了。\n\n我们来看看第二步的流程图\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190726181417.png[two]\n\n这一步相对来说多一些流程，我们需要判断一下当前登录的请求是否是需要验证验证码的，然后选择和事验证码处理器金喜处理与验证，当我们验证通过了以后，才将它放行出去，如果不通过直接打回去就可以了。\n\n具体实现后面我们具体再说。\n\n=== 自定义端点\n\n如何理解自定义端点呢？很简单，就是我们直接新建一个端点。我们可以通过过滤器或者控制器直接创建一个新的端点，然后当他需要手机授权的时候访问这个端点即可，在此端点中完成整个验证、生成凭证的过程。比如我们需要的两个端点\n\n* 手机授权的端点我们设置为 `/oauth/sms`\n* 邮箱授权的端点我们设置为 `/oauth/email`\n\n那么当我们需要进行授权的时候直接请求相应的授权端口即可。自定义端点我们提供两种方式实现：\n\n[arabic]\n. 自己定义 `controller` 完成\n. 按照 `spring security` 的流程完成授权\n\n第一种方式是最简单最快捷的方式，第二种方式比较规范化。\n\n=== 添加授权模式\n\n添加授权模式就是在原来的端点 `/oauth/token`\n上，我们需要添加新的授权类型，即 `grant_type` 参数应该要多一个 `sms`\n或者 `email` 。这个十分好理解，例如对于授权码模式，我们参数如下：\n\n* grant_type —— 必须为 `authorization_code`\n* code\n* redirect_uri\n* client_id\n* scope\n\n对于我们的 sms 或者 email 应该如下：\n\n* grant_type —— 必须为 `sms` 或者 `email`\n* code\n* client_id\n* scope\n\n这个是最为标准的实现。\n\n== 验证码\n\n前面说到，验证码需要两个步骤才能够完成：\n\n[arabic]\n. 获取验证码\n. 验证验证码\n\n我们一步一步的来，不过在那之前我们需要创建一个新的模块来完成任务。我们的扩展主要是要在授权服务器上完成的，所以我们就需要创建一个授权服务器。\n\n____\n本节代码见模块：spring-security-oauth2-authorization-more-grant-type\n____\n\n模块添加如下依赖：\n\n[source,xml]\n----\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-security</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.security.oauth.boot</groupId>\n        <artifactId>spring-security-oauth2-autoconfigure</artifactId>\n        <version>${spring.boot.version}</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-data-redis</artifactId>\n    </dependency>\n</dependencies>\n----\n\n我们需要添加 Redis 依赖，来对验证码进行存储。我们的代码可以直接把\n`spring-security-oauth2-authorization`\n模块的复制过来改一下就可以，初始的代码结构如下：\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190727220838.png[all]\n\n记得启动一下项目确保她不会报错且 8000 端口能够正常访问，\n接下来我们再来完成我们接下来的事儿。\n\n=== 获取验证码\n\n我们再来回顾一下流程图：\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190726181157.png[one]\n\n按照流程图我们需要如下几步：\n\n[arabic]\n. *提供验证码处理器*\n. 获取验证码类型\n\n我们一步一步的完成\n\n==== 提供验证码处理器\n\n我们需要提供相应的验证码处理器来对验证码进行处理，我们前面提到流程的时候说过，*整个验证码的过程除了会因为验证码类型不同会选用不同的处理器去完成，其余的操作都一样的*。\n\n所以我们可以考虑使用设计模式来增加我们系统的扩展性。需要考虑如下的点：\n\n[arabic]\n. 面向接口编程\n. 开放封闭原则\n. 提供相同行为的不同实现\n. 提取公共部分代码，子类扩展不同部分\n\n前面三点很好的符合了 *策略设计模式* 的特点，而第四点则是比较适合\n*模板方法模式*，那么我们就将他们结合来用，来完成我们的验证码处理器。两种设计模式的具体作用请自行查找。\n\n我们先准备一个接口，即\n*抽象策略*，各种不同的验证码类型以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，用来进行验证码处理：\n\n[source,java]\n----\npublic interface ValidateCodeProcessor {\n\n    /**\n     * 创建验证码\n     *\n     * @param request 请求\n     * @throws Exception 异常\n     */\n    void create(ServletWebRequest request) throws Exception;\n\n    /**\n     * 验证验证码\n     *\n     * @param request 请求\n     */\n    void validate(ServletWebRequest request);\n\n}\n----\n\n然后我们定义一个抽象的 *模板方法*\n来实现这个抽象策略，*对于公共部分，就是我们的生成和保存操作，最后的发送操作是需要我们自己去自定义的*，所以我们交由子类来实现：\n\n[source,java]\n----\n/**\n * 模板方法实现抽象策略\n *\n * @author <a href=\"https://echocow.cn\">EchoCow</a>\n * @date 2019/7/28 下午9:48\n */\npublic abstract class AbstractValidateCodeProcessor implements ValidateCodeProcessor {\n    @Override\n    public void create(ServletWebRequest request) throws Exception {\n        String validateCode = generate(request);\n        save(request, validateCode);\n        send(request, validateCode);\n    }\n\n    @Override\n    public void validate(ServletWebRequest request) {\n\n    }\n\n    /**\n     * 发送验证码，由子类实现\n     *\n     * @param request      请求\n     * @param validateCode 验证码\n     */\n    protected abstract void send(ServletWebRequest request, String validateCode);\n\n    /**\n     * 保存验证码，保存到 redis 中\n     *\n     * @param request      请求\n     * @param validateCode 验证码\n     */\n    private void save(ServletWebRequest request, String validateCode) {\n\n    }\n\n    /**\n     * 生成验证码\n     *\n     * @param request 请求\n     * @return 验证码\n     */\n    private String generate(ServletWebRequest request) {\n        return null;\n    }\n\n}\n----\n\n对于不同的实现，比如手机验证码，就来继承这个抽象的策略就行了，也就是\n*具体策略*，如下：\n\n[source,java]\n----\n@Component\n@RequiredArgsConstructor\npublic class SmsValidateCodeProcessor extends AbstractValidateCodeProcessor {\n\n    @Override\n    protected void send(ServletWebRequest request, String validateCode) {\n        System.out.println(request.getHeader(\"sms\") +\n                \"手机验证码发送成功，验证码为：\" + validateCode);\n    }\n\n}\n----\n\n对于邮箱验证码呢？同样的，继承这个抽象策略就好了，他就是另外一种\n*具体策略*，如下\n\n[source,java]\n----\n@Component\n@RequiredArgsConstructor\npublic class EmailValidateCodeProcessor extends AbstractValidateCodeProcessor {\n\n    @Override\n    protected void send(ServletWebRequest request, String validateCode) {\n        System.out.println(request.getHeader(\"email\") +\n                \"邮箱验证码发送成功，验证码为：\" + validateCode);\n    }\n\n}\n----\n\n____\n具体策略我就做了打印，因为我并没有引入相应的 API 和依赖\n____\n\n现在的代码如下：\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190728221036.png[code]\n\n*接下来我们需要做的事情就是完善抽象策略中的公共方法*，包括：\n\n[arabic]\n. 生成验证码\n. 保存验证码\n. 验证验证码（后面再说）\n\n===== 生成验证码\n\n遵循面向对象的单一职责原则，对象不应该承担太多职责，我们为了解除耦合，独立出他的接口来，创建一个接口如下：\n\n[source,java]\n----\n/**\n * 验证码生成\n *\n * @author <a href=\"https://echocow.cn\">EchoCow</a>\n * @date 2019/7/28 下午10:17\n */\npublic interface ValidateCodeGenerator {\n    /**\n     * 生成验证码\n     *\n     * @param request 请求\n     * @return 生成结果\n     */\n    String generate(ServletWebRequest request);\n\n}\n----\n\n然后对于不同的验证码使用不同的生成策略，先引入一个以前写的随机字符串生成器如下：\n\n[source,java]\n----\n/**\n * 随机生成 验证码\n *\n * @author echo\n * @version 1.0\n * @date 19-5-20 15:45\n */\npublic class RandomCode {\n    private static final char[] MORE_CHAR = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray();\n    private static final Random RANDOM = new Random();\n\n    /**\n     * 随机生成验证码\n     *\n     * @param length 长度\n     * @param end    结束长度\n     * @return 结果\n     */\n    private static String random(Integer length, Integer end) {\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            result.append(MORE_CHAR[RANDOM.nextInt(end)]);\n        }\n        return result.toString();\n    }\n\n    /**\n     * 随机生成验证码\n     *\n     * @param length  长度\n     * @param onlyNum 是否只要数字\n     * @return 结果\n     */\n    public static String random(Integer length, Boolean onlyNum) {\n        return onlyNum ? random(length, 10) : random(length, MORE_CHAR.length);\n    }\n\n    /**\n     * 随机生成验证码\n     *\n     * @param length 长度\n     * @return 结果\n     */\n    public static String random(Integer length) {\n        return random(length, false);\n    }\n}\n----\n\n创建 `ValidateCodeGenerator` 的手机、邮箱实现类如下\n\n[source,java]\n----\n/**\n * 手机验证码生成器\n *\n * @author <a href=\"https://echocow.cn\">EchoCow</a>\n * @date 2019/7/28 下午10:23\n */\n@Component\npublic class SmsValidateCodeGenerator implements ValidateCodeGenerator {\n\n    @Override\n    public String generate(ServletWebRequest request) {\n        // 定义手机验证码生成策略，可以使用 request 中从请求动态获取生成策略\n        // 可以从配置文件中读取生成策略\n        return RandomCode.random(4, true);\n    }\n\n}\n----\n\n[source,java]\n----\n/**\n * 邮箱验证码生成器\n *\n * @author <a href=\"https://echocow.cn\">EchoCow</a>\n * @date 2019/7/28 下午10:23\n */\n@Component\npublic class EmailValidateCodeGenerator implements ValidateCodeGenerator {\n\n    @Override\n    public String generate(ServletWebRequest request) {\n        return RandomCode.random(6);\n    }\n\n}\n----\n\n修改抽象策略中的生成方法如下：（代码很简单就不赘述了）\n\n[source,java]\n----\n    /**\n     * 收集系统中所有的 {@link ValidateCodeGenerator} 接口实现。\n     */\n    @Autowired\n    private Map<String, ValidateCodeGenerator> validateCodeGenerators;\n\n\n    /**\n     * 生成验证码\n     *\n     * @param request 请求\n     * @return 验证码\n     */\n    private String generate(ServletWebRequest request) {\n        String type = getValidateCodeType(request);\n        String componentName = type + ValidateCodeGenerator.class.getSimpleName();\n        ValidateCodeGenerator generator = validateCodeGenerators.get(componentName);\n        if (Objects.isNull(generator)) {\n            throw new ValidateCodeException(\"验证码生成器 \" + componentName + \" 不存在。\");\n        }\n        return generator.generate(request);\n    }\n\n    /**\n     * 根据请求 url 获取验证码类型\n     *\n     * @return 结果\n     */\n    private String getValidateCodeType(String uri) {\n        String uri = request.getRequest().getRequestURI();\n        int index = uri.lastIndexOf(\"/\") + 1;\n        return uri.substring(index).toLowerCase();\n    }\n----\n\n当然，我自定义了一个异常，专门处理验证码的：\n\n[source,java]\n----\n/**\n * @author <a href=\"https://echocow.cn\">EchoCow</a>\n * @date 2019/7/28 下午10:34\n */\npublic class ValidateCodeException extends RuntimeException {\n    public ValidationException(String message) {\n        super(message);\n    }\n}\n----\n\n===== 保存验证码\n\n这里就无非是操作 Redis 了，写一个 `repository` 就可以了：\n\n[source,java]\n----\n/**\n * 验证码资源处理\n *\n * @author echo\n * @date 2019/7/28 下午10:44\n */\npublic interface ValidateCodeRepository {\n\n    /**\n     * 保存\n     *\n     * @param request 请求\n     * @param code    验证码\n     * @param type    类型\n     */\n    void save(ServletWebRequest request, String code, String type);\n\n    /**\n     * 获取\n     *\n     * @param request 请求\n     * @param type    类型\n     * @return 验证码\n     */\n    String get(ServletWebRequest request, String type);\n\n    /**\n     * 移除\n     *\n     * @param request 请求\n     * @param type    类型\n     */\n    void remove(ServletWebRequest request, String type);\n\n\n}\n----\n\n然后一个实现类，代码很简单，就不赘述了。\n\n[source,java]\n----\n/**\n * redis 验证码操作\n *\n * @author <a href=\"https://echocow.cn\">EchoCow</a>\n * @date 2019/7/28 下午10:44\n */\n@Component\n@RequiredArgsConstructor\npublic class ValidateCodeRepositoryImpl implements ValidateCodeRepository {\n\n    private final @NonNull RedisTemplate<String, String> redisTemplate;\n\n    @Override\n    public void save(ServletWebRequest request, String code, String type) {\n        redisTemplate.opsForValue().set(buildKey(request, type), code,\n                //  有效期可以从配置文件中读取或者请求中读取\n                Duration.ofMinutes(10).getSeconds(), TimeUnit.SECONDS);\n    }\n\n    @Override\n    public String get(ServletWebRequest request, String type) {\n        return redisTemplate.opsForValue().get(buildKey(request, type));\n    }\n\n    @Override\n    public void remove(ServletWebRequest request, String type) {\n        redisTemplate.delete(buildKey(request, type));\n    }\n\n    private String buildKey(ServletWebRequest request, String type) {\n        String deviceId = request.getHeader(type);\n        if (StringUtils.isEmpty(deviceId)) {\n            throw new ValidateCodeException(\"请求中不存在邮箱号\");\n        }\n        return \"code:\" + type + \":\" +  deviceId;\n    }\n}\n----\n\n然后注入到抽象策略中直接使用就好了：\n\n[source,java]\n----\n    @Autowired\n    private ValidateCodeRepository validateCodeRepository;\n\n    /**\n     * 保存验证码，保存到 redis 中\n     *\n     * @param request      请求\n     * @param validateCode 验证码\n     */\n    private void save(ServletWebRequest request, String validateCode) {\n        validateCodeRepository.save(request,validateCode,getValidateCodeType(request));\n    }\n----\n\n这样我们的验证码处理器就算完成一部分了，关于对验证码进行验证我们后面再说，现在我们的目录结构应该是这样的：\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190728225506.png[code]\n\n==== 获取验证码类型\n\n这一步非常简单，提供一个 控制器 即可，我们先编写一个空的控制器如下：\n\n[source,java]\n----\n/**\n * 动态获取验证码\n *\n * @author <a href=\"https://echocow.cn\">EchoCow</a>\n * @date 2019/7/28 下午10:57\n */\n@RestController\n@RequiredArgsConstructor\npublic class ValidateCodeController {\n\n    /**\n     * 通过 type 进行查询到对应的处理器\n     * 同时创建验证码\n     *\n     * @param request  请求\n     * @param response 响应\n     * @param type     验证码类型\n     * @throws Exception 异常\n     */\n    @GetMapping(\"/code/{type}\")\n    public void creatCode(HttpServletRequest request, HttpServletResponse response,\n                          @PathVariable String type) throws Exception {\n        //\n    }\n\n}\n----\n\n但是我们怎么指导是哪个来具体策略来处理呢？这里其实就是策略模式中的\n*环境类*，在这里决定使用哪一个具体的策略，我们创建一个 *策略分发器*\n来完成这件事，如下：\n\n[source,java]\n----\n/**\n * 验证码处理分发\n *\n * 通过传递过来的类型，从已经依赖注入容器中搜寻符合名称的组件。\n * 直接通过名称获取对应的 {@link ValidateCodeProcessor} 实现类\n *\n * @author <a href=\"https://echocow.cn\">EchoCow</a>\n * @date 2019/7/28 下午10:59\n */\n@Component\n@RequiredArgsConstructor\npublic class ValidateCodeProcessorHolder {\n\n    private final @NonNull Map<String, ValidateCodeProcessor> validateCodeProcessors;\n\n    /**\n     * 通过验证码类型查找\n     *\n     * @param type 验证码类型\n     * @return 验证码处理器\n     */\n    ValidateCodeProcessor findValidateCodeProcessor(String type) {\n        String name = type.toLowerCase() + ValidateCodeProcessor.class.getSimpleName();\n        ValidateCodeProcessor processor = validateCodeProcessors.get(name);\n        if (Objects.isNull(processor)){\n            throw new ValidateCodeException(\"验证码处理器\" + name + \"不存在\");\n        }\n        return processor;\n    }\n\n}\n----\n\n然后我们在控制器那里调用一下就可以了：\n\n[source,java]\n----\n    private final @NonNull ValidateCodeProcessorHolder validateCodeProcessorHolder;\n\n    /**\n     * 通过 type 进行查询到对应的处理器\n     * 同时创建验证码\n     *\n     * @param request  请求\n     * @param response 响应\n     * @param type     验证码类型\n     * @throws Exception 异常\n     */\n    @GetMapping(\"/code/{type}\")\n    public void createCode(HttpServletRequest request, HttpServletResponse response,\n                          @PathVariable String type) throws Exception {\n        validateCodeProcessorHolder.findValidateCodeProcessor(type)\n                .create(new ServletWebRequest(request, response));\n    }\n----\n\n我们测试一下访问：\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190728230609.png[get]\n\n然后查看控制台\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190728230619.png[console]\n\n再去看看 Redis\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190728230634.png[reids]\n\n可以看到验证码已经保存进去并且生成了的。\n\n=== 验证验证码\n\n接下来我们需要做的就是验证验证码的过程了，再来回顾一遍流程图\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190726181417.png[two]\n\n所以我们需要通过过滤器来实现，如果是手机或邮箱登录请求，我们就需要检验是否有验证码；如果不是，就放行。\n\n所以第一步我们就需要创建这么一个过滤器：\n\n[source,java]\n----\n/**\n * 验证码过滤器。\n *\n * <p>继承于 {@link OncePerRequestFilter} 确保在一次请求只通过一次filter</p>\n * <p>需要配置指定拦截路径，默认拦截 POST 请求</p>\n *\n * @author <a href=\"https://echocow.cn\">EchoCow</a>\n * @date 2019/7/28 下午11:15\n */\n@Slf4j\n@Component\n@RequiredArgsConstructor\npublic class ValidateCodeFilter extends OncePerRequestFilter {\n\n    private final @NonNull ValidateCodeProcessorHolder validateCodeProcessorHolder;\n    private Map<String, String> urlMap = new HashMap<>();\n    private AntPathMatcher antPathMatcher = new AntPathMatcher();\n\n    @Override\n    public void afterPropertiesSet() throws ServletException {\n        super.afterPropertiesSet();\n        // 路径拦截\n        urlMap.put(\"/oauth/sms\", \"sms\");\n        urlMap.put(\"/oauth/email\", \"email\");\n    }\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        String validateCodeType = getValidateCodeType(request);\n        if (!StringUtils.isEmpty(validateCodeType)) {\n            try {\n                log.info(\"请求需要验证！验证请求：\" + request.getRequestURI() + \" 验证类型：\" + validateCodeType);\n                validateCodeProcessorHolder.findValidateCodeProcessor(validateCodeType)\n                        .validate(new ServletWebRequest(request, response));\n            } catch (Exception e) {\n                e.printStackTrace();\n                return;\n            }\n        }\n        filterChain.doFilter(request, response);\n    }\n\n    private String getValidateCodeType(HttpServletRequest request) {\n        if (HttpMethod.POST.matches(request.getMethod())) {\n            Set<String> urls = urlMap.keySet();\n            for (String url : urls) {\n                // 如果路径匹配，就回去他的类型，也就是 map 的 value\n                if (antPathMatcher.match(url, request.getRequestURI())) {\n                    return urlMap.get(url);\n                }\n            }\n        }\n        return null;\n    }\n}\n----\n\n接下来我们就要去完成 验证 的具体逻辑了，回到我们的 *抽象策略* 中来：\n\n[source,java]\n----\n    @Override\n    public void validate(ServletWebRequest request) {\n        String type = getValidateCodeType(request);\n        String code = validateCodeRepository.get(request, type);\n        // 验证码是否存在\n        if (Objects.isNull(code)) {\n            throw new ValidateCodeException(\"获取验证码失败，请检查输入是否正确或重新发送！\");\n        }\n        // 验证码输入是否正确\n        if (!code.equalsIgnoreCase(request.getParameter(\"code\"))) {\n            throw new ValidateCodeException(\"验证码不正确，请重新输入！\");\n        }\n        // 验证通过后，清除验证码\n        validateCodeRepository.remove(request, type);\n    }\n----\n\n非常简单的验证逻辑，最后我们创建一个控制器来测试：\n\n[source,java]\n----\n@RestController\n@RequestMapping(\"/oauth\")\npublic class Oauth2Controller {\n\n    @PostMapping(\"/sms\")\n    public HttpEntity<?> sms() {\n        return ResponseEntity.ok(\"ok\");\n    }\n}\n----\n\n接下来就是把我们写好的过滤器添加到 Spring security 中的过滤链里去：\n\n[source,java]\n----\n    private final @NonNull ValidateCodeFilter validateCodeFilter;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                .authorizeRequests()\n                // 添加路径\n                .antMatchers(\"/oauth/sms\").access(\"permitAll()\")\n                .antMatchers(\"/oauth/email\").access(\"permitAll()\")\n                .antMatchers(\"/code/*\").permitAll()\n                .anyRequest()\n                .authenticated()\n                // 务必关闭 csrf，否则除了 get 请求，都会报 403 错误\n                .and()\n                .csrf().disable();\n\n        // 添加过滤器\n        http\n                .addFilterBefore(validateCodeFilter, AbstractPreAuthenticatedProcessingFilter.class);\n    }\n----\n\n然后我们来测试一下，先是启动后，请求验证码：\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190729173032.png[1]\n\n去控制台看看验证码多少\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190729173059.png[2]\n\n然后携带者设备号和验证码去请求一下测试接口 `/oauth/sms`\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190729173121.png[3]\n\n验证码image:https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190729173137.png[2]\n\n成功\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190729173148.png[3]\n\n看看控制台：\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190729173207.png[5]\n\n接下来我们再请求一次看看：\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190729173240.png[6]\n\n可以看到控制台报错了\n\nimage:https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190729173306.png[image]\n\n我们对于异常处理可以创建一个授权失败的异常处理器，然后将它用来接收所有的授权失败的异常。这个我们后面再来说。现在的代码结构如下：\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190729180157.png[all]\n\n=== 小修改\n\n接下来我们要修改前面的一个地方，前面我们的手机号和邮箱号是从请求头中获取的，我们应该从请求体中获取，修改\n`ValidateCodeRepositoryImpl` 类\n\n[source,java]\n----\n    private String buildKey(ServletWebRequest request, String type) {\n        String deviceId = request.getParameter(type);\n        if (StringUtils.isEmpty(deviceId)) {\n            throw new ValidateCodeException(\"请求中不存在 \" + type);\n        }\n        return \"code:\" + type + \":\" + deviceId;\n    }\n----\n\n再修改具体的策略如下：\n\n[source,java]\n----\n@Component\npublic class EmailValidateCodeProcessor extends AbstractValidateCodeProcessor {\n\n    @Override\n    protected void send(ServletWebRequest request, String validateCode) {\n        System.out.println(request.getParameter(\"email\") +\n                \"邮箱验证码发送成功，验证码为：\" + validateCode);\n    }\n\n}\n----\n\n[source,java]\n----\n@Component\npublic class SmsValidateCodeProcessor extends AbstractValidateCodeProcessor {\n\n    @Override\n    protected void send(ServletWebRequest request, String validateCode) {\n        System.out.println(request.getParameter(\"sms\") +\n                \"手机验证码发送成功，验证码为：\" + validateCode);\n    }\n\n}\n----\n\n这样我们就修改完毕了。另外我们修改一下现在的测试 `controller`\n，以防止后面的冲突了。修改 `Oauth2Controller` 为\n`SmsValidateCodeController` ，如下：\n\n[source,java]\n----\n@RestController\n@RequestMapping(\"/auth\")\npublic class SmsValidateCodeController {\n\n    @PostMapping(\"/sms\")\n    public HttpEntity<?> sms() {\n        return ResponseEntity.ok(\"ok\");\n    }\n}\n----\n\n修改安全配置 `SecurityConfig`\n\n[source,java]\n----\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                .authorizeRequests()\n                .antMatchers(\"/code/*\").access(\"permitAll()\")\n                .antMatchers(\"/auth/sms\").access(\"permitAll()\")\n                .anyRequest().authenticated()\n                .and()\n                .csrf().disable();\n\n\n        http\n                .addFilterBefore(validateCodeFilter, AbstractPreAuthenticatedProcessingFilter.class);\n    }\n----\n\n然后 `ValidateCodeFilter` 过滤器中的路径拦截也修改一下：\n\n[source,java]\n----\n    @Override\n    public void afterPropertiesSet() throws ServletException {\n        super.afterPropertiesSet();\n        // 路径拦截\n        urlMap.put(\"/auth/sms\", \"sms\");\n    }\n----\n\n修改完毕后务必再测试一次！现在的目录结构如下：\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190729182947.png[now]\n\n=== 回顾\n\n现在我们的验证码也算完成了，回顾一下，我们的类图是这样的\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190729174454.png[uml]\n\n我们整理下如下图：\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190729175414.png[uml]\n\n这个过程就好理解了：\n\n* `ValidateCodeController`\n：决策器，用来决定使用哪一个抽象策略的，同时接收用户请求。\n* `ValidateCodeProcessor` ：抽象策略接口\n* `AbstractValidateCodeProcessor`\n：抽象策略实现类，定义了模板方法和抽象策略\n* `ValidateCodeGenerator` ：抽象策略接口，不同的实现类是不同的具体策略\n\n其余的都是具体的实现类了。这样我们的一个可扩展的验证码就完成了，当我们需要扩展新的验证码时就简单多了，直接实现新的\n`AbstractValidateCodeProcessor` 子类和 `ValidateCodeGenerator`\n接口就可以了。后面我们会做一些改变，具体后面再说。\n\n现在我们已经有的验证码端点如下：\n\n[cols=\",,\",options=\"header\",]\n|===\n|类型 |请求 url |请求参数-请求体\n|获取手机验证码 |/code/sms |sms\n|获取邮箱验证码 |/code/email |email\n|===\n\n== 自定义端点\n\n我们接下来需要的是添加手机和邮箱登录，我们首先采取的是自定义端点的方式，也就是添加新的端点来接收手机和邮箱验证码的请求。我们前面说到，有两种方式来进行实现\n\n[arabic]\n. 定义 `controller` 完成\n. 按照 `spring security oauth2` 的流程完成授权\n\n第一种较为容易理解且简单，第二种则比较规范化，完全按照他的规范来实现。\n\n=== URL 设计\n\n在那之前我们要先进行 url 的设计。\n\n* 对于我们自己定义 `controller` 来完成的端点\n** 手机登录： `/custom/sms`\n** 邮箱登录： `/custom/email`\n* 对于按照 `spring security` 的流程来完成的端点\n** 手机登录： `/oauth/sms`\n** 邮箱登录： `/oauth/email`\n\n我们来一个一个学习和尝试。\n\n=== 自定义 `controller`\n\n顾名思义，我们需要自己创建 `controller`\n来完成授权，我们先完成不使用验证码的，也就是不加入过滤器中的。创建如下\n`controller` ：\n\n[source,java]\n----\n/**\n * 自定义 controller 授权端点\n *\n * @author <a href=\"https://echocow.cn\">EchoCow</a>\n * @date 2019/7/29 下午6:40\n */\n@Slf4j\n@RestController\n@RequiredArgsConstructor\n@RequestMapping(\"/custom\")\npublic class CustomToken {\n\n    @PostMapping(\"/{type}\")\n    public HttpEntity<?> auth(HttpServletRequest request, @PathVariable String type) {\n        return ResponseEntity.ok(type);\n    }\n\n}\n----\n\n我们这个请求应该是要被验证码的过滤器给拦截的，但是我们现在先不拦截以方便测试。\n\n*如果请求能够到达这个`controller`\n那就代表着他已经通过了验证码过滤器验证了，这个时候的请求是已经登录成功了的，所以我们应该直接给他下发\ntoken*。\n\n下发 token 的前提就是创建 token，这个 token\n怎么创建的呢？我们来看源码，他的 token 创建的核心类是\n`org.springframework.security.oauth2.provider.token.DefaultTokenServices`\n在这里你可以找到一个 `createAccessToken`\n方法。但是这个方法需要我们传递一个类型为 `OAuth2Authentication`\n的参数；而构建 `OAuth2Authentication` 我们需要 `OAuth2Request` 和\n`Authentication` 这两个参数；而构建 `OAuth2Request` 需要使用\n`TokenRequest#createOAuth2Request` 进行构建，构建 `Authentication`\n需要我们去用它的子类 `UsernamePasswordAuthenticationToken`\n来构建；而构建 `TokenRequest` 需要客户端信息，构建\n`UsernamePasswordAuthenticationToken` 需要 `UserDetails` ；而构建\n`UserDetails` 需要 `UserDetailsService` ，然后注入即可。\n\n这个过程有点复杂，我们用一张图来解释：\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190729214030.png[all]\n\n所以步骤应该如下：\n\n[arabic]\n. 从请求中获取客户端信息，然后通过 `ClientDetailsService` 构建为\n`ClientDetails`\n. 通过上一步的 `ClientDetails` 构建令牌请求 `TokenRequest`\n. 通过第一、二步的 `ClientDetails` 和 `TokenRequest` 构建 oauth2\n令牌请求 `OAuth2Request`\n. 通过 `UserDetailsService` 获取当前手机/邮箱号对应用户信息\n`UserDetails`\n. 通过 `UserDetails` 构建 `Authentication` 的实现类\n`UsernamePasswordAuthenticationToken`\n. 通过第三、五步的 `OAuth2Request` 和 `Authentication` 构建 oauth2\n身份验证授权 `OAuth2Authentication`\n. 通过上一步的 `OAuth2Authentication` 和\n`AuthorizationServerTokenServices` 创建 `token`\n\n这些从源码就可以看得出来，只是有些地方层次比较深，需要仔细一点去看看他的具体实现类。由于这个系列以实践为主，所以不会带大家一步一步去找和阅读源码。\n\n现在我们开始来写代码，修改我们的类最后如下：\n\n[source,java]\n----\n@Slf4j\n@RestController\n@RequiredArgsConstructor\n@RequestMapping(\"/custom\")\npublic class CustomToken {\n\n    private final @NonNull UserDetailsService userDetailsService;\n    private final @NonNull ClientDetailsService clientDetailsService;\n    private final @NonNull PasswordEncoder passwordEncoder;\n    private final @NonNull AuthorizationServerTokenServices authorizationServerTokenServices;\n\n    @PostMapping(\"/{type}\")\n    public HttpEntity<?> auth(HttpServletRequest request, @PathVariable String type) {\n        // 判断是否是我们自定义的授权类型\n        if (!type.equalsIgnoreCase(\"sms\") && !type.equalsIgnoreCase(\"email\")) {\n            throw new UnsupportedGrantTypeException(\"Unsupported grant type: \" + type);\n        }\n\n        log.info(type + \" login succeed！\");\n        // 1. 获取客户端认证信息\n        String header = request.getHeader(\"Authorization\");\n        if (header == null || !header.toLowerCase().startsWith(\"basic \")) {\n            throw new UnapprovedClientAuthenticationException(\"请求头中无客户端信息\");\n        }\n\n        // 解密请求头\n        String[] client = extractAndDecodeHeader(header);\n        if (client.length != 2) {\n            throw new BadCredentialsException(\"Invalid basic authentication token\");\n        }\n        String clientId = client[0];\n        String clientSecret = client[1];\n\n        // 获取客户端信息进行对比判断\n        ClientDetails clientDetails = clientDetailsService.loadClientByClientId(clientId);\n        if (clientDetails == null) {\n            throw new UnapprovedClientAuthenticationException(\"客户端信息不存在：\" + clientId);\n        } else if (!passwordEncoder.matches(clientSecret, clientDetails.getClientSecret())) {\n            throw new UnapprovedClientAuthenticationException(\"客户端密钥不匹配\" + clientSecret);\n        }\n        // 2. 构建令牌请求\n        TokenRequest tokenRequest = new TokenRequest(new HashMap<>(0), clientId, clientDetails.getScope(), \"custom\");\n        // 3. 创建 oauth2 令牌请求\n        OAuth2Request oAuth2Request = tokenRequest.createOAuth2Request(clientDetails);\n        // 4. 获取当前用户信息\n        UserDetails userDetails = userDetailsService.loadUserByUsername(request.getParameter(type));\n        // 5. 构建用户授权令牌\n        Authentication authentication = new UsernamePasswordAuthenticationToken(\n                userDetails.getUsername(), userDetails.getPassword(), userDetails.getAuthorities());\n        // 6. 构建 oauth2 身份验证令牌\n        OAuth2Authentication oAuth2Authentication = new OAuth2Authentication(oAuth2Request, authentication);\n        // 7. 创建令牌\n        OAuth2AccessToken accessToken = authorizationServerTokenServices.createAccessToken(oAuth2Authentication);\n        return ResponseEntity.ok(accessToken);\n    }\n\n\n    /**\n     * 对请求头进行解密以及解析\n     *\n     * @param header 请求头\n     * @return 客户端信息\n     */\n    private String[] extractAndDecodeHeader(String header) {\n        byte[] base64Token = header.substring(6).getBytes(StandardCharsets.UTF_8);\n        byte[] decoded;\n        try {\n            decoded = Base64.getDecoder().decode(base64Token);\n        } catch (IllegalArgumentException e) {\n            throw new BadCredentialsException(\n                    \"Failed to decode basic authentication token\");\n        }\n        String token = new String(decoded, StandardCharsets.UTF_8);\n        int delimiter = token.indexOf(\":\");\n\n        if (delimiter == -1) {\n            throw new BadCredentialsException(\"Invalid basic authentication token\");\n        }\n        return new String[]{token.substring(0, delimiter), token.substring(delimiter + 1)};\n    }\n}\n----\n\n每一步代码我都做了详细的解释，就不赘述了。\n\n____\nQ：为什么有些异常信息是英文的，有些异常信息是中文的？\n\nA：英文的是 Spring\n原本就有的，也就是当出现同样的错误的时候是相同的描述；中文的是因为由我自己自定义的异常信息，Spring\n里是没有的，我希望更加详细，所以使用中文的。\n____\n\n然后我们添加一个手机用户，在 `SecurityConfig` 中配置：\n\n____\n更好的设计是：我们创建 UserDetailsService 的实现类时，自定义一个\n`SmsUserDetailsService` 接口，然实现他的抽象方法 `loadUserBySms`\n，通过这个方法来加载手机用户，这样会更好。不过这已经属于这篇教程之外的东西了，这里从简。\n____\n\n[source,java]\n----\n    @Bean\n    @Override\n    public UserDetailsService userDetailsService() {\n        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();\n        manager.createUser(User.withUsername(\"user\")\n                .password(passwordEncoder().encode(\"123456\"))\n                .authorities(\"ROLE_USER\").build());\n        manager.createUser(User.withUsername(\"admin\")\n                .password(passwordEncoder().encode(\"admin\"))\n                .authorities(\"ROLE_ADMIN\").build());\n        manager.createUser(User.withUsername(\"13712341234\")\n                .password(passwordEncoder().encode(\"123456\"))\n                .authorities(\"ROLE_ADMIN\").build());\n        return manager;\n    }\n----\n\n此时没有添加验证码过滤，我们来测试一下：\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190729220020.png[test]\n\n已经获取到了，这种方式就算完成了。\n\n== 按照 `spring security` 的流程\n\n____\n*请确保在看这种模式之前，你能够理解上一种授权模式的整个流程，这节不再赘述*\n。\n____\n\n____\n请注意：这里是按照 `spring security` 的流程，并不是\n`spring security oauth2` 的流程来实现的，不能弄混淆。\n____\n\n这里就比较复杂，对于上一种方式，我们只要理清如何生成令牌就好了，但是着一种方式要在理清上一种方式的基础上，扩展\nSpring security oauth2\n的授权模式；也就是还需要我们去了解到他是如何决策使用哪一种授权模式的。\n\n同样，我会直接带大家来如何使用。在 Spring security\n中，实现登录校验与授权的过程核心是使用过滤器，通过过滤器对登录请求进行拦截，当是登录请求时，就做处理。而我们过滤器需要继承\n`org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter`\n这个类，它是**基于浏览器的 HTTP\n身份验证请求的抽象处理器**，我们可以参考他的子类\n`UsernamePasswordAuthenticationFilter`\n来写我们自己的过滤器。在那之前，我画一张图，让大家更好的理解整个授权过程：\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190730123909.png[auth]\n\n[arabic]\n. 过滤器拦截请求，验证请求参数，构建相应的令牌对象\n`SmsAuthenticationToken` 。\n. 授权管理器 `AuthenticationManager` 的子类 `ProviderManager`\n对令牌进行授权。\n. 授权的时候会去查找 `AuthenticationProvider` 的实现类，我们提供了\n`SmsAuthenticationProvider` 来实现。\n. 通过在 `AuthenticationProvider` 使用 `UserDetailsService`\n查找用户信息，如果找到就授权成功。\n. 授权成功后，将授权信息交给授权成功处理器\n`AuthenticationSuccessHandler` 进行处理，构建 token。\n\n这个过程相比起来要复杂一点，因为我们需要自己建一些实现类，总结下来如下：\n\n[arabic]\n. 继承 `AbstractAuthenticationProcessingFilter` 的过滤器\n. 继承 `AbstractAuthenticationToken` 的令牌请求\n. 实现 `AuthenticationProvider` 的授权提供者\n. 继承 `AbstractAuthenticationToken` 的成功处理器\n. 配置过滤器、成功处理器等\n\n我们一步一步的来，先是过滤器：\n\n[source,java]\n----\n/**\n * 短信登录授权过滤器\n *\n * @author <a href=\"https://echocow.cn\">EchoCow</a>\n * @date 2019/7/29 下午10:50\n */\npublic class SmsAuthenticationFilter extends AbstractAuthenticationProcessingFilter {\n\n    SmsAuthenticationFilter() {\n        // 需要拦截的路径\n        super(new AntPathRequestMatcher(\"/oauth/sms\", HttpMethod.POST.name()));\n    }\n\n    @Override\n    public Authentication attemptAuthentication(HttpServletRequest request,\n                                                HttpServletResponse response) throws AuthenticationException {\n        if (!HttpMethod.POST.matches(request.getMethod())) {\n            throw new AuthenticationServiceException(\n                    \"Authentication method not supported: \" + request.getMethod());\n        }\n        // 获取参数\n        String sms = obtainSms(request);\n        sms = sms == null ? \"\" : sms.trim();\n        // 我们需要创建我们自己的授权 token\n        SmsAuthenticationToken authRequest = new SmsAuthenticationToken(sms);\n        setDetails(request, authRequest);\n        // 授权管理器对请求进行授权\n        return this.getAuthenticationManager().authenticate(authRequest);\n    }\n\n    /**\n     * 获取请求中的 sms 值\n     *\n     * @param request 正在为其创建身份验证请求\n     * @return 请求中的 sms 值\n     */\n    private String obtainSms(HttpServletRequest request) {\n        return request.getParameter(\"sms\");\n    }\n\n    /**\n     * 提供以便子类可以配置放入 authentication request 的 details 属性的内容\n     *\n     * @param request     正在为其创建身份验证请求\n     * @param authRequest 应设置其详细信息的身份验证请求对象\n     */\n    private void setDetails(HttpServletRequest request,\n                            SmsAuthenticationToken authRequest) {\n        authRequest.setDetails(authenticationDetailsSource.buildDetails(request));\n    }\n\n}\n----\n\n再是创建我们自己的授权请求 `SmsAuthenticationToken`\n\n[source,java]\n----\n/**\n * 这里你完全可以使用 {@link UsernamePasswordAuthenticationToken}，他完全满足需求\n * 只是为了简单和统一，我改个名字并且去掉了 凭证 这个字段\n *\n * @author <a href=\"https://echocow.cn\">EchoCow</a>\n * @date 2019/7/29 下午10:53\n */\npublic class SmsAuthenticationToken extends AbstractAuthenticationToken {\n\n    private static final long serialVersionUID = SpringSecurityCoreVersion.SERIAL_VERSION_UID;\n\n    private final Object principal;\n\n    SmsAuthenticationToken(Object phone) {\n        super(null);\n        this.principal = phone;\n        setAuthenticated(false);\n    }\n\n    SmsAuthenticationToken(Object principal, Collection<? extends GrantedAuthority> authorities) {\n        super(authorities);\n        this.principal = principal;\n        super.setAuthenticated(true);\n    }\n\n    @Override\n    public Object getCredentials() {\n        return null;\n    }\n\n    @Override\n    public Object getPrincipal() {\n        return this.principal;\n    }\n\n    @Override\n    public void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException {\n        if (isAuthenticated) {\n            throw new IllegalArgumentException(\n                    \"Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead\");\n        }\n        super.setAuthenticated(false);\n    }\n\n    @Override\n    public void eraseCredentials() {\n        super.eraseCredentials();\n    }\n}\n----\n\n接下来就是授权提供者 `SmsAuthenticationProvider`\n\n[source,java]\n----\n/**\n * 授权提供者\n *\n * @author <a href=\"https://echocow.cn\">EchoCow</a>\n * @date 2019/7/29 下午10:57\n */\n@Setter\npublic class SmsAuthenticationProvider implements AuthenticationProvider {\n\n    private UserDetailsService userDetailsService;\n\n    @Override\n    public Authentication authenticate(Authentication authentication) throws AuthenticationException {\n        SmsAuthenticationToken authenticationToken = (SmsAuthenticationToken) authentication;\n        // 获取用户信息\n        UserDetails user = userDetailsService.loadUserByUsername(authenticationToken.getPrincipal().toString());\n        if (user == null) {\n            throw new InternalAuthenticationServiceException(\"无效认证\");\n        }\n        SmsAuthenticationToken authenticationResult = new SmsAuthenticationToken(user, user.getAuthorities());\n        authenticationResult.setDetails(authenticationToken.getDetails());\n        return authenticationResult;\n    }\n\n    @Override\n    public boolean supports(Class<?> authentication) {\n        // 通过类型进行匹配\n        return SmsAuthenticationToken.class.isAssignableFrom(authentication);\n    }\n}\n----\n\n最后就是授权成功处理器，在这里生成\ntoken，所以直接复制上一种模式的生成方法即可：\n\n[source,java]\n----\n/**\n * @author <a href=\"https://echocow.cn\">EchoCow</a>\n * @date 2019/7/29 下午11:03\n */\n@Slf4j\n@Component\n@SuppressWarnings(\"Duplicates\")\n@RequiredArgsConstructor\npublic class SmsSuccessHandler implements AuthenticationSuccessHandler {\n\n    private final @NonNull ClientDetailsService clientDetailsService;\n    private final @NonNull PasswordEncoder passwordEncoder;\n    private final @NonNull AuthorizationServerTokenServices authorizationServerTokenServices;\n    private final @NonNull ObjectMapper objectMapper;\n\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException {\n\n        log.info(\"Login succeed！\");\n        // 1. 获取客户端认证信息\n        String header = request.getHeader(\"Authorization\");\n        if (header == null || !header.toLowerCase().startsWith(\"basic \")) {\n            throw new UnapprovedClientAuthenticationException(\"请求头中无客户端信息\");\n        }\n\n        // 解密请求头\n        String[] client = extractAndDecodeHeader(header);\n        if (client.length != 2) {\n            throw new BadCredentialsException(\"Invalid basic authentication token\");\n        }\n        String clientId = client[0];\n        String clientSecret = client[1];\n\n        // 获取客户端信息进行对比判断\n        ClientDetails clientDetails = clientDetailsService.loadClientByClientId(clientId);\n        if (clientDetails == null) {\n            throw new UnapprovedClientAuthenticationException(\"客户端信息不存在：\" + clientId);\n        } else if (!passwordEncoder.matches(clientSecret, clientDetails.getClientSecret())) {\n            throw new UnapprovedClientAuthenticationException(\"客户端密钥不匹配\" + clientSecret);\n        }\n        // 2. 构建令牌请求\n        TokenRequest tokenRequest = new TokenRequest(new HashMap<>(0), clientId, clientDetails.getScope(), \"custom\");\n        // 3. 创建 oauth2 令牌请求\n        OAuth2Request oAuth2Request = tokenRequest.createOAuth2Request(clientDetails);\n        // 4. 获取当前用户信息（省略，前面已经获取过了）\n        // 5. 构建用户授权令牌 (省略，已经传过来了)\n        // 6. 构建 oauth2 身份验证令牌\n        OAuth2Authentication oAuth2Authentication = new OAuth2Authentication(oAuth2Request, authentication);\n        // 7. 创建令牌\n        OAuth2AccessToken accessToken = authorizationServerTokenServices.createAccessToken(oAuth2Authentication);\n\n        // 直接结束\n        response.setContentType(\"application/json;charset=utf-8\");\n        response.getWriter().write(objectMapper.writeValueAsString(accessToken));\n    }\n\n\n    /**\n     * 对请求头进行解密以及解析\n     *\n     * @param header 请求头\n     * @return 客户端信息\n     */\n    private String[] extractAndDecodeHeader(String header) {\n        byte[] base64Token = header.substring(6).getBytes(StandardCharsets.UTF_8);\n        byte[] decoded;\n        try {\n            decoded = Base64.getDecoder().decode(base64Token);\n        } catch (IllegalArgumentException e) {\n            throw new BadCredentialsException(\n                    \"Failed to decode basic authentication token\");\n        }\n        String token = new String(decoded, StandardCharsets.UTF_8);\n        int delimiter = token.indexOf(\":\");\n\n        if (delimiter == -1) {\n            throw new BadCredentialsException(\"Invalid basic authentication token\");\n        }\n        return new String[]{token.substring(0, delimiter), token.substring(delimiter + 1)};\n    }\n}\n----\n\n接下来就是将它配置进去，我们独立出他的配置\n`SmsAuthenticationSecurityConfig`\n\n[source,java]\n----\n/**\n * sms 配置\n *\n * @author <a href=\"https://echocow.cn\">EchoCow</a>\n * @date 2019/7/29 下午11:33\n */\n@Component\npublic class SmsAuthenticationSecurityConfig\n        extends SecurityConfigurerAdapter<DefaultSecurityFilterChain, HttpSecurity> {\n\n    @Autowired\n    @SuppressWarnings(\"all\")\n    private  UserDetailsService userDetailsService;\n    @Autowired\n    @SuppressWarnings(\"all\")\n    private SmsSuccessHandler smsSuccessHandler;\n\n    @Override\n    public void configure(HttpSecurity http)  {\n        // 过滤器\n        SmsAuthenticationFilter smsAuthenticationFilter = new SmsAuthenticationFilter();\n        smsAuthenticationFilter.setAuthenticationManager(http.getSharedObject(AuthenticationManager.class));\n        smsAuthenticationFilter.setAuthenticationSuccessHandler(smsSuccessHandler);\n\n        // 授权提供者\n        SmsAuthenticationProvider smsAuthenticationProvider = new SmsAuthenticationProvider();\n        smsAuthenticationProvider.setUserDetailsService(userDetailsService);\n\n        // 过滤器\n        http.authenticationProvider(smsAuthenticationProvider)\n                .addFilterAfter(smsAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);\n    }\n}\n----\n\n____\nQ：为什么这里使用字段注入呢？\n\nA：不使用构造器注入最主要的原因在于会造成依赖环，因为我们这里注入了\n`UserDetailsService` ，而在使用的时候， `SmsSuccessHandler`\n里面也同样注入了 `UserDetailsService` 而后面我们需要在 安全配置\n`SecurityConfig` 中引入 `SmsAuthenticationSecurityConfig` ，\n`UserDetailsService` 是在 `SecurityConfig`\n创建的，这个时候就会有一个依赖环的问题了。是使用的先呢？还是创建的先？Spring\n就不知道了，但是构造器注入是 Bean 初始化的时候给的，那个时候不一定有\n`UserDetailsService` ，所以使用字段注入，他会在有的时候自动注入进去。\n____\n\n接下来安全配置 `SecurityConfig` ：\n\n[source,java]\n----\n    private final @NonNull SmsAuthenticationSecurityConfig smsAuthenticationSecurityConfig;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                // 添加进去即可\n                .apply(smsAuthenticationSecurityConfig)\n                .and()\n                .authorizeRequests()\n                .antMatchers(\"/code/*\").permitAll()\n                .antMatchers(\"/auth/sms\").permitAll()\n                .antMatchers(\"/custom/**\").permitAll()\n                .anyRequest().authenticated()\n                .and()\n                .csrf().disable()\n                .formLogin()\n                .and()\n                .httpBasic();\n\n\n        http\n                .addFilterBefore(validateCodeFilter, AbstractPreAuthenticatedProcessingFilter.class);\n    }\n----\n\n运行测试一下：\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190730130906.png[test]\n\n可以看到已经 OK 了\n～！邮箱验证码登录也是类似，完全可以考虑两个结合起来，也是不难的，就不赘述了。现在的代码结构如下：\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190730132103.png[now]\n\n== 推荐：添加授权模式\n\n对于已有的路径 `/oauth/token`\n，他拥有五种授权模式，我们需要在这五种之上，添加两种授权模式：\n\n* sms\n* email\n\n而授权模式的核心接口是 `TokenGranter` ，他拥有一个抽象实现类\n`AbstractTokenGranter` ，我们需要自定义新的 `grant type`\n，就再写一个他的子类即可，如下：\n\n[source,java]\n----\n/**\n * @author <a href=\"https://echocow.cn\">EchoCow</a>\n * @date 2019/7/30 下午1:33\n */\npublic class SmsTokenGranter extends AbstractTokenGranter {\n    private static final String GRANT_TYPE = \"sms\";\n    private UserDetailsService userDetailsService;\n\n    /**\n     * 构造方法提供一些必要的注入的参数\n     * 通过这些参数来完成我们父类的构建\n     *\n     * @param tokenServices tokenServices\n     * @param clientDetailsService clientDetailsService\n     * @param oAuth2RequestFactory oAuth2RequestFactory\n     * @param userDetailsService userDetailsService\n     */\n    public SmsTokenGranter(AuthorizationServerTokenServices tokenServices,\n                           ClientDetailsService clientDetailsService,\n                           OAuth2RequestFactory oAuth2RequestFactory,\n                           UserDetailsService userDetailsService) {\n        super(tokenServices, clientDetailsService, oAuth2RequestFactory, GRANT_TYPE);\n        this.userDetailsService = userDetailsService;\n    }\n\n    /**\n     * 在这里查询我们用户，构建用户的授权信息\n     *\n     * @param client 客户端\n     * @param tokenRequest tokenRequest\n     * @return OAuth2Authentication\n     */\n    @Override\n    protected OAuth2Authentication getOAuth2Authentication(ClientDetails client, TokenRequest tokenRequest) {\n        Map<String, String> params = tokenRequest.getRequestParameters();\n        String sms = params.getOrDefault(\"sms\", \"\");\n        // 获取用户信息\n        UserDetails userDetails = userDetailsService.loadUserByUsername(sms);\n        if (Objects.isNull(userDetails)) {\n            throw new UsernameNotFoundException(\"用户不存在\");\n        }\n        // 构建用户授权信息\n        Authentication user = new UsernamePasswordAuthenticationToken(userDetails.getUsername(),\n                userDetails.getPassword(), userDetails.getAuthorities());\n        return new OAuth2Authentication(tokenRequest.createOAuth2Request(client), user);\n    }\n}\n----\n\n接下来我们把它添加到配置类 `Oauth2AuthorizationServerConfig` 中去\n\n[source,java]\n----\n    private final @NonNull UserDetailsService userDetailsService;\n\n    @Override\n    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {\n        clients.inMemory()\n                .withClient(\"oauth2\")\n                    .secret(\"$2a$10$uLCAqDwHD9SpYlYSnjtrXemXtlgSvZCNlOwbW/Egh0wufp93QjBUC\")\n                    .resourceIds(\"oauth2\")\n                    // 注意，这里要添加我们的 sms 授权方式\n                    .authorizedGrantTypes(\"password\", \"authorization_code\", \"refresh_token\", \"sms\")\n                    .authorities(\"ROLE_ADMIN\", \"ROLE_USER\")\n                    .scopes(\"all\")\n                    .accessTokenValiditySeconds(Math.toIntExact(Duration.ofHours(1).getSeconds()))\n                    .refreshTokenValiditySeconds(Math.toIntExact(Duration.ofHours(1).getSeconds()))\n                    .redirectUris(\"http://example.com\")\n                .and()\n                .withClient(\"test\")\n                    .secret(\"$2a$10$wlgcx61faSJ8O5I4nLiovO9T36HBQgh4RhOQAYNORCzvANlInVlw2\")\n                    .resourceIds(\"oauth2\")\n                    // 注意，这里要添加我们的 sms 授权方式\n                    .authorizedGrantTypes(\"password\", \"authorization_code\", \"refresh_token\", \"sms\")\n                    .authorities(\"ROLE_ADMIN\", \"ROLE_USER\")\n                    .scopes(\"all\")\n                    .accessTokenValiditySeconds(Math.toIntExact(Duration.ofHours(1).getSeconds()))\n                    .refreshTokenValiditySeconds(Math.toIntExact(Duration.ofHours(1).getSeconds()))\n                    .redirectUris(\"http://example.com\");\n    }\n\n    @Override\n    public void configure(AuthorizationServerEndpointsConfigurer endpoints) {\n        endpoints.authenticationManager(this.authenticationManager);\n        // 添加进去\n        endpoints.tokenGranter(tokenGranter(endpoints));\n    }\n\n    /**\n     * 重点\n     * 先获取已经有的五种授权，然后添加我们自己的进去\n     *\n     * @param endpoints AuthorizationServerEndpointsConfigurer\n     * @return TokenGranter\n     */\n    private TokenGranter tokenGranter(final AuthorizationServerEndpointsConfigurer endpoints) {\n        List<TokenGranter> granters = new ArrayList<>(Collections.singletonList(endpoints.getTokenGranter()));\n        granters.add(new SmsTokenGranter(endpoints.getTokenServices(), endpoints.getClientDetailsService(),\n                endpoints.getOAuth2RequestFactory(), userDetailsService));\n        return new CompositeTokenGranter(granters);\n    }\n----\n\n测试一下\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190730220005.png[test]\n\n邮箱授权同样的道理，不再赘述。\n\n=== 添加验证码验证\n\n现在已经有了新的授权模式，我们要对他把已经写好的验证码验证添加进去。\n\n自定义 controller 的方式很简单，就在 `ValidateCodeFilter` 的\n`afterPropertiesSet` 方法中添加路径即可，如下：\n\n[source,java]\n----\n    @Override\n    public void afterPropertiesSet() throws ServletException {\n        super.afterPropertiesSet();\n        // 路径拦截\n        urlMap.put(\"/auth/sms\", \"sms\");\n        urlMap.put(\"/custom/sms\", \"sms\");\n        urlMap.put(\"/oauth/sms\", \"sms\");\n    }\n----\n\n如果是按照 `spring security oauth2` 的流程，我们就需要再加一个过滤器了\n\n[source,java]\n----\n@Slf4j\n@Component\n@RequiredArgsConstructor\npublic class ValidateCodeGranterFilter extends OncePerRequestFilter {\n\n    private final @NonNull ValidateCodeProcessorHolder validateCodeProcessorHolder;\n    private RequestMatcher requestMatcher = new AntPathRequestMatcher(\"/oauth/token\", HttpMethod.POST.name());\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        if (requestMatcher.matches(request)){\n            String grantType = getGrantType(request);\n            if (\"sms\".equalsIgnoreCase(grantType) || \"email\".equalsIgnoreCase(grantType)){\n                try {\n                    log.info(\"请求需要验证！验证请求：\" + request.getRequestURI() + \" 验证类型：\" + grantType);\n                    validateCodeProcessorHolder.findValidateCodeProcessor(grantType)\n                            .validate(new ServletWebRequest(request, response));\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    return;\n                }\n            }\n        }\n        filterChain.doFilter(request, response);\n    }\n\n    private String getGrantType(HttpServletRequest request) {\n        return request.getParameter(\"grant_type\");\n    }\n\n}\n----\n\n同时需要修改一下 `AbstractValidateCodeProcessor`\n获取授权类型的方法，如下：\n\n[source,java]\n----\n    /**\n     * 根据请求 url 获取验证码类型\n     *\n     * @return 结果\n     */\n    private String getValidateCodeType(ServletWebRequest request) {\n        String uri = request.getRequest().getRequestURI();\n        if (uri.contains(\"/oauth/token\")) {\n            return request.getParameter(\"grant_type\");\n        } else {\n            int index = uri.lastIndexOf(\"/\") + 1;\n            return uri.substring(index).toLowerCase();\n        }\n    }\n----\n\n这样就可以了，就不用测试了。\n\n到此为止，我们的这节终于写完了！现在的代码结构如下！\n\nimage::https://resources.echocow.cn/file/2019/07/26/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_plasmashell_20190730224714.png[now]\n\n== 总结\n\n啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊，终于把这块写完了！个人觉得这块是最为复杂的一块，同时觉得也是最有价值的一块！因为现在真的没有谁比我总结这两种方式更加详细的了（偷笑\n～），并且每一个方式都对应不同的源码，需要去琢磨源码然后找到对应的文档然后再去实现，实现完后要总结出来画图在表述出来，实在太累了。不过收获很明显，找到了一些新的方法。不过我省略掉了源码分析部分，不然篇幅就太长太长了。从上面的描述中可以看到第三种方式应该是最好的，那么为什么我要说自定义\ncontroller\n的方式呢？因为这就是我学习的步骤，先是尽量自己实现，然后再用他写的方式来实现，再把他整合进入，如果没有自定义\ncontroller 那一快，我不可能知道他怎么创建 token\n的，后面都是一样。一开始我只会第一种，年初的时候我用的就是第一种；后面学会了第二种，大概是今年四月份把；然后第三种是写文章的时候才会的，所以我给学校写的授权服务器中是用的第二种，后面要考虑重构一下嘿嘿嘿嘿\n～写文章真的好累好累啊，但是收获不小呢！而且放假了好开心 ～后面加油\n～！考虑要不要写一篇源码分析了哈哈，oauth2\n的源码好多地方抖都翻了好几遍了昂。。。后面考虑整理一下然后写一个源码分析的。加油\n～！！\n\n","fields":{"slug":"/articles/2019/07/30/1564498598952.html","birthTime":"2019-07-30T14:56:39.003Z","modifiedTime":"2020-04-25","year":2019},"document":{"title":"Spring Security Oauth2 从零到一完整实践（五） 自定义授权模式（手机、邮箱等）"}}]}}}